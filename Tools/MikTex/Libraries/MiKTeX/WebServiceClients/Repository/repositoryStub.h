/* repositoryStub.h
   Generated by gSOAP 2.8.29 for Repository.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_mtrep	"http://miktex.org/2006/06/repository"
#define SOAP_NAMESPACE_OF_mtrep2	"http://miktex.org/2007/03/repository"
#define SOAP_NAMESPACE_OF_mtrep3	"http://miktex.org/2007/07/repository"
#define SOAP_NAMESPACE_OF_mtrep4	"http://miktex.org/2007/10/repository"
#define SOAP_NAMESPACE_OF_mtrep5	"http://miktex.org/2008/05/repository"
#define SOAP_NAMESPACE_OF_mtrep6	"http://miktex.org/2015/06/repository"
#define SOAP_NAMESPACE_OF_mtrep7	"http://miktex.org/2015/08/repository"

#ifndef repositoryStub_H
#define repositoryStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20829
# error "GSOAP VERSION 20829 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* Repository.h:399 */
#ifndef SOAP_TYPE_mtrep__RepositoryIntegrity
#define SOAP_TYPE_mtrep__RepositoryIntegrity (61)
/* mtrep:RepositoryIntegrity */
enum mtrep__RepositoryIntegrity {
	mtrep__RepositoryIntegrity__Intact = 0,
	mtrep__RepositoryIntegrity__Corrupted = 1,
	mtrep__RepositoryIntegrity__Unknown = 2
};
#endif

/* Repository.h:409 */
#ifndef SOAP_TYPE_mtrep__PackageLevel
#define SOAP_TYPE_mtrep__PackageLevel (62)
/* mtrep:PackageLevel */
enum mtrep__PackageLevel {
	mtrep__PackageLevel__Essential = 0,
	mtrep__PackageLevel__Basic = 1,
	mtrep__PackageLevel__Advanced = 2,
	mtrep__PackageLevel__Complete = 3
};
#endif

/* Repository.h:420 */
#ifndef SOAP_TYPE_mtrep__RepositoryStatus
#define SOAP_TYPE_mtrep__RepositoryStatus (63)
/* mtrep:RepositoryStatus */
enum mtrep__RepositoryStatus {
	mtrep__RepositoryStatus__Online = 0,
	mtrep__RepositoryStatus__Offline = 1,
	mtrep__RepositoryStatus__Unknown = 2
};
#endif

/* Repository.h:446 */
#ifndef SOAP_TYPE_mtrep3__RepositoryIntegrity
#define SOAP_TYPE_mtrep3__RepositoryIntegrity (64)
/* mtrep3:RepositoryIntegrity */
enum mtrep3__RepositoryIntegrity {
	mtrep3__RepositoryIntegrity__Intact = 0,
	mtrep3__RepositoryIntegrity__Corrupted = 1,
	mtrep3__RepositoryIntegrity__Unknown = 2
};
#endif

/* Repository.h:456 */
#ifndef SOAP_TYPE_mtrep3__PackageLevel
#define SOAP_TYPE_mtrep3__PackageLevel (65)
/* mtrep3:PackageLevel */
enum mtrep3__PackageLevel {
	mtrep3__PackageLevel__Essential = 0,
	mtrep3__PackageLevel__Basic = 1,
	mtrep3__PackageLevel__Advanced = 2,
	mtrep3__PackageLevel__Complete = 3
};
#endif

/* Repository.h:467 */
#ifndef SOAP_TYPE_mtrep3__RepositoryStatus
#define SOAP_TYPE_mtrep3__RepositoryStatus (66)
/* mtrep3:RepositoryStatus */
enum mtrep3__RepositoryStatus {
	mtrep3__RepositoryStatus__Online = 0,
	mtrep3__RepositoryStatus__Offline = 1,
	mtrep3__RepositoryStatus__Unknown = 2
};
#endif

/* Repository.h:485 */
#ifndef SOAP_TYPE_mtrep4__RepositoryIntegrity
#define SOAP_TYPE_mtrep4__RepositoryIntegrity (67)
/* mtrep4:RepositoryIntegrity */
enum mtrep4__RepositoryIntegrity {
	mtrep4__RepositoryIntegrity__Intact = 0,
	mtrep4__RepositoryIntegrity__Corrupted = 1,
	mtrep4__RepositoryIntegrity__Unknown = 2
};
#endif

/* Repository.h:495 */
#ifndef SOAP_TYPE_mtrep4__PackageLevel
#define SOAP_TYPE_mtrep4__PackageLevel (68)
/* mtrep4:PackageLevel */
enum mtrep4__PackageLevel {
	mtrep4__PackageLevel__Essential = 0,
	mtrep4__PackageLevel__Basic = 1,
	mtrep4__PackageLevel__Advanced = 2,
	mtrep4__PackageLevel__Complete = 3
};
#endif

/* Repository.h:506 */
#ifndef SOAP_TYPE_mtrep4__RepositoryStatus
#define SOAP_TYPE_mtrep4__RepositoryStatus (69)
/* mtrep4:RepositoryStatus */
enum mtrep4__RepositoryStatus {
	mtrep4__RepositoryStatus__Online = 0,
	mtrep4__RepositoryStatus__Offline = 1,
	mtrep4__RepositoryStatus__Unknown = 2
};
#endif

/* Repository.h:524 */
#ifndef SOAP_TYPE_mtrep5__RepositoryIntegrity
#define SOAP_TYPE_mtrep5__RepositoryIntegrity (70)
/* mtrep5:RepositoryIntegrity */
enum mtrep5__RepositoryIntegrity {
	mtrep5__RepositoryIntegrity__Intact = 0,
	mtrep5__RepositoryIntegrity__Corrupted = 1,
	mtrep5__RepositoryIntegrity__Unknown = 2
};
#endif

/* Repository.h:534 */
#ifndef SOAP_TYPE_mtrep5__PackageLevel
#define SOAP_TYPE_mtrep5__PackageLevel (71)
/* mtrep5:PackageLevel */
enum mtrep5__PackageLevel {
	mtrep5__PackageLevel__Essential = 0,
	mtrep5__PackageLevel__Basic = 1,
	mtrep5__PackageLevel__Advanced = 2,
	mtrep5__PackageLevel__Complete = 3
};
#endif

/* Repository.h:545 */
#ifndef SOAP_TYPE_mtrep5__RepositoryStatus
#define SOAP_TYPE_mtrep5__RepositoryStatus (72)
/* mtrep5:RepositoryStatus */
enum mtrep5__RepositoryStatus {
	mtrep5__RepositoryStatus__Online = 0,
	mtrep5__RepositoryStatus__Offline = 1,
	mtrep5__RepositoryStatus__Unknown = 2
};
#endif

/* Repository.h:563 */
#ifndef SOAP_TYPE_mtrep6__RepositoryReleaseState
#define SOAP_TYPE_mtrep6__RepositoryReleaseState (73)
/* mtrep6:RepositoryReleaseState */
enum mtrep6__RepositoryReleaseState {
	mtrep6__RepositoryReleaseState__Stable = 0,
	mtrep6__RepositoryReleaseState__Next = 1
};
#endif

/* Repository.h:572 */
#ifndef SOAP_TYPE_mtrep6__RepositoryIntegrity
#define SOAP_TYPE_mtrep6__RepositoryIntegrity (74)
/* mtrep6:RepositoryIntegrity */
enum mtrep6__RepositoryIntegrity {
	mtrep6__RepositoryIntegrity__Intact = 0,
	mtrep6__RepositoryIntegrity__Corrupted = 1,
	mtrep6__RepositoryIntegrity__Unknown = 2
};
#endif

/* Repository.h:582 */
#ifndef SOAP_TYPE_mtrep6__PackageLevel
#define SOAP_TYPE_mtrep6__PackageLevel (75)
/* mtrep6:PackageLevel */
enum mtrep6__PackageLevel {
	mtrep6__PackageLevel__Essential = 0,
	mtrep6__PackageLevel__Basic = 1,
	mtrep6__PackageLevel__Advanced = 2,
	mtrep6__PackageLevel__Complete = 3
};
#endif

/* Repository.h:593 */
#ifndef SOAP_TYPE_mtrep6__RepositoryStatus
#define SOAP_TYPE_mtrep6__RepositoryStatus (76)
/* mtrep6:RepositoryStatus */
enum mtrep6__RepositoryStatus {
	mtrep6__RepositoryStatus__Online = 0,
	mtrep6__RepositoryStatus__Offline = 1,
	mtrep6__RepositoryStatus__Unknown = 2
};
#endif

/* Repository.h:611 */
#ifndef SOAP_TYPE_mtrep7__RepositoryIntegrity
#define SOAP_TYPE_mtrep7__RepositoryIntegrity (77)
/* mtrep7:RepositoryIntegrity */
enum mtrep7__RepositoryIntegrity {
	mtrep7__RepositoryIntegrity__Intact = 0,
	mtrep7__RepositoryIntegrity__Corrupted = 1,
	mtrep7__RepositoryIntegrity__Unknown = 2
};
#endif

/* Repository.h:621 */
#ifndef SOAP_TYPE_mtrep7__PackageLevel
#define SOAP_TYPE_mtrep7__PackageLevel (78)
/* mtrep7:PackageLevel */
enum mtrep7__PackageLevel {
	mtrep7__PackageLevel__Essential = 0,
	mtrep7__PackageLevel__Basic = 1,
	mtrep7__PackageLevel__Advanced = 2,
	mtrep7__PackageLevel__Complete = 3
};
#endif

/* Repository.h:632 */
#ifndef SOAP_TYPE_mtrep7__RepositoryStatus
#define SOAP_TYPE_mtrep7__RepositoryStatus (79)
/* mtrep7:RepositoryStatus */
enum mtrep7__RepositoryStatus {
	mtrep7__RepositoryStatus__Online = 0,
	mtrep7__RepositoryStatus__Offline = 1,
	mtrep7__RepositoryStatus__Unknown = 2
};
#endif

/* Repository.h:642 */
#ifndef SOAP_TYPE_mtrep7__RepositoryReleaseState
#define SOAP_TYPE_mtrep7__RepositoryReleaseState (80)
/* mtrep7:RepositoryReleaseState */
enum mtrep7__RepositoryReleaseState {
	mtrep7__RepositoryReleaseState__Stable = 0,
	mtrep7__RepositoryReleaseState__Next = 1
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class mtrep__RepositoryInfo;	/* Repository.h:190 */
class mtrep__ArrayOfRepositoryInfo;	/* Repository.h:193 */
class _mtrep__TryGetRepositoryInfo;	/* Repository.h:196 */
class _mtrep__TryGetRepositoryInfoResponse;	/* Repository.h:199 */
class _mtrep__PickRepository;	/* Repository.h:202 */
class _mtrep__PickRepositoryResponse;	/* Repository.h:205 */
class _mtrep__GetAllRepositories;	/* Repository.h:208 */
class _mtrep__GetAllRepositoriesResponse;	/* Repository.h:211 */
class _mtrep__GetRepositories;	/* Repository.h:214 */
class _mtrep__GetRepositoriesResponse;	/* Repository.h:217 */
class _mtrep2__GetListCreationTime;	/* Repository.h:220 */
class _mtrep2__GetListCreationTimeResponse;	/* Repository.h:223 */
class mtrep3__ClientInfo;	/* Repository.h:226 */
class mtrep3__ArrayOfRepositoryInfo;	/* Repository.h:229 */
class mtrep3__RepositoryInfo;	/* Repository.h:232 */
class _mtrep3__GetRepositories2;	/* Repository.h:235 */
class _mtrep3__GetRepositories2Response;	/* Repository.h:238 */
class _mtrep3__PickRepository2;	/* Repository.h:241 */
class _mtrep3__PickRepository2Response;	/* Repository.h:244 */
class _mtrep3__TryGetRepositoryInfo2;	/* Repository.h:247 */
class _mtrep3__TryGetRepositoryInfo2Response;	/* Repository.h:250 */
class mtrep4__ClientInfo;	/* Repository.h:253 */
class mtrep4__RepositoryInfo;	/* Repository.h:256 */
class _mtrep4__VerifyRepository;	/* Repository.h:259 */
class _mtrep4__VerifyRepositoryResponse;	/* Repository.h:262 */
class mtrep5__ClientInfo;	/* Repository.h:265 */
class mtrep5__ArrayOfRepositoryInfo2;	/* Repository.h:268 */
class mtrep5__RepositoryInfo;	/* Repository.h:274 */
class _mtrep5__GetRepositories3;	/* Repository.h:277 */
class _mtrep5__GetRepositories3Response;	/* Repository.h:280 */
class _mtrep5__PickRepository3;	/* Repository.h:283 */
class _mtrep5__PickRepository3Response;	/* Repository.h:286 */
class mtrep6__ClientInfo;	/* Repository.h:289 */
class mtrep6__ArrayOfRepositoryInfo3;	/* Repository.h:292 */
class mtrep6__RepositoryInfo;	/* Repository.h:301 */
class _mtrep6__GetRepositories4;	/* Repository.h:304 */
class _mtrep6__GetRepositories4Response;	/* Repository.h:307 */
class _mtrep6__PickRepository4;	/* Repository.h:310 */
class _mtrep6__PickRepository4Response;	/* Repository.h:313 */
class mtrep7__ClientInfo;	/* Repository.h:316 */
class mtrep7__RepositoryInfo;	/* Repository.h:325 */
class _mtrep7__VerifyRepository2;	/* Repository.h:328 */
class _mtrep7__VerifyRepository2Response;	/* Repository.h:331 */
class _mtrep7__TryGetRepositoryInfo3;	/* Repository.h:334 */
class _mtrep7__TryGetRepositoryInfo3Response;	/* Repository.h:337 */
class mtrep5__RepositoryInfo2;	/* Repository.h:271 */
class mtrep6__RepositoryInfo2;	/* Repository.h:298 */
class mtrep7__RepositoryInfo2;	/* Repository.h:322 */
class mtrep6__RepositoryInfo3;	/* Repository.h:295 */
class mtrep7__RepositoryInfo3;	/* Repository.h:319 */
struct __mtrep7__TryGetRepositoryInfo;	/* Repository.h:2334 */
struct __mtrep7__PickRepository;	/* Repository.h:2401 */
struct __mtrep7__GetAllRepositories;	/* Repository.h:2468 */
struct __mtrep7__GetRepositories;	/* Repository.h:2535 */
struct __mtrep7__GetListCreationTime;	/* Repository.h:2602 */
struct __mtrep7__GetRepositories2;	/* Repository.h:2669 */
struct __mtrep7__PickRepository2;	/* Repository.h:2736 */
struct __mtrep7__TryGetRepositoryInfo2;	/* Repository.h:2803 */
struct __mtrep7__VerifyRepository;	/* Repository.h:2870 */
struct __mtrep7__GetRepositories3;	/* Repository.h:2937 */
struct __mtrep7__PickRepository3;	/* Repository.h:3004 */
struct __mtrep7__GetRepositories4;	/* Repository.h:3071 */
struct __mtrep7__PickRepository4;	/* Repository.h:3138 */
struct __mtrep7__VerifyRepository2;	/* Repository.h:3205 */
struct __mtrep7__TryGetRepositoryInfo3;	/* Repository.h:3272 */
struct __mtrep7__TryGetRepositoryInfo_;	/* Repository.h:3339 */
struct __mtrep7__PickRepository_;	/* Repository.h:3406 */
struct __mtrep7__GetAllRepositories_;	/* Repository.h:3473 */
struct __mtrep7__GetRepositories_;	/* Repository.h:3540 */
struct __mtrep7__GetListCreationTime_;	/* Repository.h:3607 */
struct __mtrep7__GetRepositories2_;	/* Repository.h:3674 */
struct __mtrep7__PickRepository2_;	/* Repository.h:3741 */
struct __mtrep7__TryGetRepositoryInfo2_;	/* Repository.h:3808 */
struct __mtrep7__VerifyRepository_;	/* Repository.h:3875 */
struct __mtrep7__GetRepositories3_;	/* Repository.h:3942 */
struct __mtrep7__PickRepository3_;	/* Repository.h:4009 */
struct __mtrep7__GetRepositories4_;	/* Repository.h:4076 */
struct __mtrep7__PickRepository4_;	/* Repository.h:4143 */
struct __mtrep7__VerifyRepository2_;	/* Repository.h:4210 */
struct __mtrep7__TryGetRepositoryInfo3_;	/* Repository.h:4277 */

/* Repository.h:190 */
#ifndef SOAP_TYPE_mtrep__RepositoryInfo
#define SOAP_TYPE_mtrep__RepositoryInfo (11)
/* complex XSD type 'mtrep:RepositoryInfo': */
class SOAP_CMAC mtrep__RepositoryInfo {
      public:
        /// Optional element 'mtrep:Country' of XSD type 'xsd:string'
        std::string *Country;
        /// Required element 'mtrep:Date' of XSD type 'xsd:int'
        int Date;
        /// Required element 'mtrep:Delay' of XSD type 'xsd:int'
        int Delay;
        /// Optional element 'mtrep:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Required element 'mtrep:Integrity' of XSD type 'mtrep:RepositoryIntegrity'
        enum mtrep__RepositoryIntegrity Integrity;
        /// Required element 'mtrep:Level' of XSD type 'mtrep:PackageLevel'
        enum mtrep__PackageLevel Level;
        /// Required element 'mtrep:Status' of XSD type 'mtrep:RepositoryStatus'
        enum mtrep__RepositoryStatus Status;
        /// Optional element 'mtrep:Url' of XSD type 'xsd:string'
        std::string *Url;
        /// Required element 'mtrep:Version' of XSD type 'xsd:int'
        int Version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep__RepositoryInfo
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep__RepositoryInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep__RepositoryInfo, default initialized and not managed by a soap context
        virtual mtrep__RepositoryInfo *soap_alloc(void) const { return SOAP_NEW(mtrep__RepositoryInfo); }
      public:
        /// Constructor with initializations
        mtrep__RepositoryInfo()
        {
          Country = (std::string *)0;
          Date = (int)0;
          Delay = (int)0;
          Description = (std::string *)0;
          Integrity = (enum mtrep__RepositoryIntegrity)0;
          Level = (enum mtrep__PackageLevel)0;
          Status = (enum mtrep__RepositoryStatus)0;
          Url = (std::string *)0;
          Version = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~mtrep__RepositoryInfo() { }
        /// Friend allocator used by soap_new_mtrep__RepositoryInfo(struct soap*, int)
        friend SOAP_FMAC1 mtrep__RepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep__RepositoryInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:193 */
#ifndef SOAP_TYPE_mtrep__ArrayOfRepositoryInfo
#define SOAP_TYPE_mtrep__ArrayOfRepositoryInfo (12)
/* complex XSD type 'mtrep:ArrayOfRepositoryInfo': */
class SOAP_CMAC mtrep__ArrayOfRepositoryInfo {
      public:
        /// Optional element 'mtrep:RepositoryInfo' of XSD type 'mtrep:RepositoryInfo'
        std::vector<mtrep__RepositoryInfo *> RepositoryInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep__ArrayOfRepositoryInfo
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep__ArrayOfRepositoryInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep__ArrayOfRepositoryInfo, default initialized and not managed by a soap context
        virtual mtrep__ArrayOfRepositoryInfo *soap_alloc(void) const { return SOAP_NEW(mtrep__ArrayOfRepositoryInfo); }
      public:
        /// Constructor with initializations
        mtrep__ArrayOfRepositoryInfo()
        {
          soap = (struct soap *)0;
        }
        virtual ~mtrep__ArrayOfRepositoryInfo() { }
        /// Friend allocator used by soap_new_mtrep__ArrayOfRepositoryInfo(struct soap*, int)
        friend SOAP_FMAC1 mtrep__ArrayOfRepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep__ArrayOfRepositoryInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:196 */
#ifndef SOAP_TYPE__mtrep__TryGetRepositoryInfo
#define SOAP_TYPE__mtrep__TryGetRepositoryInfo (13)
/* complex XSD type 'mtrep:TryGetRepositoryInfo': */
class SOAP_CMAC _mtrep__TryGetRepositoryInfo {
      public:
        /// Optional element 'mtrep:url' of XSD type 'xsd:string'
        std::string *url;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep__TryGetRepositoryInfo
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep__TryGetRepositoryInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep__TryGetRepositoryInfo, default initialized and not managed by a soap context
        virtual _mtrep__TryGetRepositoryInfo *soap_alloc(void) const { return SOAP_NEW(_mtrep__TryGetRepositoryInfo); }
      public:
        /// Constructor with initializations
        _mtrep__TryGetRepositoryInfo()
        {
          url = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep__TryGetRepositoryInfo() { }
        /// Friend allocator used by soap_new__mtrep__TryGetRepositoryInfo(struct soap*, int)
        friend SOAP_FMAC1 _mtrep__TryGetRepositoryInfo * SOAP_FMAC2 repository_instantiate__mtrep__TryGetRepositoryInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:199 */
#ifndef SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse
#define SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse (14)
/* complex XSD type 'mtrep:TryGetRepositoryInfoResponse': */
class SOAP_CMAC _mtrep__TryGetRepositoryInfoResponse {
      public:
        /// Required element 'mtrep:TryGetRepositoryInfoResult' of XSD type 'xsd:boolean'
        bool TryGetRepositoryInfoResult;
        /// Optional element 'mtrep:repositoryInfo' of XSD type 'mtrep:RepositoryInfo'
        mtrep__RepositoryInfo *repositoryInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep__TryGetRepositoryInfoResponse, default initialized and not managed by a soap context
        virtual _mtrep__TryGetRepositoryInfoResponse *soap_alloc(void) const { return SOAP_NEW(_mtrep__TryGetRepositoryInfoResponse); }
      public:
        /// Constructor with initializations
        _mtrep__TryGetRepositoryInfoResponse()
        {
          TryGetRepositoryInfoResult = (bool)0;
          repositoryInfo = (mtrep__RepositoryInfo *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep__TryGetRepositoryInfoResponse() { }
        /// Friend allocator used by soap_new__mtrep__TryGetRepositoryInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 _mtrep__TryGetRepositoryInfoResponse * SOAP_FMAC2 repository_instantiate__mtrep__TryGetRepositoryInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:202 */
#ifndef SOAP_TYPE__mtrep__PickRepository
#define SOAP_TYPE__mtrep__PickRepository (15)
/* complex XSD type 'mtrep:PickRepository': */
class SOAP_CMAC _mtrep__PickRepository {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep__PickRepository
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep__PickRepository; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep__PickRepository, default initialized and not managed by a soap context
        virtual _mtrep__PickRepository *soap_alloc(void) const { return SOAP_NEW(_mtrep__PickRepository); }
      public:
        /// Constructor with initializations
        _mtrep__PickRepository()
        {
          soap = (struct soap *)0;
        }
        virtual ~_mtrep__PickRepository() { }
        /// Friend allocator used by soap_new__mtrep__PickRepository(struct soap*, int)
        friend SOAP_FMAC1 _mtrep__PickRepository * SOAP_FMAC2 repository_instantiate__mtrep__PickRepository(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:205 */
#ifndef SOAP_TYPE__mtrep__PickRepositoryResponse
#define SOAP_TYPE__mtrep__PickRepositoryResponse (16)
/* complex XSD type 'mtrep:PickRepositoryResponse': */
class SOAP_CMAC _mtrep__PickRepositoryResponse {
      public:
        /// Optional element 'mtrep:PickRepositoryResult' of XSD type 'mtrep:RepositoryInfo'
        mtrep__RepositoryInfo *PickRepositoryResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep__PickRepositoryResponse
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep__PickRepositoryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep__PickRepositoryResponse, default initialized and not managed by a soap context
        virtual _mtrep__PickRepositoryResponse *soap_alloc(void) const { return SOAP_NEW(_mtrep__PickRepositoryResponse); }
      public:
        /// Constructor with initializations
        _mtrep__PickRepositoryResponse()
        {
          PickRepositoryResult = (mtrep__RepositoryInfo *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep__PickRepositoryResponse() { }
        /// Friend allocator used by soap_new__mtrep__PickRepositoryResponse(struct soap*, int)
        friend SOAP_FMAC1 _mtrep__PickRepositoryResponse * SOAP_FMAC2 repository_instantiate__mtrep__PickRepositoryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:208 */
#ifndef SOAP_TYPE__mtrep__GetAllRepositories
#define SOAP_TYPE__mtrep__GetAllRepositories (17)
/* complex XSD type 'mtrep:GetAllRepositories': */
class SOAP_CMAC _mtrep__GetAllRepositories {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep__GetAllRepositories
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep__GetAllRepositories; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep__GetAllRepositories, default initialized and not managed by a soap context
        virtual _mtrep__GetAllRepositories *soap_alloc(void) const { return SOAP_NEW(_mtrep__GetAllRepositories); }
      public:
        /// Constructor with initializations
        _mtrep__GetAllRepositories()
        {
          soap = (struct soap *)0;
        }
        virtual ~_mtrep__GetAllRepositories() { }
        /// Friend allocator used by soap_new__mtrep__GetAllRepositories(struct soap*, int)
        friend SOAP_FMAC1 _mtrep__GetAllRepositories * SOAP_FMAC2 repository_instantiate__mtrep__GetAllRepositories(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:211 */
#ifndef SOAP_TYPE__mtrep__GetAllRepositoriesResponse
#define SOAP_TYPE__mtrep__GetAllRepositoriesResponse (18)
/* complex XSD type 'mtrep:GetAllRepositoriesResponse': */
class SOAP_CMAC _mtrep__GetAllRepositoriesResponse {
      public:
        /// Optional element 'mtrep:GetAllRepositoriesResult' of XSD type 'mtrep:ArrayOfRepositoryInfo'
        mtrep__ArrayOfRepositoryInfo *GetAllRepositoriesResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep__GetAllRepositoriesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep__GetAllRepositoriesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep__GetAllRepositoriesResponse, default initialized and not managed by a soap context
        virtual _mtrep__GetAllRepositoriesResponse *soap_alloc(void) const { return SOAP_NEW(_mtrep__GetAllRepositoriesResponse); }
      public:
        /// Constructor with initializations
        _mtrep__GetAllRepositoriesResponse()
        {
          GetAllRepositoriesResult = (mtrep__ArrayOfRepositoryInfo *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep__GetAllRepositoriesResponse() { }
        /// Friend allocator used by soap_new__mtrep__GetAllRepositoriesResponse(struct soap*, int)
        friend SOAP_FMAC1 _mtrep__GetAllRepositoriesResponse * SOAP_FMAC2 repository_instantiate__mtrep__GetAllRepositoriesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:214 */
#ifndef SOAP_TYPE__mtrep__GetRepositories
#define SOAP_TYPE__mtrep__GetRepositories (19)
/* complex XSD type 'mtrep:GetRepositories': */
class SOAP_CMAC _mtrep__GetRepositories {
      public:
        /// Required element 'mtrep:onlyOnline' of XSD type 'xsd:boolean'
        bool onlyOnline;
        /// Required element 'mtrep:noCorrupted' of XSD type 'xsd:boolean'
        bool noCorrupted;
        /// Required element 'mtrep:maxDelay' of XSD type 'xsd:int'
        int maxDelay;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep__GetRepositories
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep__GetRepositories; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep__GetRepositories, default initialized and not managed by a soap context
        virtual _mtrep__GetRepositories *soap_alloc(void) const { return SOAP_NEW(_mtrep__GetRepositories); }
      public:
        /// Constructor with initializations
        _mtrep__GetRepositories()
        {
          onlyOnline = (bool)0;
          noCorrupted = (bool)0;
          maxDelay = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep__GetRepositories() { }
        /// Friend allocator used by soap_new__mtrep__GetRepositories(struct soap*, int)
        friend SOAP_FMAC1 _mtrep__GetRepositories * SOAP_FMAC2 repository_instantiate__mtrep__GetRepositories(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:217 */
#ifndef SOAP_TYPE__mtrep__GetRepositoriesResponse
#define SOAP_TYPE__mtrep__GetRepositoriesResponse (20)
/* complex XSD type 'mtrep:GetRepositoriesResponse': */
class SOAP_CMAC _mtrep__GetRepositoriesResponse {
      public:
        /// Optional element 'mtrep:GetRepositoriesResult' of XSD type 'mtrep:ArrayOfRepositoryInfo'
        mtrep__ArrayOfRepositoryInfo *GetRepositoriesResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep__GetRepositoriesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep__GetRepositoriesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep__GetRepositoriesResponse, default initialized and not managed by a soap context
        virtual _mtrep__GetRepositoriesResponse *soap_alloc(void) const { return SOAP_NEW(_mtrep__GetRepositoriesResponse); }
      public:
        /// Constructor with initializations
        _mtrep__GetRepositoriesResponse()
        {
          GetRepositoriesResult = (mtrep__ArrayOfRepositoryInfo *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep__GetRepositoriesResponse() { }
        /// Friend allocator used by soap_new__mtrep__GetRepositoriesResponse(struct soap*, int)
        friend SOAP_FMAC1 _mtrep__GetRepositoriesResponse * SOAP_FMAC2 repository_instantiate__mtrep__GetRepositoriesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:220 */
#ifndef SOAP_TYPE__mtrep2__GetListCreationTime
#define SOAP_TYPE__mtrep2__GetListCreationTime (21)
/* complex XSD type 'mtrep2:GetListCreationTime': */
class SOAP_CMAC _mtrep2__GetListCreationTime {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep2__GetListCreationTime
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep2__GetListCreationTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep2__GetListCreationTime, default initialized and not managed by a soap context
        virtual _mtrep2__GetListCreationTime *soap_alloc(void) const { return SOAP_NEW(_mtrep2__GetListCreationTime); }
      public:
        /// Constructor with initializations
        _mtrep2__GetListCreationTime()
        {
          soap = (struct soap *)0;
        }
        virtual ~_mtrep2__GetListCreationTime() { }
        /// Friend allocator used by soap_new__mtrep2__GetListCreationTime(struct soap*, int)
        friend SOAP_FMAC1 _mtrep2__GetListCreationTime * SOAP_FMAC2 repository_instantiate__mtrep2__GetListCreationTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:223 */
#ifndef SOAP_TYPE__mtrep2__GetListCreationTimeResponse
#define SOAP_TYPE__mtrep2__GetListCreationTimeResponse (22)
/* complex XSD type 'mtrep2:GetListCreationTimeResponse': */
class SOAP_CMAC _mtrep2__GetListCreationTimeResponse {
      public:
        /// Required element 'mtrep2:GetListCreationTimeResult' of XSD type 'xsd:int'
        int GetListCreationTimeResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep2__GetListCreationTimeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep2__GetListCreationTimeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep2__GetListCreationTimeResponse, default initialized and not managed by a soap context
        virtual _mtrep2__GetListCreationTimeResponse *soap_alloc(void) const { return SOAP_NEW(_mtrep2__GetListCreationTimeResponse); }
      public:
        /// Constructor with initializations
        _mtrep2__GetListCreationTimeResponse()
        {
          GetListCreationTimeResult = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep2__GetListCreationTimeResponse() { }
        /// Friend allocator used by soap_new__mtrep2__GetListCreationTimeResponse(struct soap*, int)
        friend SOAP_FMAC1 _mtrep2__GetListCreationTimeResponse * SOAP_FMAC2 repository_instantiate__mtrep2__GetListCreationTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:226 */
#ifndef SOAP_TYPE_mtrep3__ClientInfo
#define SOAP_TYPE_mtrep3__ClientInfo (23)
/* complex XSD type 'mtrep3:ClientInfo': */
class SOAP_CMAC mtrep3__ClientInfo {
      public:
        /// Optional element 'mtrep3:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Optional element 'mtrep3:Version' of XSD type 'xsd:string'
        std::string *Version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep3__ClientInfo
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep3__ClientInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep3__ClientInfo, default initialized and not managed by a soap context
        virtual mtrep3__ClientInfo *soap_alloc(void) const { return SOAP_NEW(mtrep3__ClientInfo); }
      public:
        /// Constructor with initializations
        mtrep3__ClientInfo()
        {
          Name = (std::string *)0;
          Version = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~mtrep3__ClientInfo() { }
        /// Friend allocator used by soap_new_mtrep3__ClientInfo(struct soap*, int)
        friend SOAP_FMAC1 mtrep3__ClientInfo * SOAP_FMAC2 repository_instantiate_mtrep3__ClientInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:229 */
#ifndef SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo
#define SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo (24)
/* complex XSD type 'mtrep3:ArrayOfRepositoryInfo': */
class SOAP_CMAC mtrep3__ArrayOfRepositoryInfo {
      public:
        /// Optional element 'mtrep3:RepositoryInfo' of XSD type 'mtrep3:RepositoryInfo'
        std::vector<mtrep3__RepositoryInfo *> RepositoryInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep3__ArrayOfRepositoryInfo, default initialized and not managed by a soap context
        virtual mtrep3__ArrayOfRepositoryInfo *soap_alloc(void) const { return SOAP_NEW(mtrep3__ArrayOfRepositoryInfo); }
      public:
        /// Constructor with initializations
        mtrep3__ArrayOfRepositoryInfo()
        {
          soap = (struct soap *)0;
        }
        virtual ~mtrep3__ArrayOfRepositoryInfo() { }
        /// Friend allocator used by soap_new_mtrep3__ArrayOfRepositoryInfo(struct soap*, int)
        friend SOAP_FMAC1 mtrep3__ArrayOfRepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep3__ArrayOfRepositoryInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:232 */
#ifndef SOAP_TYPE_mtrep3__RepositoryInfo
#define SOAP_TYPE_mtrep3__RepositoryInfo (25)
/* complex XSD type 'mtrep3:RepositoryInfo': */
class SOAP_CMAC mtrep3__RepositoryInfo {
      public:
        /// Optional element 'mtrep3:Country' of XSD type 'xsd:string'
        std::string *Country;
        /// Required element 'mtrep3:Date' of XSD type 'xsd:int'
        int Date;
        /// Required element 'mtrep3:Delay' of XSD type 'xsd:int'
        int Delay;
        /// Optional element 'mtrep3:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Required element 'mtrep3:Integrity' of XSD type 'mtrep3:RepositoryIntegrity'
        enum mtrep3__RepositoryIntegrity Integrity;
        /// Required element 'mtrep3:Level' of XSD type 'mtrep3:PackageLevel'
        enum mtrep3__PackageLevel Level;
        /// Required element 'mtrep3:Status' of XSD type 'mtrep3:RepositoryStatus'
        enum mtrep3__RepositoryStatus Status;
        /// Optional element 'mtrep3:Url' of XSD type 'xsd:string'
        std::string *Url;
        /// Required element 'mtrep3:Version' of XSD type 'xsd:int'
        int Version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep3__RepositoryInfo
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep3__RepositoryInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep3__RepositoryInfo, default initialized and not managed by a soap context
        virtual mtrep3__RepositoryInfo *soap_alloc(void) const { return SOAP_NEW(mtrep3__RepositoryInfo); }
      public:
        /// Constructor with initializations
        mtrep3__RepositoryInfo()
        {
          Country = (std::string *)0;
          Date = (int)0;
          Delay = (int)0;
          Description = (std::string *)0;
          Integrity = (enum mtrep3__RepositoryIntegrity)0;
          Level = (enum mtrep3__PackageLevel)0;
          Status = (enum mtrep3__RepositoryStatus)0;
          Url = (std::string *)0;
          Version = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~mtrep3__RepositoryInfo() { }
        /// Friend allocator used by soap_new_mtrep3__RepositoryInfo(struct soap*, int)
        friend SOAP_FMAC1 mtrep3__RepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep3__RepositoryInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:235 */
#ifndef SOAP_TYPE__mtrep3__GetRepositories2
#define SOAP_TYPE__mtrep3__GetRepositories2 (26)
/* complex XSD type 'mtrep3:GetRepositories2': */
class SOAP_CMAC _mtrep3__GetRepositories2 {
      public:
        /// Optional element 'mtrep3:clientInfo' of XSD type 'mtrep3:ClientInfo'
        mtrep3__ClientInfo *clientInfo;
        /// Required element 'mtrep3:onlyOnline' of XSD type 'xsd:boolean'
        bool onlyOnline;
        /// Required element 'mtrep3:noCorrupted' of XSD type 'xsd:boolean'
        bool noCorrupted;
        /// Required element 'mtrep3:maxDelay' of XSD type 'xsd:int'
        int maxDelay;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep3__GetRepositories2
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep3__GetRepositories2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep3__GetRepositories2, default initialized and not managed by a soap context
        virtual _mtrep3__GetRepositories2 *soap_alloc(void) const { return SOAP_NEW(_mtrep3__GetRepositories2); }
      public:
        /// Constructor with initializations
        _mtrep3__GetRepositories2()
        {
          clientInfo = (mtrep3__ClientInfo *)0;
          onlyOnline = (bool)0;
          noCorrupted = (bool)0;
          maxDelay = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep3__GetRepositories2() { }
        /// Friend allocator used by soap_new__mtrep3__GetRepositories2(struct soap*, int)
        friend SOAP_FMAC1 _mtrep3__GetRepositories2 * SOAP_FMAC2 repository_instantiate__mtrep3__GetRepositories2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:238 */
#ifndef SOAP_TYPE__mtrep3__GetRepositories2Response
#define SOAP_TYPE__mtrep3__GetRepositories2Response (27)
/* complex XSD type 'mtrep3:GetRepositories2Response': */
class SOAP_CMAC _mtrep3__GetRepositories2Response {
      public:
        /// Optional element 'mtrep3:GetRepositories2Result' of XSD type 'mtrep3:ArrayOfRepositoryInfo'
        mtrep3__ArrayOfRepositoryInfo *GetRepositories2Result;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep3__GetRepositories2Response
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep3__GetRepositories2Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep3__GetRepositories2Response, default initialized and not managed by a soap context
        virtual _mtrep3__GetRepositories2Response *soap_alloc(void) const { return SOAP_NEW(_mtrep3__GetRepositories2Response); }
      public:
        /// Constructor with initializations
        _mtrep3__GetRepositories2Response()
        {
          GetRepositories2Result = (mtrep3__ArrayOfRepositoryInfo *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep3__GetRepositories2Response() { }
        /// Friend allocator used by soap_new__mtrep3__GetRepositories2Response(struct soap*, int)
        friend SOAP_FMAC1 _mtrep3__GetRepositories2Response * SOAP_FMAC2 repository_instantiate__mtrep3__GetRepositories2Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:241 */
#ifndef SOAP_TYPE__mtrep3__PickRepository2
#define SOAP_TYPE__mtrep3__PickRepository2 (28)
/* complex XSD type 'mtrep3:PickRepository2': */
class SOAP_CMAC _mtrep3__PickRepository2 {
      public:
        /// Optional element 'mtrep3:clientInfo' of XSD type 'mtrep3:ClientInfo'
        mtrep3__ClientInfo *clientInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep3__PickRepository2
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep3__PickRepository2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep3__PickRepository2, default initialized and not managed by a soap context
        virtual _mtrep3__PickRepository2 *soap_alloc(void) const { return SOAP_NEW(_mtrep3__PickRepository2); }
      public:
        /// Constructor with initializations
        _mtrep3__PickRepository2()
        {
          clientInfo = (mtrep3__ClientInfo *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep3__PickRepository2() { }
        /// Friend allocator used by soap_new__mtrep3__PickRepository2(struct soap*, int)
        friend SOAP_FMAC1 _mtrep3__PickRepository2 * SOAP_FMAC2 repository_instantiate__mtrep3__PickRepository2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:244 */
#ifndef SOAP_TYPE__mtrep3__PickRepository2Response
#define SOAP_TYPE__mtrep3__PickRepository2Response (29)
/* complex XSD type 'mtrep3:PickRepository2Response': */
class SOAP_CMAC _mtrep3__PickRepository2Response {
      public:
        /// Optional element 'mtrep3:PickRepository2Result' of XSD type 'mtrep3:RepositoryInfo'
        mtrep3__RepositoryInfo *PickRepository2Result;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep3__PickRepository2Response
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep3__PickRepository2Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep3__PickRepository2Response, default initialized and not managed by a soap context
        virtual _mtrep3__PickRepository2Response *soap_alloc(void) const { return SOAP_NEW(_mtrep3__PickRepository2Response); }
      public:
        /// Constructor with initializations
        _mtrep3__PickRepository2Response()
        {
          PickRepository2Result = (mtrep3__RepositoryInfo *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep3__PickRepository2Response() { }
        /// Friend allocator used by soap_new__mtrep3__PickRepository2Response(struct soap*, int)
        friend SOAP_FMAC1 _mtrep3__PickRepository2Response * SOAP_FMAC2 repository_instantiate__mtrep3__PickRepository2Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:247 */
#ifndef SOAP_TYPE__mtrep3__TryGetRepositoryInfo2
#define SOAP_TYPE__mtrep3__TryGetRepositoryInfo2 (30)
/* complex XSD type 'mtrep3:TryGetRepositoryInfo2': */
class SOAP_CMAC _mtrep3__TryGetRepositoryInfo2 {
      public:
        /// Optional element 'mtrep3:clientInfo' of XSD type 'mtrep3:ClientInfo'
        mtrep3__ClientInfo *clientInfo;
        /// Optional element 'mtrep3:url' of XSD type 'xsd:string'
        std::string *url;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep3__TryGetRepositoryInfo2
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep3__TryGetRepositoryInfo2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep3__TryGetRepositoryInfo2, default initialized and not managed by a soap context
        virtual _mtrep3__TryGetRepositoryInfo2 *soap_alloc(void) const { return SOAP_NEW(_mtrep3__TryGetRepositoryInfo2); }
      public:
        /// Constructor with initializations
        _mtrep3__TryGetRepositoryInfo2()
        {
          clientInfo = (mtrep3__ClientInfo *)0;
          url = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep3__TryGetRepositoryInfo2() { }
        /// Friend allocator used by soap_new__mtrep3__TryGetRepositoryInfo2(struct soap*, int)
        friend SOAP_FMAC1 _mtrep3__TryGetRepositoryInfo2 * SOAP_FMAC2 repository_instantiate__mtrep3__TryGetRepositoryInfo2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:250 */
#ifndef SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response
#define SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response (31)
/* complex XSD type 'mtrep3:TryGetRepositoryInfo2Response': */
class SOAP_CMAC _mtrep3__TryGetRepositoryInfo2Response {
      public:
        /// Required element 'mtrep3:TryGetRepositoryInfo2Result' of XSD type 'xsd:boolean'
        bool TryGetRepositoryInfo2Result;
        /// Optional element 'mtrep3:repositoryInfo' of XSD type 'mtrep3:RepositoryInfo'
        mtrep3__RepositoryInfo *repositoryInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep3__TryGetRepositoryInfo2Response, default initialized and not managed by a soap context
        virtual _mtrep3__TryGetRepositoryInfo2Response *soap_alloc(void) const { return SOAP_NEW(_mtrep3__TryGetRepositoryInfo2Response); }
      public:
        /// Constructor with initializations
        _mtrep3__TryGetRepositoryInfo2Response()
        {
          TryGetRepositoryInfo2Result = (bool)0;
          repositoryInfo = (mtrep3__RepositoryInfo *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep3__TryGetRepositoryInfo2Response() { }
        /// Friend allocator used by soap_new__mtrep3__TryGetRepositoryInfo2Response(struct soap*, int)
        friend SOAP_FMAC1 _mtrep3__TryGetRepositoryInfo2Response * SOAP_FMAC2 repository_instantiate__mtrep3__TryGetRepositoryInfo2Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:253 */
#ifndef SOAP_TYPE_mtrep4__ClientInfo
#define SOAP_TYPE_mtrep4__ClientInfo (32)
/* complex XSD type 'mtrep4:ClientInfo': */
class SOAP_CMAC mtrep4__ClientInfo {
      public:
        /// Optional element 'mtrep4:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Optional element 'mtrep4:Version' of XSD type 'xsd:string'
        std::string *Version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep4__ClientInfo
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep4__ClientInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep4__ClientInfo, default initialized and not managed by a soap context
        virtual mtrep4__ClientInfo *soap_alloc(void) const { return SOAP_NEW(mtrep4__ClientInfo); }
      public:
        /// Constructor with initializations
        mtrep4__ClientInfo()
        {
          Name = (std::string *)0;
          Version = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~mtrep4__ClientInfo() { }
        /// Friend allocator used by soap_new_mtrep4__ClientInfo(struct soap*, int)
        friend SOAP_FMAC1 mtrep4__ClientInfo * SOAP_FMAC2 repository_instantiate_mtrep4__ClientInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:256 */
#ifndef SOAP_TYPE_mtrep4__RepositoryInfo
#define SOAP_TYPE_mtrep4__RepositoryInfo (33)
/* complex XSD type 'mtrep4:RepositoryInfo': */
class SOAP_CMAC mtrep4__RepositoryInfo {
      public:
        /// Optional element 'mtrep4:Country' of XSD type 'xsd:string'
        std::string *Country;
        /// Required element 'mtrep4:Date' of XSD type 'xsd:int'
        int Date;
        /// Required element 'mtrep4:Delay' of XSD type 'xsd:int'
        int Delay;
        /// Optional element 'mtrep4:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Required element 'mtrep4:Integrity' of XSD type 'mtrep4:RepositoryIntegrity'
        enum mtrep4__RepositoryIntegrity Integrity;
        /// Required element 'mtrep4:Level' of XSD type 'mtrep4:PackageLevel'
        enum mtrep4__PackageLevel Level;
        /// Required element 'mtrep4:Status' of XSD type 'mtrep4:RepositoryStatus'
        enum mtrep4__RepositoryStatus Status;
        /// Optional element 'mtrep4:Url' of XSD type 'xsd:string'
        std::string *Url;
        /// Required element 'mtrep4:Version' of XSD type 'xsd:int'
        int Version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep4__RepositoryInfo
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep4__RepositoryInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep4__RepositoryInfo, default initialized and not managed by a soap context
        virtual mtrep4__RepositoryInfo *soap_alloc(void) const { return SOAP_NEW(mtrep4__RepositoryInfo); }
      public:
        /// Constructor with initializations
        mtrep4__RepositoryInfo()
        {
          Country = (std::string *)0;
          Date = (int)0;
          Delay = (int)0;
          Description = (std::string *)0;
          Integrity = (enum mtrep4__RepositoryIntegrity)0;
          Level = (enum mtrep4__PackageLevel)0;
          Status = (enum mtrep4__RepositoryStatus)0;
          Url = (std::string *)0;
          Version = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~mtrep4__RepositoryInfo() { }
        /// Friend allocator used by soap_new_mtrep4__RepositoryInfo(struct soap*, int)
        friend SOAP_FMAC1 mtrep4__RepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep4__RepositoryInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:259 */
#ifndef SOAP_TYPE__mtrep4__VerifyRepository
#define SOAP_TYPE__mtrep4__VerifyRepository (34)
/* complex XSD type 'mtrep4:VerifyRepository': */
class SOAP_CMAC _mtrep4__VerifyRepository {
      public:
        /// Optional element 'mtrep4:clientInfo' of XSD type 'mtrep4:ClientInfo'
        mtrep4__ClientInfo *clientInfo;
        /// Optional element 'mtrep4:url' of XSD type 'xsd:string'
        std::string *url;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep4__VerifyRepository
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep4__VerifyRepository; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep4__VerifyRepository, default initialized and not managed by a soap context
        virtual _mtrep4__VerifyRepository *soap_alloc(void) const { return SOAP_NEW(_mtrep4__VerifyRepository); }
      public:
        /// Constructor with initializations
        _mtrep4__VerifyRepository()
        {
          clientInfo = (mtrep4__ClientInfo *)0;
          url = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep4__VerifyRepository() { }
        /// Friend allocator used by soap_new__mtrep4__VerifyRepository(struct soap*, int)
        friend SOAP_FMAC1 _mtrep4__VerifyRepository * SOAP_FMAC2 repository_instantiate__mtrep4__VerifyRepository(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:262 */
#ifndef SOAP_TYPE__mtrep4__VerifyRepositoryResponse
#define SOAP_TYPE__mtrep4__VerifyRepositoryResponse (35)
/* complex XSD type 'mtrep4:VerifyRepositoryResponse': */
class SOAP_CMAC _mtrep4__VerifyRepositoryResponse {
      public:
        /// Required element 'mtrep4:VerifyRepositoryResult' of XSD type 'xsd:boolean'
        bool VerifyRepositoryResult;
        /// Optional element 'mtrep4:repositoryInfo' of XSD type 'mtrep4:RepositoryInfo'
        mtrep4__RepositoryInfo *repositoryInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep4__VerifyRepositoryResponse
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep4__VerifyRepositoryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep4__VerifyRepositoryResponse, default initialized and not managed by a soap context
        virtual _mtrep4__VerifyRepositoryResponse *soap_alloc(void) const { return SOAP_NEW(_mtrep4__VerifyRepositoryResponse); }
      public:
        /// Constructor with initializations
        _mtrep4__VerifyRepositoryResponse()
        {
          VerifyRepositoryResult = (bool)0;
          repositoryInfo = (mtrep4__RepositoryInfo *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep4__VerifyRepositoryResponse() { }
        /// Friend allocator used by soap_new__mtrep4__VerifyRepositoryResponse(struct soap*, int)
        friend SOAP_FMAC1 _mtrep4__VerifyRepositoryResponse * SOAP_FMAC2 repository_instantiate__mtrep4__VerifyRepositoryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:265 */
#ifndef SOAP_TYPE_mtrep5__ClientInfo
#define SOAP_TYPE_mtrep5__ClientInfo (36)
/* complex XSD type 'mtrep5:ClientInfo': */
class SOAP_CMAC mtrep5__ClientInfo {
      public:
        /// Optional element 'mtrep5:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Optional element 'mtrep5:Version' of XSD type 'xsd:string'
        std::string *Version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep5__ClientInfo
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep5__ClientInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep5__ClientInfo, default initialized and not managed by a soap context
        virtual mtrep5__ClientInfo *soap_alloc(void) const { return SOAP_NEW(mtrep5__ClientInfo); }
      public:
        /// Constructor with initializations
        mtrep5__ClientInfo()
        {
          Name = (std::string *)0;
          Version = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~mtrep5__ClientInfo() { }
        /// Friend allocator used by soap_new_mtrep5__ClientInfo(struct soap*, int)
        friend SOAP_FMAC1 mtrep5__ClientInfo * SOAP_FMAC2 repository_instantiate_mtrep5__ClientInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:268 */
#ifndef SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2
#define SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2 (37)
/* complex XSD type 'mtrep5:ArrayOfRepositoryInfo2': */
class SOAP_CMAC mtrep5__ArrayOfRepositoryInfo2 {
      public:
        /// Optional element 'mtrep5:RepositoryInfo2' of XSD type 'mtrep5:RepositoryInfo2'
        std::vector<mtrep5__RepositoryInfo2 *> RepositoryInfo2;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep5__ArrayOfRepositoryInfo2, default initialized and not managed by a soap context
        virtual mtrep5__ArrayOfRepositoryInfo2 *soap_alloc(void) const { return SOAP_NEW(mtrep5__ArrayOfRepositoryInfo2); }
      public:
        /// Constructor with initializations
        mtrep5__ArrayOfRepositoryInfo2()
        {
          soap = (struct soap *)0;
        }
        virtual ~mtrep5__ArrayOfRepositoryInfo2() { }
        /// Friend allocator used by soap_new_mtrep5__ArrayOfRepositoryInfo2(struct soap*, int)
        friend SOAP_FMAC1 mtrep5__ArrayOfRepositoryInfo2 * SOAP_FMAC2 repository_instantiate_mtrep5__ArrayOfRepositoryInfo2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:274 */
#ifndef SOAP_TYPE_mtrep5__RepositoryInfo
#define SOAP_TYPE_mtrep5__RepositoryInfo (39)
/* Type mtrep5__RepositoryInfo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'mtrep5:RepositoryInfo': */
class SOAP_CMAC mtrep5__RepositoryInfo {
      public:
        /// Optional element 'mtrep5:Country' of XSD type 'xsd:string'
        std::string *Country;
        /// Required element 'mtrep5:Date' of XSD type 'xsd:int'
        int Date;
        /// Required element 'mtrep5:Delay' of XSD type 'xsd:int'
        int Delay;
        /// Optional element 'mtrep5:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Required element 'mtrep5:Integrity' of XSD type 'mtrep5:RepositoryIntegrity'
        enum mtrep5__RepositoryIntegrity Integrity;
        /// Required element 'mtrep5:Level' of XSD type 'mtrep5:PackageLevel'
        enum mtrep5__PackageLevel Level;
        /// Required element 'mtrep5:Status' of XSD type 'mtrep5:RepositoryStatus'
        enum mtrep5__RepositoryStatus Status;
        /// Optional element 'mtrep5:Url' of XSD type 'xsd:string'
        std::string *Url;
        /// Required element 'mtrep5:Version' of XSD type 'xsd:int'
        int Version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep5__RepositoryInfo
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep5__RepositoryInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep5__RepositoryInfo, default initialized and not managed by a soap context
        virtual mtrep5__RepositoryInfo *soap_alloc(void) const { return SOAP_NEW(mtrep5__RepositoryInfo); }
      public:
        /// Constructor with initializations
        mtrep5__RepositoryInfo()
        {
          Country = (std::string *)0;
          Date = (int)0;
          Delay = (int)0;
          Description = (std::string *)0;
          Integrity = (enum mtrep5__RepositoryIntegrity)0;
          Level = (enum mtrep5__PackageLevel)0;
          Status = (enum mtrep5__RepositoryStatus)0;
          Url = (std::string *)0;
          Version = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~mtrep5__RepositoryInfo() { }
        /// Friend allocator used by soap_new_mtrep5__RepositoryInfo(struct soap*, int)
        friend SOAP_FMAC1 mtrep5__RepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep5__RepositoryInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:277 */
#ifndef SOAP_TYPE__mtrep5__GetRepositories3
#define SOAP_TYPE__mtrep5__GetRepositories3 (40)
/* complex XSD type 'mtrep5:GetRepositories3': */
class SOAP_CMAC _mtrep5__GetRepositories3 {
      public:
        /// Optional element 'mtrep5:clientInfo' of XSD type 'mtrep5:ClientInfo'
        mtrep5__ClientInfo *clientInfo;
        /// Required element 'mtrep5:onlyOnline' of XSD type 'xsd:boolean'
        bool onlyOnline;
        /// Required element 'mtrep5:noCorrupted' of XSD type 'xsd:boolean'
        bool noCorrupted;
        /// Required element 'mtrep5:httpOnly' of XSD type 'xsd:boolean'
        bool httpOnly;
        /// Required element 'mtrep5:excludeHidden' of XSD type 'xsd:boolean'
        bool excludeHidden;
        /// Required element 'mtrep5:maxDelay' of XSD type 'xsd:int'
        int maxDelay;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep5__GetRepositories3
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep5__GetRepositories3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep5__GetRepositories3, default initialized and not managed by a soap context
        virtual _mtrep5__GetRepositories3 *soap_alloc(void) const { return SOAP_NEW(_mtrep5__GetRepositories3); }
      public:
        /// Constructor with initializations
        _mtrep5__GetRepositories3()
        {
          clientInfo = (mtrep5__ClientInfo *)0;
          onlyOnline = (bool)0;
          noCorrupted = (bool)0;
          httpOnly = (bool)0;
          excludeHidden = (bool)0;
          maxDelay = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep5__GetRepositories3() { }
        /// Friend allocator used by soap_new__mtrep5__GetRepositories3(struct soap*, int)
        friend SOAP_FMAC1 _mtrep5__GetRepositories3 * SOAP_FMAC2 repository_instantiate__mtrep5__GetRepositories3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:280 */
#ifndef SOAP_TYPE__mtrep5__GetRepositories3Response
#define SOAP_TYPE__mtrep5__GetRepositories3Response (41)
/* complex XSD type 'mtrep5:GetRepositories3Response': */
class SOAP_CMAC _mtrep5__GetRepositories3Response {
      public:
        /// Optional element 'mtrep5:GetRepositories3Result' of XSD type 'mtrep5:ArrayOfRepositoryInfo2'
        mtrep5__ArrayOfRepositoryInfo2 *GetRepositories3Result;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep5__GetRepositories3Response
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep5__GetRepositories3Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep5__GetRepositories3Response, default initialized and not managed by a soap context
        virtual _mtrep5__GetRepositories3Response *soap_alloc(void) const { return SOAP_NEW(_mtrep5__GetRepositories3Response); }
      public:
        /// Constructor with initializations
        _mtrep5__GetRepositories3Response()
        {
          GetRepositories3Result = (mtrep5__ArrayOfRepositoryInfo2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep5__GetRepositories3Response() { }
        /// Friend allocator used by soap_new__mtrep5__GetRepositories3Response(struct soap*, int)
        friend SOAP_FMAC1 _mtrep5__GetRepositories3Response * SOAP_FMAC2 repository_instantiate__mtrep5__GetRepositories3Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:283 */
#ifndef SOAP_TYPE__mtrep5__PickRepository3
#define SOAP_TYPE__mtrep5__PickRepository3 (42)
/* complex XSD type 'mtrep5:PickRepository3': */
class SOAP_CMAC _mtrep5__PickRepository3 {
      public:
        /// Optional element 'mtrep5:clientInfo' of XSD type 'mtrep5:ClientInfo'
        mtrep5__ClientInfo *clientInfo;
        /// Required element 'mtrep5:favorHttp' of XSD type 'xsd:boolean'
        bool favorHttp;
        /// Required element 'mtrep5:nearest' of XSD type 'xsd:boolean'
        bool nearest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep5__PickRepository3
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep5__PickRepository3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep5__PickRepository3, default initialized and not managed by a soap context
        virtual _mtrep5__PickRepository3 *soap_alloc(void) const { return SOAP_NEW(_mtrep5__PickRepository3); }
      public:
        /// Constructor with initializations
        _mtrep5__PickRepository3()
        {
          clientInfo = (mtrep5__ClientInfo *)0;
          favorHttp = (bool)0;
          nearest = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep5__PickRepository3() { }
        /// Friend allocator used by soap_new__mtrep5__PickRepository3(struct soap*, int)
        friend SOAP_FMAC1 _mtrep5__PickRepository3 * SOAP_FMAC2 repository_instantiate__mtrep5__PickRepository3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:286 */
#ifndef SOAP_TYPE__mtrep5__PickRepository3Response
#define SOAP_TYPE__mtrep5__PickRepository3Response (43)
/* complex XSD type 'mtrep5:PickRepository3Response': */
class SOAP_CMAC _mtrep5__PickRepository3Response {
      public:
        /// Optional element 'mtrep5:PickRepository3Result' of XSD type 'mtrep5:RepositoryInfo2'
        mtrep5__RepositoryInfo2 *PickRepository3Result;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep5__PickRepository3Response
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep5__PickRepository3Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep5__PickRepository3Response, default initialized and not managed by a soap context
        virtual _mtrep5__PickRepository3Response *soap_alloc(void) const { return SOAP_NEW(_mtrep5__PickRepository3Response); }
      public:
        /// Constructor with initializations
        _mtrep5__PickRepository3Response()
        {
          PickRepository3Result = (mtrep5__RepositoryInfo2 *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep5__PickRepository3Response() { }
        /// Friend allocator used by soap_new__mtrep5__PickRepository3Response(struct soap*, int)
        friend SOAP_FMAC1 _mtrep5__PickRepository3Response * SOAP_FMAC2 repository_instantiate__mtrep5__PickRepository3Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:289 */
#ifndef SOAP_TYPE_mtrep6__ClientInfo
#define SOAP_TYPE_mtrep6__ClientInfo (44)
/* complex XSD type 'mtrep6:ClientInfo': */
class SOAP_CMAC mtrep6__ClientInfo {
      public:
        /// Optional element 'mtrep6:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Optional element 'mtrep6:Version' of XSD type 'xsd:string'
        std::string *Version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep6__ClientInfo
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep6__ClientInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep6__ClientInfo, default initialized and not managed by a soap context
        virtual mtrep6__ClientInfo *soap_alloc(void) const { return SOAP_NEW(mtrep6__ClientInfo); }
      public:
        /// Constructor with initializations
        mtrep6__ClientInfo()
        {
          Name = (std::string *)0;
          Version = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~mtrep6__ClientInfo() { }
        /// Friend allocator used by soap_new_mtrep6__ClientInfo(struct soap*, int)
        friend SOAP_FMAC1 mtrep6__ClientInfo * SOAP_FMAC2 repository_instantiate_mtrep6__ClientInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:292 */
#ifndef SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3
#define SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3 (45)
/* complex XSD type 'mtrep6:ArrayOfRepositoryInfo3': */
class SOAP_CMAC mtrep6__ArrayOfRepositoryInfo3 {
      public:
        /// Optional element 'mtrep6:RepositoryInfo3' of XSD type 'mtrep6:RepositoryInfo3'
        std::vector<mtrep6__RepositoryInfo3 *> RepositoryInfo3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep6__ArrayOfRepositoryInfo3, default initialized and not managed by a soap context
        virtual mtrep6__ArrayOfRepositoryInfo3 *soap_alloc(void) const { return SOAP_NEW(mtrep6__ArrayOfRepositoryInfo3); }
      public:
        /// Constructor with initializations
        mtrep6__ArrayOfRepositoryInfo3()
        {
          soap = (struct soap *)0;
        }
        virtual ~mtrep6__ArrayOfRepositoryInfo3() { }
        /// Friend allocator used by soap_new_mtrep6__ArrayOfRepositoryInfo3(struct soap*, int)
        friend SOAP_FMAC1 mtrep6__ArrayOfRepositoryInfo3 * SOAP_FMAC2 repository_instantiate_mtrep6__ArrayOfRepositoryInfo3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:301 */
#ifndef SOAP_TYPE_mtrep6__RepositoryInfo
#define SOAP_TYPE_mtrep6__RepositoryInfo (48)
/* complex XSD type 'mtrep6:RepositoryInfo': */
class SOAP_CMAC mtrep6__RepositoryInfo {
      public:
        /// Optional element 'mtrep6:Country' of XSD type 'xsd:string'
        std::string *Country;
        /// Required element 'mtrep6:Date' of XSD type 'xsd:int'
        int Date;
        /// Required element 'mtrep6:Delay' of XSD type 'xsd:int'
        int Delay;
        /// Optional element 'mtrep6:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Required element 'mtrep6:Integrity' of XSD type 'mtrep6:RepositoryIntegrity'
        enum mtrep6__RepositoryIntegrity Integrity;
        /// Required element 'mtrep6:Level' of XSD type 'mtrep6:PackageLevel'
        enum mtrep6__PackageLevel Level;
        /// Required element 'mtrep6:Status' of XSD type 'mtrep6:RepositoryStatus'
        enum mtrep6__RepositoryStatus Status;
        /// Optional element 'mtrep6:Url' of XSD type 'xsd:string'
        std::string *Url;
        /// Required element 'mtrep6:Version' of XSD type 'xsd:int'
        int Version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep6__RepositoryInfo
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep6__RepositoryInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep6__RepositoryInfo, default initialized and not managed by a soap context
        virtual mtrep6__RepositoryInfo *soap_alloc(void) const { return SOAP_NEW(mtrep6__RepositoryInfo); }
      public:
        /// Constructor with initializations
        mtrep6__RepositoryInfo()
        {
          Country = (std::string *)0;
          Date = (int)0;
          Delay = (int)0;
          Description = (std::string *)0;
          Integrity = (enum mtrep6__RepositoryIntegrity)0;
          Level = (enum mtrep6__PackageLevel)0;
          Status = (enum mtrep6__RepositoryStatus)0;
          Url = (std::string *)0;
          Version = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~mtrep6__RepositoryInfo() { }
        /// Friend allocator used by soap_new_mtrep6__RepositoryInfo(struct soap*, int)
        friend SOAP_FMAC1 mtrep6__RepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep6__RepositoryInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:304 */
#ifndef SOAP_TYPE__mtrep6__GetRepositories4
#define SOAP_TYPE__mtrep6__GetRepositories4 (49)
/* complex XSD type 'mtrep6:GetRepositories4': */
class SOAP_CMAC _mtrep6__GetRepositories4 {
      public:
        /// Optional element 'mtrep6:clientInfo' of XSD type 'mtrep6:ClientInfo'
        mtrep6__ClientInfo *clientInfo;
        /// Required element 'mtrep6:onlyOnline' of XSD type 'xsd:boolean'
        bool onlyOnline;
        /// Required element 'mtrep6:noCorrupted' of XSD type 'xsd:boolean'
        bool noCorrupted;
        /// Required element 'mtrep6:httpOnly' of XSD type 'xsd:boolean'
        bool httpOnly;
        /// Required element 'mtrep6:excludeHidden' of XSD type 'xsd:boolean'
        bool excludeHidden;
        /// Required element 'mtrep6:maxDelay' of XSD type 'xsd:int'
        int maxDelay;
        /// Required element 'mtrep6:releaseState' of XSD type 'mtrep6:RepositoryReleaseState'
        enum mtrep6__RepositoryReleaseState releaseState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep6__GetRepositories4
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep6__GetRepositories4; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep6__GetRepositories4, default initialized and not managed by a soap context
        virtual _mtrep6__GetRepositories4 *soap_alloc(void) const { return SOAP_NEW(_mtrep6__GetRepositories4); }
      public:
        /// Constructor with initializations
        _mtrep6__GetRepositories4()
        {
          clientInfo = (mtrep6__ClientInfo *)0;
          onlyOnline = (bool)0;
          noCorrupted = (bool)0;
          httpOnly = (bool)0;
          excludeHidden = (bool)0;
          maxDelay = (int)0;
          releaseState = (enum mtrep6__RepositoryReleaseState)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep6__GetRepositories4() { }
        /// Friend allocator used by soap_new__mtrep6__GetRepositories4(struct soap*, int)
        friend SOAP_FMAC1 _mtrep6__GetRepositories4 * SOAP_FMAC2 repository_instantiate__mtrep6__GetRepositories4(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:307 */
#ifndef SOAP_TYPE__mtrep6__GetRepositories4Response
#define SOAP_TYPE__mtrep6__GetRepositories4Response (50)
/* complex XSD type 'mtrep6:GetRepositories4Response': */
class SOAP_CMAC _mtrep6__GetRepositories4Response {
      public:
        /// Optional element 'mtrep6:GetRepositories4Result' of XSD type 'mtrep6:ArrayOfRepositoryInfo3'
        mtrep6__ArrayOfRepositoryInfo3 *GetRepositories4Result;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep6__GetRepositories4Response
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep6__GetRepositories4Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep6__GetRepositories4Response, default initialized and not managed by a soap context
        virtual _mtrep6__GetRepositories4Response *soap_alloc(void) const { return SOAP_NEW(_mtrep6__GetRepositories4Response); }
      public:
        /// Constructor with initializations
        _mtrep6__GetRepositories4Response()
        {
          GetRepositories4Result = (mtrep6__ArrayOfRepositoryInfo3 *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep6__GetRepositories4Response() { }
        /// Friend allocator used by soap_new__mtrep6__GetRepositories4Response(struct soap*, int)
        friend SOAP_FMAC1 _mtrep6__GetRepositories4Response * SOAP_FMAC2 repository_instantiate__mtrep6__GetRepositories4Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:310 */
#ifndef SOAP_TYPE__mtrep6__PickRepository4
#define SOAP_TYPE__mtrep6__PickRepository4 (51)
/* complex XSD type 'mtrep6:PickRepository4': */
class SOAP_CMAC _mtrep6__PickRepository4 {
      public:
        /// Optional element 'mtrep6:clientInfo' of XSD type 'mtrep6:ClientInfo'
        mtrep6__ClientInfo *clientInfo;
        /// Required element 'mtrep6:favorHttp' of XSD type 'xsd:boolean'
        bool favorHttp;
        /// Required element 'mtrep6:nearest' of XSD type 'xsd:boolean'
        bool nearest;
        /// Required element 'mtrep6:releaseState' of XSD type 'mtrep6:RepositoryReleaseState'
        enum mtrep6__RepositoryReleaseState releaseState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep6__PickRepository4
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep6__PickRepository4; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep6__PickRepository4, default initialized and not managed by a soap context
        virtual _mtrep6__PickRepository4 *soap_alloc(void) const { return SOAP_NEW(_mtrep6__PickRepository4); }
      public:
        /// Constructor with initializations
        _mtrep6__PickRepository4()
        {
          clientInfo = (mtrep6__ClientInfo *)0;
          favorHttp = (bool)0;
          nearest = (bool)0;
          releaseState = (enum mtrep6__RepositoryReleaseState)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep6__PickRepository4() { }
        /// Friend allocator used by soap_new__mtrep6__PickRepository4(struct soap*, int)
        friend SOAP_FMAC1 _mtrep6__PickRepository4 * SOAP_FMAC2 repository_instantiate__mtrep6__PickRepository4(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:313 */
#ifndef SOAP_TYPE__mtrep6__PickRepository4Response
#define SOAP_TYPE__mtrep6__PickRepository4Response (52)
/* complex XSD type 'mtrep6:PickRepository4Response': */
class SOAP_CMAC _mtrep6__PickRepository4Response {
      public:
        /// Optional element 'mtrep6:PickRepository4Result' of XSD type 'mtrep6:RepositoryInfo3'
        mtrep6__RepositoryInfo3 *PickRepository4Result;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep6__PickRepository4Response
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep6__PickRepository4Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep6__PickRepository4Response, default initialized and not managed by a soap context
        virtual _mtrep6__PickRepository4Response *soap_alloc(void) const { return SOAP_NEW(_mtrep6__PickRepository4Response); }
      public:
        /// Constructor with initializations
        _mtrep6__PickRepository4Response()
        {
          PickRepository4Result = (mtrep6__RepositoryInfo3 *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep6__PickRepository4Response() { }
        /// Friend allocator used by soap_new__mtrep6__PickRepository4Response(struct soap*, int)
        friend SOAP_FMAC1 _mtrep6__PickRepository4Response * SOAP_FMAC2 repository_instantiate__mtrep6__PickRepository4Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:316 */
#ifndef SOAP_TYPE_mtrep7__ClientInfo
#define SOAP_TYPE_mtrep7__ClientInfo (53)
/* complex XSD type 'mtrep7:ClientInfo': */
class SOAP_CMAC mtrep7__ClientInfo {
      public:
        /// Optional element 'mtrep7:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Optional element 'mtrep7:Version' of XSD type 'xsd:string'
        std::string *Version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep7__ClientInfo
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep7__ClientInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep7__ClientInfo, default initialized and not managed by a soap context
        virtual mtrep7__ClientInfo *soap_alloc(void) const { return SOAP_NEW(mtrep7__ClientInfo); }
      public:
        /// Constructor with initializations
        mtrep7__ClientInfo()
        {
          Name = (std::string *)0;
          Version = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~mtrep7__ClientInfo() { }
        /// Friend allocator used by soap_new_mtrep7__ClientInfo(struct soap*, int)
        friend SOAP_FMAC1 mtrep7__ClientInfo * SOAP_FMAC2 repository_instantiate_mtrep7__ClientInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:325 */
#ifndef SOAP_TYPE_mtrep7__RepositoryInfo
#define SOAP_TYPE_mtrep7__RepositoryInfo (56)
/* complex XSD type 'mtrep7:RepositoryInfo': */
class SOAP_CMAC mtrep7__RepositoryInfo {
      public:
        /// Optional element 'mtrep7:Country' of XSD type 'xsd:string'
        std::string *Country;
        /// Required element 'mtrep7:Date' of XSD type 'xsd:int'
        int Date;
        /// Required element 'mtrep7:Delay' of XSD type 'xsd:int'
        int Delay;
        /// Optional element 'mtrep7:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Required element 'mtrep7:Integrity' of XSD type 'mtrep7:RepositoryIntegrity'
        enum mtrep7__RepositoryIntegrity Integrity;
        /// Required element 'mtrep7:Level' of XSD type 'mtrep7:PackageLevel'
        enum mtrep7__PackageLevel Level;
        /// Required element 'mtrep7:Status' of XSD type 'mtrep7:RepositoryStatus'
        enum mtrep7__RepositoryStatus Status;
        /// Optional element 'mtrep7:Url' of XSD type 'xsd:string'
        std::string *Url;
        /// Required element 'mtrep7:Version' of XSD type 'xsd:int'
        int Version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_mtrep7__RepositoryInfo
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep7__RepositoryInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep7__RepositoryInfo, default initialized and not managed by a soap context
        virtual mtrep7__RepositoryInfo *soap_alloc(void) const { return SOAP_NEW(mtrep7__RepositoryInfo); }
      public:
        /// Constructor with initializations
        mtrep7__RepositoryInfo()
        {
          Country = (std::string *)0;
          Date = (int)0;
          Delay = (int)0;
          Description = (std::string *)0;
          Integrity = (enum mtrep7__RepositoryIntegrity)0;
          Level = (enum mtrep7__PackageLevel)0;
          Status = (enum mtrep7__RepositoryStatus)0;
          Url = (std::string *)0;
          Version = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~mtrep7__RepositoryInfo() { }
        /// Friend allocator used by soap_new_mtrep7__RepositoryInfo(struct soap*, int)
        friend SOAP_FMAC1 mtrep7__RepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep7__RepositoryInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:328 */
#ifndef SOAP_TYPE__mtrep7__VerifyRepository2
#define SOAP_TYPE__mtrep7__VerifyRepository2 (57)
/* complex XSD type 'mtrep7:VerifyRepository2': */
class SOAP_CMAC _mtrep7__VerifyRepository2 {
      public:
        /// Optional element 'mtrep7:clientInfo' of XSD type 'mtrep7:ClientInfo'
        mtrep7__ClientInfo *clientInfo;
        /// Optional element 'mtrep7:url' of XSD type 'xsd:string'
        std::string *url;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep7__VerifyRepository2
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep7__VerifyRepository2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep7__VerifyRepository2, default initialized and not managed by a soap context
        virtual _mtrep7__VerifyRepository2 *soap_alloc(void) const { return SOAP_NEW(_mtrep7__VerifyRepository2); }
      public:
        /// Constructor with initializations
        _mtrep7__VerifyRepository2()
        {
          clientInfo = (mtrep7__ClientInfo *)0;
          url = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep7__VerifyRepository2() { }
        /// Friend allocator used by soap_new__mtrep7__VerifyRepository2(struct soap*, int)
        friend SOAP_FMAC1 _mtrep7__VerifyRepository2 * SOAP_FMAC2 repository_instantiate__mtrep7__VerifyRepository2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:331 */
#ifndef SOAP_TYPE__mtrep7__VerifyRepository2Response
#define SOAP_TYPE__mtrep7__VerifyRepository2Response (58)
/* complex XSD type 'mtrep7:VerifyRepository2Response': */
class SOAP_CMAC _mtrep7__VerifyRepository2Response {
      public:
        /// Required element 'mtrep7:VerifyRepository2Result' of XSD type 'xsd:boolean'
        bool VerifyRepository2Result;
        /// Optional element 'mtrep7:repositoryInfo' of XSD type 'mtrep7:RepositoryInfo3'
        mtrep7__RepositoryInfo3 *repositoryInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep7__VerifyRepository2Response
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep7__VerifyRepository2Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep7__VerifyRepository2Response, default initialized and not managed by a soap context
        virtual _mtrep7__VerifyRepository2Response *soap_alloc(void) const { return SOAP_NEW(_mtrep7__VerifyRepository2Response); }
      public:
        /// Constructor with initializations
        _mtrep7__VerifyRepository2Response()
        {
          VerifyRepository2Result = (bool)0;
          repositoryInfo = (mtrep7__RepositoryInfo3 *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep7__VerifyRepository2Response() { }
        /// Friend allocator used by soap_new__mtrep7__VerifyRepository2Response(struct soap*, int)
        friend SOAP_FMAC1 _mtrep7__VerifyRepository2Response * SOAP_FMAC2 repository_instantiate__mtrep7__VerifyRepository2Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:334 */
#ifndef SOAP_TYPE__mtrep7__TryGetRepositoryInfo3
#define SOAP_TYPE__mtrep7__TryGetRepositoryInfo3 (59)
/* complex XSD type 'mtrep7:TryGetRepositoryInfo3': */
class SOAP_CMAC _mtrep7__TryGetRepositoryInfo3 {
      public:
        /// Optional element 'mtrep7:clientInfo' of XSD type 'mtrep7:ClientInfo'
        mtrep7__ClientInfo *clientInfo;
        /// Optional element 'mtrep7:url' of XSD type 'xsd:string'
        std::string *url;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep7__TryGetRepositoryInfo3
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep7__TryGetRepositoryInfo3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep7__TryGetRepositoryInfo3, default initialized and not managed by a soap context
        virtual _mtrep7__TryGetRepositoryInfo3 *soap_alloc(void) const { return SOAP_NEW(_mtrep7__TryGetRepositoryInfo3); }
      public:
        /// Constructor with initializations
        _mtrep7__TryGetRepositoryInfo3()
        {
          clientInfo = (mtrep7__ClientInfo *)0;
          url = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep7__TryGetRepositoryInfo3() { }
        /// Friend allocator used by soap_new__mtrep7__TryGetRepositoryInfo3(struct soap*, int)
        friend SOAP_FMAC1 _mtrep7__TryGetRepositoryInfo3 * SOAP_FMAC2 repository_instantiate__mtrep7__TryGetRepositoryInfo3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:337 */
#ifndef SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response
#define SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response (60)
/* complex XSD type 'mtrep7:TryGetRepositoryInfo3Response': */
class SOAP_CMAC _mtrep7__TryGetRepositoryInfo3Response {
      public:
        /// Required element 'mtrep7:TryGetRepositoryInfo3Result' of XSD type 'xsd:boolean'
        bool TryGetRepositoryInfo3Result;
        /// Optional element 'mtrep7:repositoryInfo' of XSD type 'mtrep7:RepositoryInfo3'
        mtrep7__RepositoryInfo3 *repositoryInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response
        virtual int soap_type(void) const { return SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _mtrep7__TryGetRepositoryInfo3Response, default initialized and not managed by a soap context
        virtual _mtrep7__TryGetRepositoryInfo3Response *soap_alloc(void) const { return SOAP_NEW(_mtrep7__TryGetRepositoryInfo3Response); }
      public:
        /// Constructor with initializations
        _mtrep7__TryGetRepositoryInfo3Response()
        {
          TryGetRepositoryInfo3Result = (bool)0;
          repositoryInfo = (mtrep7__RepositoryInfo3 *)0;
          soap = (struct soap *)0;
        }
        virtual ~_mtrep7__TryGetRepositoryInfo3Response() { }
        /// Friend allocator used by soap_new__mtrep7__TryGetRepositoryInfo3Response(struct soap*, int)
        friend SOAP_FMAC1 _mtrep7__TryGetRepositoryInfo3Response * SOAP_FMAC2 repository_instantiate__mtrep7__TryGetRepositoryInfo3Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:271 */
#ifndef SOAP_TYPE_mtrep5__RepositoryInfo2
#define SOAP_TYPE_mtrep5__RepositoryInfo2 (38)
/* Type mtrep5__RepositoryInfo2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'mtrep5:RepositoryInfo2': */
class SOAP_CMAC mtrep5__RepositoryInfo2 : public mtrep5__RepositoryInfo {
      public:
        /// Optional element 'mtrep5:CountryCode' of XSD type 'xsd:string'
        std::string *CountryCode;
        /// Optional element 'mtrep5:City' of XSD type 'xsd:string'
        std::string *City;
        /// Required element 'mtrep5:Latitude' of XSD type 'xsd:double'
        double Latitude;
        /// Required element 'mtrep5:Longitude' of XSD type 'xsd:double'
        double Longitude;
      public:
        /// Return unique type id SOAP_TYPE_mtrep5__RepositoryInfo2
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep5__RepositoryInfo2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep5__RepositoryInfo2, default initialized and not managed by a soap context
        virtual mtrep5__RepositoryInfo2 *soap_alloc(void) const { return SOAP_NEW(mtrep5__RepositoryInfo2); }
      public:
        /// Constructor with initializations
        mtrep5__RepositoryInfo2()
        {
          CountryCode = (std::string *)0;
          City = (std::string *)0;
          Latitude = (double)0;
          Longitude = (double)0;
        }
        virtual ~mtrep5__RepositoryInfo2() { }
        /// Friend allocator used by soap_new_mtrep5__RepositoryInfo2(struct soap*, int)
        friend SOAP_FMAC1 mtrep5__RepositoryInfo2 * SOAP_FMAC2 repository_instantiate_mtrep5__RepositoryInfo2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:298 */
#ifndef SOAP_TYPE_mtrep6__RepositoryInfo2
#define SOAP_TYPE_mtrep6__RepositoryInfo2 (47)
/* Type mtrep6__RepositoryInfo2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'mtrep6:RepositoryInfo2': */
class SOAP_CMAC mtrep6__RepositoryInfo2 : public mtrep6__RepositoryInfo {
      public:
        /// Optional element 'mtrep6:CountryCode' of XSD type 'xsd:string'
        std::string *CountryCode;
        /// Optional element 'mtrep6:City' of XSD type 'xsd:string'
        std::string *City;
        /// Required element 'mtrep6:Latitude' of XSD type 'xsd:double'
        double Latitude;
        /// Required element 'mtrep6:Longitude' of XSD type 'xsd:double'
        double Longitude;
      public:
        /// Return unique type id SOAP_TYPE_mtrep6__RepositoryInfo2
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep6__RepositoryInfo2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep6__RepositoryInfo2, default initialized and not managed by a soap context
        virtual mtrep6__RepositoryInfo2 *soap_alloc(void) const { return SOAP_NEW(mtrep6__RepositoryInfo2); }
      public:
        /// Constructor with initializations
        mtrep6__RepositoryInfo2()
        {
          CountryCode = (std::string *)0;
          City = (std::string *)0;
          Latitude = (double)0;
          Longitude = (double)0;
        }
        virtual ~mtrep6__RepositoryInfo2() { }
        /// Friend allocator used by soap_new_mtrep6__RepositoryInfo2(struct soap*, int)
        friend SOAP_FMAC1 mtrep6__RepositoryInfo2 * SOAP_FMAC2 repository_instantiate_mtrep6__RepositoryInfo2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:322 */
#ifndef SOAP_TYPE_mtrep7__RepositoryInfo2
#define SOAP_TYPE_mtrep7__RepositoryInfo2 (55)
/* Type mtrep7__RepositoryInfo2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'mtrep7:RepositoryInfo2': */
class SOAP_CMAC mtrep7__RepositoryInfo2 : public mtrep7__RepositoryInfo {
      public:
        /// Optional element 'mtrep7:CountryCode' of XSD type 'xsd:string'
        std::string *CountryCode;
        /// Optional element 'mtrep7:City' of XSD type 'xsd:string'
        std::string *City;
        /// Required element 'mtrep7:Latitude' of XSD type 'xsd:double'
        double Latitude;
        /// Required element 'mtrep7:Longitude' of XSD type 'xsd:double'
        double Longitude;
      public:
        /// Return unique type id SOAP_TYPE_mtrep7__RepositoryInfo2
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep7__RepositoryInfo2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep7__RepositoryInfo2, default initialized and not managed by a soap context
        virtual mtrep7__RepositoryInfo2 *soap_alloc(void) const { return SOAP_NEW(mtrep7__RepositoryInfo2); }
      public:
        /// Constructor with initializations
        mtrep7__RepositoryInfo2()
        {
          CountryCode = (std::string *)0;
          City = (std::string *)0;
          Latitude = (double)0;
          Longitude = (double)0;
        }
        virtual ~mtrep7__RepositoryInfo2() { }
        /// Friend allocator used by soap_new_mtrep7__RepositoryInfo2(struct soap*, int)
        friend SOAP_FMAC1 mtrep7__RepositoryInfo2 * SOAP_FMAC2 repository_instantiate_mtrep7__RepositoryInfo2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:295 */
#ifndef SOAP_TYPE_mtrep6__RepositoryInfo3
#define SOAP_TYPE_mtrep6__RepositoryInfo3 (46)
/* Type mtrep6__RepositoryInfo3 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'mtrep6:RepositoryInfo3': */
class SOAP_CMAC mtrep6__RepositoryInfo3 : public mtrep6__RepositoryInfo2 {
      public:
        /// Optional element 'mtrep6:Attributes' of XSD type 'xsd:string'
        std::string *Attributes;
        /// Required element 'mtrep6:ReleaseState' of XSD type 'mtrep6:RepositoryReleaseState'
        enum mtrep6__RepositoryReleaseState ReleaseState;
      public:
        /// Return unique type id SOAP_TYPE_mtrep6__RepositoryInfo3
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep6__RepositoryInfo3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep6__RepositoryInfo3, default initialized and not managed by a soap context
        virtual mtrep6__RepositoryInfo3 *soap_alloc(void) const { return SOAP_NEW(mtrep6__RepositoryInfo3); }
      public:
        /// Constructor with initializations
        mtrep6__RepositoryInfo3()
        {
          Attributes = (std::string *)0;
          ReleaseState = (enum mtrep6__RepositoryReleaseState)0;
        }
        virtual ~mtrep6__RepositoryInfo3() { }
        /// Friend allocator used by soap_new_mtrep6__RepositoryInfo3(struct soap*, int)
        friend SOAP_FMAC1 mtrep6__RepositoryInfo3 * SOAP_FMAC2 repository_instantiate_mtrep6__RepositoryInfo3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:319 */
#ifndef SOAP_TYPE_mtrep7__RepositoryInfo3
#define SOAP_TYPE_mtrep7__RepositoryInfo3 (54)
/* Type mtrep7__RepositoryInfo3 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'mtrep7:RepositoryInfo3': */
class SOAP_CMAC mtrep7__RepositoryInfo3 : public mtrep7__RepositoryInfo2 {
      public:
        /// Optional element 'mtrep7:Attributes' of XSD type 'xsd:string'
        std::string *Attributes;
        /// Required element 'mtrep7:ReleaseState' of XSD type 'mtrep7:RepositoryReleaseState'
        enum mtrep7__RepositoryReleaseState ReleaseState;
      public:
        /// Return unique type id SOAP_TYPE_mtrep7__RepositoryInfo3
        virtual int soap_type(void) const { return SOAP_TYPE_mtrep7__RepositoryInfo3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mtrep7__RepositoryInfo3, default initialized and not managed by a soap context
        virtual mtrep7__RepositoryInfo3 *soap_alloc(void) const { return SOAP_NEW(mtrep7__RepositoryInfo3); }
      public:
        /// Constructor with initializations
        mtrep7__RepositoryInfo3()
        {
          Attributes = (std::string *)0;
          ReleaseState = (enum mtrep7__RepositoryReleaseState)0;
        }
        virtual ~mtrep7__RepositoryInfo3() { }
        /// Friend allocator used by soap_new_mtrep7__RepositoryInfo3(struct soap*, int)
        friend SOAP_FMAC1 mtrep7__RepositoryInfo3 * SOAP_FMAC2 repository_instantiate_mtrep7__RepositoryInfo3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:2334 */
#ifndef SOAP_TYPE___mtrep7__TryGetRepositoryInfo
#define SOAP_TYPE___mtrep7__TryGetRepositoryInfo (108)
/* Wrapper: */
struct __mtrep7__TryGetRepositoryInfo {
      public:
        /** Optional element 'mtrep:TryGetRepositoryInfo' of XSD type 'mtrep:TryGetRepositoryInfo' */
        _mtrep__TryGetRepositoryInfo *mtrep__TryGetRepositoryInfo;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__TryGetRepositoryInfo */
        int soap_type() const { return SOAP_TYPE___mtrep7__TryGetRepositoryInfo; }
        /** Constructor with member initializations */
        __mtrep7__TryGetRepositoryInfo()
        {
          mtrep__TryGetRepositoryInfo = (_mtrep__TryGetRepositoryInfo *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__TryGetRepositoryInfo(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__TryGetRepositoryInfo * SOAP_FMAC2 repository_instantiate___mtrep7__TryGetRepositoryInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:2401 */
#ifndef SOAP_TYPE___mtrep7__PickRepository
#define SOAP_TYPE___mtrep7__PickRepository (112)
/* Wrapper: */
struct __mtrep7__PickRepository {
      public:
        /** Optional element 'mtrep:PickRepository' of XSD type 'mtrep:PickRepository' */
        _mtrep__PickRepository *mtrep__PickRepository;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__PickRepository */
        int soap_type() const { return SOAP_TYPE___mtrep7__PickRepository; }
        /** Constructor with member initializations */
        __mtrep7__PickRepository()
        {
          mtrep__PickRepository = (_mtrep__PickRepository *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__PickRepository(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__PickRepository * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:2468 */
#ifndef SOAP_TYPE___mtrep7__GetAllRepositories
#define SOAP_TYPE___mtrep7__GetAllRepositories (116)
/* Wrapper: */
struct __mtrep7__GetAllRepositories {
      public:
        /** Optional element 'mtrep:GetAllRepositories' of XSD type 'mtrep:GetAllRepositories' */
        _mtrep__GetAllRepositories *mtrep__GetAllRepositories;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__GetAllRepositories */
        int soap_type() const { return SOAP_TYPE___mtrep7__GetAllRepositories; }
        /** Constructor with member initializations */
        __mtrep7__GetAllRepositories()
        {
          mtrep__GetAllRepositories = (_mtrep__GetAllRepositories *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__GetAllRepositories(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__GetAllRepositories * SOAP_FMAC2 repository_instantiate___mtrep7__GetAllRepositories(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:2535 */
#ifndef SOAP_TYPE___mtrep7__GetRepositories
#define SOAP_TYPE___mtrep7__GetRepositories (120)
/* Wrapper: */
struct __mtrep7__GetRepositories {
      public:
        /** Optional element 'mtrep:GetRepositories' of XSD type 'mtrep:GetRepositories' */
        _mtrep__GetRepositories *mtrep__GetRepositories;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__GetRepositories */
        int soap_type() const { return SOAP_TYPE___mtrep7__GetRepositories; }
        /** Constructor with member initializations */
        __mtrep7__GetRepositories()
        {
          mtrep__GetRepositories = (_mtrep__GetRepositories *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__GetRepositories(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__GetRepositories * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:2602 */
#ifndef SOAP_TYPE___mtrep7__GetListCreationTime
#define SOAP_TYPE___mtrep7__GetListCreationTime (124)
/* Wrapper: */
struct __mtrep7__GetListCreationTime {
      public:
        /** Optional element 'mtrep2:GetListCreationTime' of XSD type 'mtrep2:GetListCreationTime' */
        _mtrep2__GetListCreationTime *mtrep2__GetListCreationTime;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__GetListCreationTime */
        int soap_type() const { return SOAP_TYPE___mtrep7__GetListCreationTime; }
        /** Constructor with member initializations */
        __mtrep7__GetListCreationTime()
        {
          mtrep2__GetListCreationTime = (_mtrep2__GetListCreationTime *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__GetListCreationTime(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__GetListCreationTime * SOAP_FMAC2 repository_instantiate___mtrep7__GetListCreationTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:2669 */
#ifndef SOAP_TYPE___mtrep7__GetRepositories2
#define SOAP_TYPE___mtrep7__GetRepositories2 (128)
/* Wrapper: */
struct __mtrep7__GetRepositories2 {
      public:
        /** Optional element 'mtrep3:GetRepositories2' of XSD type 'mtrep3:GetRepositories2' */
        _mtrep3__GetRepositories2 *mtrep3__GetRepositories2;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__GetRepositories2 */
        int soap_type() const { return SOAP_TYPE___mtrep7__GetRepositories2; }
        /** Constructor with member initializations */
        __mtrep7__GetRepositories2()
        {
          mtrep3__GetRepositories2 = (_mtrep3__GetRepositories2 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__GetRepositories2(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__GetRepositories2 * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:2736 */
#ifndef SOAP_TYPE___mtrep7__PickRepository2
#define SOAP_TYPE___mtrep7__PickRepository2 (132)
/* Wrapper: */
struct __mtrep7__PickRepository2 {
      public:
        /** Optional element 'mtrep3:PickRepository2' of XSD type 'mtrep3:PickRepository2' */
        _mtrep3__PickRepository2 *mtrep3__PickRepository2;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__PickRepository2 */
        int soap_type() const { return SOAP_TYPE___mtrep7__PickRepository2; }
        /** Constructor with member initializations */
        __mtrep7__PickRepository2()
        {
          mtrep3__PickRepository2 = (_mtrep3__PickRepository2 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__PickRepository2(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__PickRepository2 * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:2803 */
#ifndef SOAP_TYPE___mtrep7__TryGetRepositoryInfo2
#define SOAP_TYPE___mtrep7__TryGetRepositoryInfo2 (136)
/* Wrapper: */
struct __mtrep7__TryGetRepositoryInfo2 {
      public:
        /** Optional element 'mtrep3:TryGetRepositoryInfo2' of XSD type 'mtrep3:TryGetRepositoryInfo2' */
        _mtrep3__TryGetRepositoryInfo2 *mtrep3__TryGetRepositoryInfo2;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__TryGetRepositoryInfo2 */
        int soap_type() const { return SOAP_TYPE___mtrep7__TryGetRepositoryInfo2; }
        /** Constructor with member initializations */
        __mtrep7__TryGetRepositoryInfo2()
        {
          mtrep3__TryGetRepositoryInfo2 = (_mtrep3__TryGetRepositoryInfo2 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__TryGetRepositoryInfo2(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__TryGetRepositoryInfo2 * SOAP_FMAC2 repository_instantiate___mtrep7__TryGetRepositoryInfo2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:2870 */
#ifndef SOAP_TYPE___mtrep7__VerifyRepository
#define SOAP_TYPE___mtrep7__VerifyRepository (140)
/* Wrapper: */
struct __mtrep7__VerifyRepository {
      public:
        /** Optional element 'mtrep4:VerifyRepository' of XSD type 'mtrep4:VerifyRepository' */
        _mtrep4__VerifyRepository *mtrep4__VerifyRepository;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__VerifyRepository */
        int soap_type() const { return SOAP_TYPE___mtrep7__VerifyRepository; }
        /** Constructor with member initializations */
        __mtrep7__VerifyRepository()
        {
          mtrep4__VerifyRepository = (_mtrep4__VerifyRepository *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__VerifyRepository(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__VerifyRepository * SOAP_FMAC2 repository_instantiate___mtrep7__VerifyRepository(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:2937 */
#ifndef SOAP_TYPE___mtrep7__GetRepositories3
#define SOAP_TYPE___mtrep7__GetRepositories3 (144)
/* Wrapper: */
struct __mtrep7__GetRepositories3 {
      public:
        /** Optional element 'mtrep5:GetRepositories3' of XSD type 'mtrep5:GetRepositories3' */
        _mtrep5__GetRepositories3 *mtrep5__GetRepositories3;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__GetRepositories3 */
        int soap_type() const { return SOAP_TYPE___mtrep7__GetRepositories3; }
        /** Constructor with member initializations */
        __mtrep7__GetRepositories3()
        {
          mtrep5__GetRepositories3 = (_mtrep5__GetRepositories3 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__GetRepositories3(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__GetRepositories3 * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3004 */
#ifndef SOAP_TYPE___mtrep7__PickRepository3
#define SOAP_TYPE___mtrep7__PickRepository3 (148)
/* Wrapper: */
struct __mtrep7__PickRepository3 {
      public:
        /** Optional element 'mtrep5:PickRepository3' of XSD type 'mtrep5:PickRepository3' */
        _mtrep5__PickRepository3 *mtrep5__PickRepository3;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__PickRepository3 */
        int soap_type() const { return SOAP_TYPE___mtrep7__PickRepository3; }
        /** Constructor with member initializations */
        __mtrep7__PickRepository3()
        {
          mtrep5__PickRepository3 = (_mtrep5__PickRepository3 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__PickRepository3(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__PickRepository3 * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3071 */
#ifndef SOAP_TYPE___mtrep7__GetRepositories4
#define SOAP_TYPE___mtrep7__GetRepositories4 (152)
/* Wrapper: */
struct __mtrep7__GetRepositories4 {
      public:
        /** Optional element 'mtrep6:GetRepositories4' of XSD type 'mtrep6:GetRepositories4' */
        _mtrep6__GetRepositories4 *mtrep6__GetRepositories4;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__GetRepositories4 */
        int soap_type() const { return SOAP_TYPE___mtrep7__GetRepositories4; }
        /** Constructor with member initializations */
        __mtrep7__GetRepositories4()
        {
          mtrep6__GetRepositories4 = (_mtrep6__GetRepositories4 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__GetRepositories4(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__GetRepositories4 * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories4(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3138 */
#ifndef SOAP_TYPE___mtrep7__PickRepository4
#define SOAP_TYPE___mtrep7__PickRepository4 (156)
/* Wrapper: */
struct __mtrep7__PickRepository4 {
      public:
        /** Optional element 'mtrep6:PickRepository4' of XSD type 'mtrep6:PickRepository4' */
        _mtrep6__PickRepository4 *mtrep6__PickRepository4;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__PickRepository4 */
        int soap_type() const { return SOAP_TYPE___mtrep7__PickRepository4; }
        /** Constructor with member initializations */
        __mtrep7__PickRepository4()
        {
          mtrep6__PickRepository4 = (_mtrep6__PickRepository4 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__PickRepository4(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__PickRepository4 * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository4(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3205 */
#ifndef SOAP_TYPE___mtrep7__VerifyRepository2
#define SOAP_TYPE___mtrep7__VerifyRepository2 (160)
/* Wrapper: */
struct __mtrep7__VerifyRepository2 {
      public:
        /** Optional element 'mtrep7:VerifyRepository2' of XSD type 'mtrep7:VerifyRepository2' */
        _mtrep7__VerifyRepository2 *mtrep7__VerifyRepository2;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__VerifyRepository2 */
        int soap_type() const { return SOAP_TYPE___mtrep7__VerifyRepository2; }
        /** Constructor with member initializations */
        __mtrep7__VerifyRepository2()
        {
          mtrep7__VerifyRepository2 = (_mtrep7__VerifyRepository2 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__VerifyRepository2(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__VerifyRepository2 * SOAP_FMAC2 repository_instantiate___mtrep7__VerifyRepository2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3272 */
#ifndef SOAP_TYPE___mtrep7__TryGetRepositoryInfo3
#define SOAP_TYPE___mtrep7__TryGetRepositoryInfo3 (164)
/* Wrapper: */
struct __mtrep7__TryGetRepositoryInfo3 {
      public:
        /** Optional element 'mtrep7:TryGetRepositoryInfo3' of XSD type 'mtrep7:TryGetRepositoryInfo3' */
        _mtrep7__TryGetRepositoryInfo3 *mtrep7__TryGetRepositoryInfo3;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__TryGetRepositoryInfo3 */
        int soap_type() const { return SOAP_TYPE___mtrep7__TryGetRepositoryInfo3; }
        /** Constructor with member initializations */
        __mtrep7__TryGetRepositoryInfo3()
        {
          mtrep7__TryGetRepositoryInfo3 = (_mtrep7__TryGetRepositoryInfo3 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__TryGetRepositoryInfo3(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__TryGetRepositoryInfo3 * SOAP_FMAC2 repository_instantiate___mtrep7__TryGetRepositoryInfo3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3339 */
#ifndef SOAP_TYPE___mtrep7__TryGetRepositoryInfo_
#define SOAP_TYPE___mtrep7__TryGetRepositoryInfo_ (166)
/* Wrapper: */
struct __mtrep7__TryGetRepositoryInfo_ {
      public:
        /** Optional element 'mtrep:TryGetRepositoryInfo' of XSD type 'mtrep:TryGetRepositoryInfo' */
        _mtrep__TryGetRepositoryInfo *mtrep__TryGetRepositoryInfo;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__TryGetRepositoryInfo_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__TryGetRepositoryInfo_; }
        /** Constructor with member initializations */
        __mtrep7__TryGetRepositoryInfo_()
        {
          mtrep__TryGetRepositoryInfo = (_mtrep__TryGetRepositoryInfo *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__TryGetRepositoryInfo_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__TryGetRepositoryInfo_ * SOAP_FMAC2 repository_instantiate___mtrep7__TryGetRepositoryInfo_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3406 */
#ifndef SOAP_TYPE___mtrep7__PickRepository_
#define SOAP_TYPE___mtrep7__PickRepository_ (168)
/* Wrapper: */
struct __mtrep7__PickRepository_ {
      public:
        /** Optional element 'mtrep:PickRepository' of XSD type 'mtrep:PickRepository' */
        _mtrep__PickRepository *mtrep__PickRepository;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__PickRepository_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__PickRepository_; }
        /** Constructor with member initializations */
        __mtrep7__PickRepository_()
        {
          mtrep__PickRepository = (_mtrep__PickRepository *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__PickRepository_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__PickRepository_ * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3473 */
#ifndef SOAP_TYPE___mtrep7__GetAllRepositories_
#define SOAP_TYPE___mtrep7__GetAllRepositories_ (170)
/* Wrapper: */
struct __mtrep7__GetAllRepositories_ {
      public:
        /** Optional element 'mtrep:GetAllRepositories' of XSD type 'mtrep:GetAllRepositories' */
        _mtrep__GetAllRepositories *mtrep__GetAllRepositories;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__GetAllRepositories_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__GetAllRepositories_; }
        /** Constructor with member initializations */
        __mtrep7__GetAllRepositories_()
        {
          mtrep__GetAllRepositories = (_mtrep__GetAllRepositories *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__GetAllRepositories_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__GetAllRepositories_ * SOAP_FMAC2 repository_instantiate___mtrep7__GetAllRepositories_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3540 */
#ifndef SOAP_TYPE___mtrep7__GetRepositories_
#define SOAP_TYPE___mtrep7__GetRepositories_ (172)
/* Wrapper: */
struct __mtrep7__GetRepositories_ {
      public:
        /** Optional element 'mtrep:GetRepositories' of XSD type 'mtrep:GetRepositories' */
        _mtrep__GetRepositories *mtrep__GetRepositories;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__GetRepositories_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__GetRepositories_; }
        /** Constructor with member initializations */
        __mtrep7__GetRepositories_()
        {
          mtrep__GetRepositories = (_mtrep__GetRepositories *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__GetRepositories_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__GetRepositories_ * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3607 */
#ifndef SOAP_TYPE___mtrep7__GetListCreationTime_
#define SOAP_TYPE___mtrep7__GetListCreationTime_ (174)
/* Wrapper: */
struct __mtrep7__GetListCreationTime_ {
      public:
        /** Optional element 'mtrep2:GetListCreationTime' of XSD type 'mtrep2:GetListCreationTime' */
        _mtrep2__GetListCreationTime *mtrep2__GetListCreationTime;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__GetListCreationTime_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__GetListCreationTime_; }
        /** Constructor with member initializations */
        __mtrep7__GetListCreationTime_()
        {
          mtrep2__GetListCreationTime = (_mtrep2__GetListCreationTime *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__GetListCreationTime_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__GetListCreationTime_ * SOAP_FMAC2 repository_instantiate___mtrep7__GetListCreationTime_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3674 */
#ifndef SOAP_TYPE___mtrep7__GetRepositories2_
#define SOAP_TYPE___mtrep7__GetRepositories2_ (176)
/* Wrapper: */
struct __mtrep7__GetRepositories2_ {
      public:
        /** Optional element 'mtrep3:GetRepositories2' of XSD type 'mtrep3:GetRepositories2' */
        _mtrep3__GetRepositories2 *mtrep3__GetRepositories2;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__GetRepositories2_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__GetRepositories2_; }
        /** Constructor with member initializations */
        __mtrep7__GetRepositories2_()
        {
          mtrep3__GetRepositories2 = (_mtrep3__GetRepositories2 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__GetRepositories2_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__GetRepositories2_ * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories2_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3741 */
#ifndef SOAP_TYPE___mtrep7__PickRepository2_
#define SOAP_TYPE___mtrep7__PickRepository2_ (178)
/* Wrapper: */
struct __mtrep7__PickRepository2_ {
      public:
        /** Optional element 'mtrep3:PickRepository2' of XSD type 'mtrep3:PickRepository2' */
        _mtrep3__PickRepository2 *mtrep3__PickRepository2;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__PickRepository2_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__PickRepository2_; }
        /** Constructor with member initializations */
        __mtrep7__PickRepository2_()
        {
          mtrep3__PickRepository2 = (_mtrep3__PickRepository2 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__PickRepository2_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__PickRepository2_ * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository2_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3808 */
#ifndef SOAP_TYPE___mtrep7__TryGetRepositoryInfo2_
#define SOAP_TYPE___mtrep7__TryGetRepositoryInfo2_ (180)
/* Wrapper: */
struct __mtrep7__TryGetRepositoryInfo2_ {
      public:
        /** Optional element 'mtrep3:TryGetRepositoryInfo2' of XSD type 'mtrep3:TryGetRepositoryInfo2' */
        _mtrep3__TryGetRepositoryInfo2 *mtrep3__TryGetRepositoryInfo2;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__TryGetRepositoryInfo2_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__TryGetRepositoryInfo2_; }
        /** Constructor with member initializations */
        __mtrep7__TryGetRepositoryInfo2_()
        {
          mtrep3__TryGetRepositoryInfo2 = (_mtrep3__TryGetRepositoryInfo2 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__TryGetRepositoryInfo2_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__TryGetRepositoryInfo2_ * SOAP_FMAC2 repository_instantiate___mtrep7__TryGetRepositoryInfo2_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3875 */
#ifndef SOAP_TYPE___mtrep7__VerifyRepository_
#define SOAP_TYPE___mtrep7__VerifyRepository_ (182)
/* Wrapper: */
struct __mtrep7__VerifyRepository_ {
      public:
        /** Optional element 'mtrep4:VerifyRepository' of XSD type 'mtrep4:VerifyRepository' */
        _mtrep4__VerifyRepository *mtrep4__VerifyRepository;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__VerifyRepository_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__VerifyRepository_; }
        /** Constructor with member initializations */
        __mtrep7__VerifyRepository_()
        {
          mtrep4__VerifyRepository = (_mtrep4__VerifyRepository *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__VerifyRepository_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__VerifyRepository_ * SOAP_FMAC2 repository_instantiate___mtrep7__VerifyRepository_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:3942 */
#ifndef SOAP_TYPE___mtrep7__GetRepositories3_
#define SOAP_TYPE___mtrep7__GetRepositories3_ (184)
/* Wrapper: */
struct __mtrep7__GetRepositories3_ {
      public:
        /** Optional element 'mtrep5:GetRepositories3' of XSD type 'mtrep5:GetRepositories3' */
        _mtrep5__GetRepositories3 *mtrep5__GetRepositories3;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__GetRepositories3_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__GetRepositories3_; }
        /** Constructor with member initializations */
        __mtrep7__GetRepositories3_()
        {
          mtrep5__GetRepositories3 = (_mtrep5__GetRepositories3 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__GetRepositories3_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__GetRepositories3_ * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories3_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:4009 */
#ifndef SOAP_TYPE___mtrep7__PickRepository3_
#define SOAP_TYPE___mtrep7__PickRepository3_ (186)
/* Wrapper: */
struct __mtrep7__PickRepository3_ {
      public:
        /** Optional element 'mtrep5:PickRepository3' of XSD type 'mtrep5:PickRepository3' */
        _mtrep5__PickRepository3 *mtrep5__PickRepository3;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__PickRepository3_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__PickRepository3_; }
        /** Constructor with member initializations */
        __mtrep7__PickRepository3_()
        {
          mtrep5__PickRepository3 = (_mtrep5__PickRepository3 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__PickRepository3_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__PickRepository3_ * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository3_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:4076 */
#ifndef SOAP_TYPE___mtrep7__GetRepositories4_
#define SOAP_TYPE___mtrep7__GetRepositories4_ (188)
/* Wrapper: */
struct __mtrep7__GetRepositories4_ {
      public:
        /** Optional element 'mtrep6:GetRepositories4' of XSD type 'mtrep6:GetRepositories4' */
        _mtrep6__GetRepositories4 *mtrep6__GetRepositories4;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__GetRepositories4_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__GetRepositories4_; }
        /** Constructor with member initializations */
        __mtrep7__GetRepositories4_()
        {
          mtrep6__GetRepositories4 = (_mtrep6__GetRepositories4 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__GetRepositories4_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__GetRepositories4_ * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories4_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:4143 */
#ifndef SOAP_TYPE___mtrep7__PickRepository4_
#define SOAP_TYPE___mtrep7__PickRepository4_ (190)
/* Wrapper: */
struct __mtrep7__PickRepository4_ {
      public:
        /** Optional element 'mtrep6:PickRepository4' of XSD type 'mtrep6:PickRepository4' */
        _mtrep6__PickRepository4 *mtrep6__PickRepository4;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__PickRepository4_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__PickRepository4_; }
        /** Constructor with member initializations */
        __mtrep7__PickRepository4_()
        {
          mtrep6__PickRepository4 = (_mtrep6__PickRepository4 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__PickRepository4_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__PickRepository4_ * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository4_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:4210 */
#ifndef SOAP_TYPE___mtrep7__VerifyRepository2_
#define SOAP_TYPE___mtrep7__VerifyRepository2_ (192)
/* Wrapper: */
struct __mtrep7__VerifyRepository2_ {
      public:
        /** Optional element 'mtrep7:VerifyRepository2' of XSD type 'mtrep7:VerifyRepository2' */
        _mtrep7__VerifyRepository2 *mtrep7__VerifyRepository2;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__VerifyRepository2_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__VerifyRepository2_; }
        /** Constructor with member initializations */
        __mtrep7__VerifyRepository2_()
        {
          mtrep7__VerifyRepository2 = (_mtrep7__VerifyRepository2 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__VerifyRepository2_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__VerifyRepository2_ * SOAP_FMAC2 repository_instantiate___mtrep7__VerifyRepository2_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:4277 */
#ifndef SOAP_TYPE___mtrep7__TryGetRepositoryInfo3_
#define SOAP_TYPE___mtrep7__TryGetRepositoryInfo3_ (194)
/* Wrapper: */
struct __mtrep7__TryGetRepositoryInfo3_ {
      public:
        /** Optional element 'mtrep7:TryGetRepositoryInfo3' of XSD type 'mtrep7:TryGetRepositoryInfo3' */
        _mtrep7__TryGetRepositoryInfo3 *mtrep7__TryGetRepositoryInfo3;
      public:
        /** Return unique type id SOAP_TYPE___mtrep7__TryGetRepositoryInfo3_ */
        int soap_type() const { return SOAP_TYPE___mtrep7__TryGetRepositoryInfo3_; }
        /** Constructor with member initializations */
        __mtrep7__TryGetRepositoryInfo3_()
        {
          mtrep7__TryGetRepositoryInfo3 = (_mtrep7__TryGetRepositoryInfo3 *)0;
        }
        /** Friend allocator used by soap_new___mtrep7__TryGetRepositoryInfo3_(struct soap*, int) */
        friend SOAP_FMAC1 __mtrep7__TryGetRepositoryInfo3_ * SOAP_FMAC2 repository_instantiate___mtrep7__TryGetRepositoryInfo3_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* Repository.h:4590 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (195)
/* SOAP_ENV__Header: */
struct SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 repository_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* Repository.h:4590 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (196)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 repository_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* Repository.h:4590 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (198)
/* SOAP_ENV__Detail: */
struct SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 repository_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* Repository.h:4590 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (201)
/* SOAP_ENV__Reason: */
struct SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 repository_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* Repository.h:4590 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (202)
/* SOAP_ENV__Fault: */
struct SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 repository_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* Repository.h:107 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* Repository.h:107 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (104)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (86)
#endif

/* enum mtrep7__RepositoryReleaseState has binding name 'mtrep7__RepositoryReleaseState' for type 'mtrep7:RepositoryReleaseState' */
#ifndef SOAP_TYPE_mtrep7__RepositoryReleaseState
#define SOAP_TYPE_mtrep7__RepositoryReleaseState (80)
#endif

/* enum mtrep7__RepositoryStatus has binding name 'mtrep7__RepositoryStatus' for type 'mtrep7:RepositoryStatus' */
#ifndef SOAP_TYPE_mtrep7__RepositoryStatus
#define SOAP_TYPE_mtrep7__RepositoryStatus (79)
#endif

/* enum mtrep7__PackageLevel has binding name 'mtrep7__PackageLevel' for type 'mtrep7:PackageLevel' */
#ifndef SOAP_TYPE_mtrep7__PackageLevel
#define SOAP_TYPE_mtrep7__PackageLevel (78)
#endif

/* enum mtrep7__RepositoryIntegrity has binding name 'mtrep7__RepositoryIntegrity' for type 'mtrep7:RepositoryIntegrity' */
#ifndef SOAP_TYPE_mtrep7__RepositoryIntegrity
#define SOAP_TYPE_mtrep7__RepositoryIntegrity (77)
#endif

/* enum mtrep6__RepositoryStatus has binding name 'mtrep6__RepositoryStatus' for type 'mtrep6:RepositoryStatus' */
#ifndef SOAP_TYPE_mtrep6__RepositoryStatus
#define SOAP_TYPE_mtrep6__RepositoryStatus (76)
#endif

/* enum mtrep6__PackageLevel has binding name 'mtrep6__PackageLevel' for type 'mtrep6:PackageLevel' */
#ifndef SOAP_TYPE_mtrep6__PackageLevel
#define SOAP_TYPE_mtrep6__PackageLevel (75)
#endif

/* enum mtrep6__RepositoryIntegrity has binding name 'mtrep6__RepositoryIntegrity' for type 'mtrep6:RepositoryIntegrity' */
#ifndef SOAP_TYPE_mtrep6__RepositoryIntegrity
#define SOAP_TYPE_mtrep6__RepositoryIntegrity (74)
#endif

/* enum mtrep6__RepositoryReleaseState has binding name 'mtrep6__RepositoryReleaseState' for type 'mtrep6:RepositoryReleaseState' */
#ifndef SOAP_TYPE_mtrep6__RepositoryReleaseState
#define SOAP_TYPE_mtrep6__RepositoryReleaseState (73)
#endif

/* enum mtrep5__RepositoryStatus has binding name 'mtrep5__RepositoryStatus' for type 'mtrep5:RepositoryStatus' */
#ifndef SOAP_TYPE_mtrep5__RepositoryStatus
#define SOAP_TYPE_mtrep5__RepositoryStatus (72)
#endif

/* enum mtrep5__PackageLevel has binding name 'mtrep5__PackageLevel' for type 'mtrep5:PackageLevel' */
#ifndef SOAP_TYPE_mtrep5__PackageLevel
#define SOAP_TYPE_mtrep5__PackageLevel (71)
#endif

/* enum mtrep5__RepositoryIntegrity has binding name 'mtrep5__RepositoryIntegrity' for type 'mtrep5:RepositoryIntegrity' */
#ifndef SOAP_TYPE_mtrep5__RepositoryIntegrity
#define SOAP_TYPE_mtrep5__RepositoryIntegrity (70)
#endif

/* enum mtrep4__RepositoryStatus has binding name 'mtrep4__RepositoryStatus' for type 'mtrep4:RepositoryStatus' */
#ifndef SOAP_TYPE_mtrep4__RepositoryStatus
#define SOAP_TYPE_mtrep4__RepositoryStatus (69)
#endif

/* enum mtrep4__PackageLevel has binding name 'mtrep4__PackageLevel' for type 'mtrep4:PackageLevel' */
#ifndef SOAP_TYPE_mtrep4__PackageLevel
#define SOAP_TYPE_mtrep4__PackageLevel (68)
#endif

/* enum mtrep4__RepositoryIntegrity has binding name 'mtrep4__RepositoryIntegrity' for type 'mtrep4:RepositoryIntegrity' */
#ifndef SOAP_TYPE_mtrep4__RepositoryIntegrity
#define SOAP_TYPE_mtrep4__RepositoryIntegrity (67)
#endif

/* enum mtrep3__RepositoryStatus has binding name 'mtrep3__RepositoryStatus' for type 'mtrep3:RepositoryStatus' */
#ifndef SOAP_TYPE_mtrep3__RepositoryStatus
#define SOAP_TYPE_mtrep3__RepositoryStatus (66)
#endif

/* enum mtrep3__PackageLevel has binding name 'mtrep3__PackageLevel' for type 'mtrep3:PackageLevel' */
#ifndef SOAP_TYPE_mtrep3__PackageLevel
#define SOAP_TYPE_mtrep3__PackageLevel (65)
#endif

/* enum mtrep3__RepositoryIntegrity has binding name 'mtrep3__RepositoryIntegrity' for type 'mtrep3:RepositoryIntegrity' */
#ifndef SOAP_TYPE_mtrep3__RepositoryIntegrity
#define SOAP_TYPE_mtrep3__RepositoryIntegrity (64)
#endif

/* enum mtrep__RepositoryStatus has binding name 'mtrep__RepositoryStatus' for type 'mtrep:RepositoryStatus' */
#ifndef SOAP_TYPE_mtrep__RepositoryStatus
#define SOAP_TYPE_mtrep__RepositoryStatus (63)
#endif

/* enum mtrep__PackageLevel has binding name 'mtrep__PackageLevel' for type 'mtrep:PackageLevel' */
#ifndef SOAP_TYPE_mtrep__PackageLevel
#define SOAP_TYPE_mtrep__PackageLevel (62)
#endif

/* enum mtrep__RepositoryIntegrity has binding name 'mtrep__RepositoryIntegrity' for type 'mtrep:RepositoryIntegrity' */
#ifndef SOAP_TYPE_mtrep__RepositoryIntegrity
#define SOAP_TYPE_mtrep__RepositoryIntegrity (61)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (81)
#endif

/* _mtrep7__TryGetRepositoryInfo3Response has binding name '_mtrep7__TryGetRepositoryInfo3Response' for type '' */
#ifndef SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response
#define SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response (60)
#endif

/* _mtrep7__TryGetRepositoryInfo3 has binding name '_mtrep7__TryGetRepositoryInfo3' for type '' */
#ifndef SOAP_TYPE__mtrep7__TryGetRepositoryInfo3
#define SOAP_TYPE__mtrep7__TryGetRepositoryInfo3 (59)
#endif

/* _mtrep7__VerifyRepository2Response has binding name '_mtrep7__VerifyRepository2Response' for type '' */
#ifndef SOAP_TYPE__mtrep7__VerifyRepository2Response
#define SOAP_TYPE__mtrep7__VerifyRepository2Response (58)
#endif

/* _mtrep7__VerifyRepository2 has binding name '_mtrep7__VerifyRepository2' for type '' */
#ifndef SOAP_TYPE__mtrep7__VerifyRepository2
#define SOAP_TYPE__mtrep7__VerifyRepository2 (57)
#endif

/* mtrep7__RepositoryInfo has binding name 'mtrep7__RepositoryInfo' for type 'mtrep7:RepositoryInfo' */
#ifndef SOAP_TYPE_mtrep7__RepositoryInfo
#define SOAP_TYPE_mtrep7__RepositoryInfo (56)
#endif

/* mtrep7__RepositoryInfo2 has binding name 'mtrep7__RepositoryInfo2' for type 'mtrep7:RepositoryInfo2' */
#ifndef SOAP_TYPE_mtrep7__RepositoryInfo2
#define SOAP_TYPE_mtrep7__RepositoryInfo2 (55)
#endif

/* mtrep7__RepositoryInfo3 has binding name 'mtrep7__RepositoryInfo3' for type 'mtrep7:RepositoryInfo3' */
#ifndef SOAP_TYPE_mtrep7__RepositoryInfo3
#define SOAP_TYPE_mtrep7__RepositoryInfo3 (54)
#endif

/* mtrep7__ClientInfo has binding name 'mtrep7__ClientInfo' for type 'mtrep7:ClientInfo' */
#ifndef SOAP_TYPE_mtrep7__ClientInfo
#define SOAP_TYPE_mtrep7__ClientInfo (53)
#endif

/* _mtrep6__PickRepository4Response has binding name '_mtrep6__PickRepository4Response' for type '' */
#ifndef SOAP_TYPE__mtrep6__PickRepository4Response
#define SOAP_TYPE__mtrep6__PickRepository4Response (52)
#endif

/* _mtrep6__PickRepository4 has binding name '_mtrep6__PickRepository4' for type '' */
#ifndef SOAP_TYPE__mtrep6__PickRepository4
#define SOAP_TYPE__mtrep6__PickRepository4 (51)
#endif

/* _mtrep6__GetRepositories4Response has binding name '_mtrep6__GetRepositories4Response' for type '' */
#ifndef SOAP_TYPE__mtrep6__GetRepositories4Response
#define SOAP_TYPE__mtrep6__GetRepositories4Response (50)
#endif

/* _mtrep6__GetRepositories4 has binding name '_mtrep6__GetRepositories4' for type '' */
#ifndef SOAP_TYPE__mtrep6__GetRepositories4
#define SOAP_TYPE__mtrep6__GetRepositories4 (49)
#endif

/* mtrep6__RepositoryInfo has binding name 'mtrep6__RepositoryInfo' for type 'mtrep6:RepositoryInfo' */
#ifndef SOAP_TYPE_mtrep6__RepositoryInfo
#define SOAP_TYPE_mtrep6__RepositoryInfo (48)
#endif

/* mtrep6__RepositoryInfo2 has binding name 'mtrep6__RepositoryInfo2' for type 'mtrep6:RepositoryInfo2' */
#ifndef SOAP_TYPE_mtrep6__RepositoryInfo2
#define SOAP_TYPE_mtrep6__RepositoryInfo2 (47)
#endif

/* mtrep6__RepositoryInfo3 has binding name 'mtrep6__RepositoryInfo3' for type 'mtrep6:RepositoryInfo3' */
#ifndef SOAP_TYPE_mtrep6__RepositoryInfo3
#define SOAP_TYPE_mtrep6__RepositoryInfo3 (46)
#endif

/* mtrep6__ArrayOfRepositoryInfo3 has binding name 'mtrep6__ArrayOfRepositoryInfo3' for type 'mtrep6:ArrayOfRepositoryInfo3' */
#ifndef SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3
#define SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3 (45)
#endif

/* mtrep6__ClientInfo has binding name 'mtrep6__ClientInfo' for type 'mtrep6:ClientInfo' */
#ifndef SOAP_TYPE_mtrep6__ClientInfo
#define SOAP_TYPE_mtrep6__ClientInfo (44)
#endif

/* _mtrep5__PickRepository3Response has binding name '_mtrep5__PickRepository3Response' for type '' */
#ifndef SOAP_TYPE__mtrep5__PickRepository3Response
#define SOAP_TYPE__mtrep5__PickRepository3Response (43)
#endif

/* _mtrep5__PickRepository3 has binding name '_mtrep5__PickRepository3' for type '' */
#ifndef SOAP_TYPE__mtrep5__PickRepository3
#define SOAP_TYPE__mtrep5__PickRepository3 (42)
#endif

/* _mtrep5__GetRepositories3Response has binding name '_mtrep5__GetRepositories3Response' for type '' */
#ifndef SOAP_TYPE__mtrep5__GetRepositories3Response
#define SOAP_TYPE__mtrep5__GetRepositories3Response (41)
#endif

/* _mtrep5__GetRepositories3 has binding name '_mtrep5__GetRepositories3' for type '' */
#ifndef SOAP_TYPE__mtrep5__GetRepositories3
#define SOAP_TYPE__mtrep5__GetRepositories3 (40)
#endif

/* mtrep5__RepositoryInfo has binding name 'mtrep5__RepositoryInfo' for type 'mtrep5:RepositoryInfo' */
#ifndef SOAP_TYPE_mtrep5__RepositoryInfo
#define SOAP_TYPE_mtrep5__RepositoryInfo (39)
#endif

/* mtrep5__RepositoryInfo2 has binding name 'mtrep5__RepositoryInfo2' for type 'mtrep5:RepositoryInfo2' */
#ifndef SOAP_TYPE_mtrep5__RepositoryInfo2
#define SOAP_TYPE_mtrep5__RepositoryInfo2 (38)
#endif

/* mtrep5__ArrayOfRepositoryInfo2 has binding name 'mtrep5__ArrayOfRepositoryInfo2' for type 'mtrep5:ArrayOfRepositoryInfo2' */
#ifndef SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2
#define SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2 (37)
#endif

/* mtrep5__ClientInfo has binding name 'mtrep5__ClientInfo' for type 'mtrep5:ClientInfo' */
#ifndef SOAP_TYPE_mtrep5__ClientInfo
#define SOAP_TYPE_mtrep5__ClientInfo (36)
#endif

/* _mtrep4__VerifyRepositoryResponse has binding name '_mtrep4__VerifyRepositoryResponse' for type '' */
#ifndef SOAP_TYPE__mtrep4__VerifyRepositoryResponse
#define SOAP_TYPE__mtrep4__VerifyRepositoryResponse (35)
#endif

/* _mtrep4__VerifyRepository has binding name '_mtrep4__VerifyRepository' for type '' */
#ifndef SOAP_TYPE__mtrep4__VerifyRepository
#define SOAP_TYPE__mtrep4__VerifyRepository (34)
#endif

/* mtrep4__RepositoryInfo has binding name 'mtrep4__RepositoryInfo' for type 'mtrep4:RepositoryInfo' */
#ifndef SOAP_TYPE_mtrep4__RepositoryInfo
#define SOAP_TYPE_mtrep4__RepositoryInfo (33)
#endif

/* mtrep4__ClientInfo has binding name 'mtrep4__ClientInfo' for type 'mtrep4:ClientInfo' */
#ifndef SOAP_TYPE_mtrep4__ClientInfo
#define SOAP_TYPE_mtrep4__ClientInfo (32)
#endif

/* _mtrep3__TryGetRepositoryInfo2Response has binding name '_mtrep3__TryGetRepositoryInfo2Response' for type '' */
#ifndef SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response
#define SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response (31)
#endif

/* _mtrep3__TryGetRepositoryInfo2 has binding name '_mtrep3__TryGetRepositoryInfo2' for type '' */
#ifndef SOAP_TYPE__mtrep3__TryGetRepositoryInfo2
#define SOAP_TYPE__mtrep3__TryGetRepositoryInfo2 (30)
#endif

/* _mtrep3__PickRepository2Response has binding name '_mtrep3__PickRepository2Response' for type '' */
#ifndef SOAP_TYPE__mtrep3__PickRepository2Response
#define SOAP_TYPE__mtrep3__PickRepository2Response (29)
#endif

/* _mtrep3__PickRepository2 has binding name '_mtrep3__PickRepository2' for type '' */
#ifndef SOAP_TYPE__mtrep3__PickRepository2
#define SOAP_TYPE__mtrep3__PickRepository2 (28)
#endif

/* _mtrep3__GetRepositories2Response has binding name '_mtrep3__GetRepositories2Response' for type '' */
#ifndef SOAP_TYPE__mtrep3__GetRepositories2Response
#define SOAP_TYPE__mtrep3__GetRepositories2Response (27)
#endif

/* _mtrep3__GetRepositories2 has binding name '_mtrep3__GetRepositories2' for type '' */
#ifndef SOAP_TYPE__mtrep3__GetRepositories2
#define SOAP_TYPE__mtrep3__GetRepositories2 (26)
#endif

/* mtrep3__RepositoryInfo has binding name 'mtrep3__RepositoryInfo' for type 'mtrep3:RepositoryInfo' */
#ifndef SOAP_TYPE_mtrep3__RepositoryInfo
#define SOAP_TYPE_mtrep3__RepositoryInfo (25)
#endif

/* mtrep3__ArrayOfRepositoryInfo has binding name 'mtrep3__ArrayOfRepositoryInfo' for type 'mtrep3:ArrayOfRepositoryInfo' */
#ifndef SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo
#define SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo (24)
#endif

/* mtrep3__ClientInfo has binding name 'mtrep3__ClientInfo' for type 'mtrep3:ClientInfo' */
#ifndef SOAP_TYPE_mtrep3__ClientInfo
#define SOAP_TYPE_mtrep3__ClientInfo (23)
#endif

/* _mtrep2__GetListCreationTimeResponse has binding name '_mtrep2__GetListCreationTimeResponse' for type '' */
#ifndef SOAP_TYPE__mtrep2__GetListCreationTimeResponse
#define SOAP_TYPE__mtrep2__GetListCreationTimeResponse (22)
#endif

/* _mtrep2__GetListCreationTime has binding name '_mtrep2__GetListCreationTime' for type '' */
#ifndef SOAP_TYPE__mtrep2__GetListCreationTime
#define SOAP_TYPE__mtrep2__GetListCreationTime (21)
#endif

/* _mtrep__GetRepositoriesResponse has binding name '_mtrep__GetRepositoriesResponse' for type '' */
#ifndef SOAP_TYPE__mtrep__GetRepositoriesResponse
#define SOAP_TYPE__mtrep__GetRepositoriesResponse (20)
#endif

/* _mtrep__GetRepositories has binding name '_mtrep__GetRepositories' for type '' */
#ifndef SOAP_TYPE__mtrep__GetRepositories
#define SOAP_TYPE__mtrep__GetRepositories (19)
#endif

/* _mtrep__GetAllRepositoriesResponse has binding name '_mtrep__GetAllRepositoriesResponse' for type '' */
#ifndef SOAP_TYPE__mtrep__GetAllRepositoriesResponse
#define SOAP_TYPE__mtrep__GetAllRepositoriesResponse (18)
#endif

/* _mtrep__GetAllRepositories has binding name '_mtrep__GetAllRepositories' for type '' */
#ifndef SOAP_TYPE__mtrep__GetAllRepositories
#define SOAP_TYPE__mtrep__GetAllRepositories (17)
#endif

/* _mtrep__PickRepositoryResponse has binding name '_mtrep__PickRepositoryResponse' for type '' */
#ifndef SOAP_TYPE__mtrep__PickRepositoryResponse
#define SOAP_TYPE__mtrep__PickRepositoryResponse (16)
#endif

/* _mtrep__PickRepository has binding name '_mtrep__PickRepository' for type '' */
#ifndef SOAP_TYPE__mtrep__PickRepository
#define SOAP_TYPE__mtrep__PickRepository (15)
#endif

/* _mtrep__TryGetRepositoryInfoResponse has binding name '_mtrep__TryGetRepositoryInfoResponse' for type '' */
#ifndef SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse
#define SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse (14)
#endif

/* _mtrep__TryGetRepositoryInfo has binding name '_mtrep__TryGetRepositoryInfo' for type '' */
#ifndef SOAP_TYPE__mtrep__TryGetRepositoryInfo
#define SOAP_TYPE__mtrep__TryGetRepositoryInfo (13)
#endif

/* mtrep__ArrayOfRepositoryInfo has binding name 'mtrep__ArrayOfRepositoryInfo' for type 'mtrep:ArrayOfRepositoryInfo' */
#ifndef SOAP_TYPE_mtrep__ArrayOfRepositoryInfo
#define SOAP_TYPE_mtrep__ArrayOfRepositoryInfo (12)
#endif

/* mtrep__RepositoryInfo has binding name 'mtrep__RepositoryInfo' for type 'mtrep:RepositoryInfo' */
#ifndef SOAP_TYPE_mtrep__RepositoryInfo
#define SOAP_TYPE_mtrep__RepositoryInfo (11)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (202)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (201)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (198)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (196)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (195)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (204)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (203)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (197)
#endif

/* _mtrep7__TryGetRepositoryInfo3 * has binding name 'PointerTo_mtrep7__TryGetRepositoryInfo3' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep7__TryGetRepositoryInfo3
#define SOAP_TYPE_PointerTo_mtrep7__TryGetRepositoryInfo3 (161)
#endif

/* _mtrep7__VerifyRepository2 * has binding name 'PointerTo_mtrep7__VerifyRepository2' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep7__VerifyRepository2
#define SOAP_TYPE_PointerTo_mtrep7__VerifyRepository2 (157)
#endif

/* _mtrep6__PickRepository4 * has binding name 'PointerTo_mtrep6__PickRepository4' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep6__PickRepository4
#define SOAP_TYPE_PointerTo_mtrep6__PickRepository4 (153)
#endif

/* _mtrep6__GetRepositories4 * has binding name 'PointerTo_mtrep6__GetRepositories4' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep6__GetRepositories4
#define SOAP_TYPE_PointerTo_mtrep6__GetRepositories4 (149)
#endif

/* _mtrep5__PickRepository3 * has binding name 'PointerTo_mtrep5__PickRepository3' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep5__PickRepository3
#define SOAP_TYPE_PointerTo_mtrep5__PickRepository3 (145)
#endif

/* _mtrep5__GetRepositories3 * has binding name 'PointerTo_mtrep5__GetRepositories3' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep5__GetRepositories3
#define SOAP_TYPE_PointerTo_mtrep5__GetRepositories3 (141)
#endif

/* _mtrep4__VerifyRepository * has binding name 'PointerTo_mtrep4__VerifyRepository' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep4__VerifyRepository
#define SOAP_TYPE_PointerTo_mtrep4__VerifyRepository (137)
#endif

/* _mtrep3__TryGetRepositoryInfo2 * has binding name 'PointerTo_mtrep3__TryGetRepositoryInfo2' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep3__TryGetRepositoryInfo2
#define SOAP_TYPE_PointerTo_mtrep3__TryGetRepositoryInfo2 (133)
#endif

/* _mtrep3__PickRepository2 * has binding name 'PointerTo_mtrep3__PickRepository2' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep3__PickRepository2
#define SOAP_TYPE_PointerTo_mtrep3__PickRepository2 (129)
#endif

/* _mtrep3__GetRepositories2 * has binding name 'PointerTo_mtrep3__GetRepositories2' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep3__GetRepositories2
#define SOAP_TYPE_PointerTo_mtrep3__GetRepositories2 (125)
#endif

/* _mtrep2__GetListCreationTime * has binding name 'PointerTo_mtrep2__GetListCreationTime' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep2__GetListCreationTime
#define SOAP_TYPE_PointerTo_mtrep2__GetListCreationTime (121)
#endif

/* _mtrep__GetRepositories * has binding name 'PointerTo_mtrep__GetRepositories' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep__GetRepositories
#define SOAP_TYPE_PointerTo_mtrep__GetRepositories (117)
#endif

/* _mtrep__GetAllRepositories * has binding name 'PointerTo_mtrep__GetAllRepositories' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep__GetAllRepositories
#define SOAP_TYPE_PointerTo_mtrep__GetAllRepositories (113)
#endif

/* _mtrep__PickRepository * has binding name 'PointerTo_mtrep__PickRepository' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep__PickRepository
#define SOAP_TYPE_PointerTo_mtrep__PickRepository (109)
#endif

/* _mtrep__TryGetRepositoryInfo * has binding name 'PointerTo_mtrep__TryGetRepositoryInfo' for type '' */
#ifndef SOAP_TYPE_PointerTo_mtrep__TryGetRepositoryInfo
#define SOAP_TYPE_PointerTo_mtrep__TryGetRepositoryInfo (105)
#endif

/* mtrep7__RepositoryInfo3 * has binding name 'PointerTomtrep7__RepositoryInfo3' for type 'mtrep7:RepositoryInfo3' */
#ifndef SOAP_TYPE_PointerTomtrep7__RepositoryInfo3
#define SOAP_TYPE_PointerTomtrep7__RepositoryInfo3 (103)
#endif

/* mtrep7__ClientInfo * has binding name 'PointerTomtrep7__ClientInfo' for type 'mtrep7:ClientInfo' */
#ifndef SOAP_TYPE_PointerTomtrep7__ClientInfo
#define SOAP_TYPE_PointerTomtrep7__ClientInfo (102)
#endif

/* mtrep6__ArrayOfRepositoryInfo3 * has binding name 'PointerTomtrep6__ArrayOfRepositoryInfo3' for type 'mtrep6:ArrayOfRepositoryInfo3' */
#ifndef SOAP_TYPE_PointerTomtrep6__ArrayOfRepositoryInfo3
#define SOAP_TYPE_PointerTomtrep6__ArrayOfRepositoryInfo3 (101)
#endif

/* mtrep6__ClientInfo * has binding name 'PointerTomtrep6__ClientInfo' for type 'mtrep6:ClientInfo' */
#ifndef SOAP_TYPE_PointerTomtrep6__ClientInfo
#define SOAP_TYPE_PointerTomtrep6__ClientInfo (100)
#endif

/* mtrep6__RepositoryInfo3 * has binding name 'PointerTomtrep6__RepositoryInfo3' for type 'mtrep6:RepositoryInfo3' */
#ifndef SOAP_TYPE_PointerTomtrep6__RepositoryInfo3
#define SOAP_TYPE_PointerTomtrep6__RepositoryInfo3 (98)
#endif

/* mtrep5__ArrayOfRepositoryInfo2 * has binding name 'PointerTomtrep5__ArrayOfRepositoryInfo2' for type 'mtrep5:ArrayOfRepositoryInfo2' */
#ifndef SOAP_TYPE_PointerTomtrep5__ArrayOfRepositoryInfo2
#define SOAP_TYPE_PointerTomtrep5__ArrayOfRepositoryInfo2 (97)
#endif

/* mtrep5__ClientInfo * has binding name 'PointerTomtrep5__ClientInfo' for type 'mtrep5:ClientInfo' */
#ifndef SOAP_TYPE_PointerTomtrep5__ClientInfo
#define SOAP_TYPE_PointerTomtrep5__ClientInfo (96)
#endif

/* mtrep5__RepositoryInfo2 * has binding name 'PointerTomtrep5__RepositoryInfo2' for type 'mtrep5:RepositoryInfo2' */
#ifndef SOAP_TYPE_PointerTomtrep5__RepositoryInfo2
#define SOAP_TYPE_PointerTomtrep5__RepositoryInfo2 (94)
#endif

/* mtrep4__RepositoryInfo * has binding name 'PointerTomtrep4__RepositoryInfo' for type 'mtrep4:RepositoryInfo' */
#ifndef SOAP_TYPE_PointerTomtrep4__RepositoryInfo
#define SOAP_TYPE_PointerTomtrep4__RepositoryInfo (93)
#endif

/* mtrep4__ClientInfo * has binding name 'PointerTomtrep4__ClientInfo' for type 'mtrep4:ClientInfo' */
#ifndef SOAP_TYPE_PointerTomtrep4__ClientInfo
#define SOAP_TYPE_PointerTomtrep4__ClientInfo (92)
#endif

/* mtrep3__ArrayOfRepositoryInfo * has binding name 'PointerTomtrep3__ArrayOfRepositoryInfo' for type 'mtrep3:ArrayOfRepositoryInfo' */
#ifndef SOAP_TYPE_PointerTomtrep3__ArrayOfRepositoryInfo
#define SOAP_TYPE_PointerTomtrep3__ArrayOfRepositoryInfo (91)
#endif

/* mtrep3__ClientInfo * has binding name 'PointerTomtrep3__ClientInfo' for type 'mtrep3:ClientInfo' */
#ifndef SOAP_TYPE_PointerTomtrep3__ClientInfo
#define SOAP_TYPE_PointerTomtrep3__ClientInfo (90)
#endif

/* mtrep3__RepositoryInfo * has binding name 'PointerTomtrep3__RepositoryInfo' for type 'mtrep3:RepositoryInfo' */
#ifndef SOAP_TYPE_PointerTomtrep3__RepositoryInfo
#define SOAP_TYPE_PointerTomtrep3__RepositoryInfo (88)
#endif

/* mtrep__ArrayOfRepositoryInfo * has binding name 'PointerTomtrep__ArrayOfRepositoryInfo' for type 'mtrep:ArrayOfRepositoryInfo' */
#ifndef SOAP_TYPE_PointerTomtrep__ArrayOfRepositoryInfo
#define SOAP_TYPE_PointerTomtrep__ArrayOfRepositoryInfo (87)
#endif

/* mtrep__RepositoryInfo * has binding name 'PointerTomtrep__RepositoryInfo' for type 'mtrep:RepositoryInfo' */
#ifndef SOAP_TYPE_PointerTomtrep__RepositoryInfo
#define SOAP_TYPE_PointerTomtrep__RepositoryInfo (84)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (82)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<mtrep6__RepositoryInfo3 *>  has binding name 'std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3' for type 'mtrep6:RepositoryInfo3' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3
#define SOAP_TYPE_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3 (99)
#endif

/* std::vector<mtrep5__RepositoryInfo2 *>  has binding name 'std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2' for type 'mtrep5:RepositoryInfo2' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2
#define SOAP_TYPE_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2 (95)
#endif

/* std::vector<mtrep3__RepositoryInfo *>  has binding name 'std__vectorTemplateOfPointerTomtrep3__RepositoryInfo' for type 'mtrep3:RepositoryInfo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo
#define SOAP_TYPE_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo (89)
#endif

/* std::vector<mtrep__RepositoryInfo *>  has binding name 'std__vectorTemplateOfPointerTomtrep__RepositoryInfo' for type 'mtrep:RepositoryInfo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTomtrep__RepositoryInfo
#define SOAP_TYPE_std__vectorTemplateOfPointerTomtrep__RepositoryInfo (85)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of repositoryStub.h */
