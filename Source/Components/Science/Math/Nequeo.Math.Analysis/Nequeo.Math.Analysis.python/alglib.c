/**************************************************************************
ALGLIB 3.10.0 (source code generated 2015-08-19)
Copyright (c) Sergey Bochkanov (ALGLIB project).

>>> SOURCE LICENSE >>>
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation (www.fsf.org); either version 2 of the 
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

A copy of the GNU General Public License is available at
http://www.fsf.org/licensing/licenses
>>> END OF LICENSE >>>
**************************************************************************/

#include <stdlib.h>
#include "aenv.h"
#include "alglib.h"

#ifdef X_FOR_WINDOWS
#define DLLEXPORT __declspec(dllexport)
#endif
#ifdef X_FOR_LINUX
#define DLLEXPORT
#endif

#pragma pack(1)
#define x_nb 16
#define bool8 char

enum
{
    X_OK = 0,
    X_MALLOC_ERROR = 1,
    X_DIV_BY_ZERO_ERROR = 2,
    X_32_64_ERROR = 3,
    X_ARRAY_TOO_LARGE = 4,
    X_ASSERTION_FAILED = 5
};

DLLEXPORT ae_int32_t x_malloc(void **p, ae_int64_t size)
{
    size_t volatile tmp;
    tmp = (size_t)size;
    if( tmp!=size )
        return X_MALLOC_ERROR;
    *p = aligned_malloc(tmp,16);
    if( *p || tmp==0 )
        return X_OK;
    return X_MALLOC_ERROR;
}
DLLEXPORT ae_int32_t x_free(void *p)
{
    aligned_free(p);
    return X_OK;
}
DLLEXPORT bool8 x_setnworkers(ae_int64_t nworkers)
{
    /* serial stub */
    return 1;
}
DLLEXPORT ae_int64_t x_alloc_counter()
{
    return _alloc_counter;
}
DLLEXPORT void x_alloc_counter_activate()
{
    _use_alloc_counter = ae_true;
}
DLLEXPORT bool8 x_is_symmetric_e_(x_matrix *a)
{
    return x_is_symmetric(a);
}
DLLEXPORT bool8 x_is_hermitian_e_(x_matrix *a)
{
    return x_is_hermitian(a);
}
DLLEXPORT bool8 x_force_symmetric_e_(x_matrix *a)
{
    return x_force_symmetric(a);
}
DLLEXPORT bool8 x_force_hermitian_e_(x_matrix *a)
{
    return x_force_hermitian(a);
}


typedef ALIGNED struct
{
    ALIGNED hqrndstate obj;
} x_hqrndstate;
x_hqrndstate* x_obj_alloc_hqrndstate(ae_state *_state)
{
    x_hqrndstate *result;
    result = ae_malloc(sizeof(x_hqrndstate), _state);
    _hqrndstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_hqrndstate* x_obj_copy_hqrndstate(x_hqrndstate *src)
{
    x_hqrndstate *result;
    result = ae_malloc(sizeof(x_hqrndstate), NULL);
    _hqrndstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_hqrndstate(x_hqrndstate *obj)
{
    if( obj==NULL )
        return;
    _hqrndstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT ae_int32_t alglib_hqrndrandomize(const char **errormsg, x_hqrndstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *state = x_obj_alloc_hqrndstate(&_alglib_env_state);
    hqrndrandomize(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hqrndseed(const char **errormsg, ae_int_t* s1, ae_int_t* s2, x_hqrndstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *state = x_obj_alloc_hqrndstate(&_alglib_env_state);
    hqrndseed(*s1, *s2, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hqrnduniformr(const char **errormsg, double* result, x_hqrndstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = hqrnduniformr(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hqrnduniformi(const char **errormsg, ae_int_t* result, x_hqrndstate** state, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = hqrnduniformi(&(*state)->obj, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hqrndnormal(const char **errormsg, double* result, x_hqrndstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = hqrndnormal(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hqrndunit2(const char **errormsg, x_hqrndstate** state, double* x, double* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    hqrndunit2(&(*state)->obj, x, y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hqrndnormal2(const char **errormsg, x_hqrndstate** state, double* x1, double* x2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    hqrndnormal2(&(*state)->obj, x1, x2, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hqrndexponential(const char **errormsg, double* result, x_hqrndstate** state, double* lambdav)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = hqrndexponential(&(*state)->obj, *lambdav, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hqrnddiscrete(const char **errormsg, double* result, x_hqrndstate** state, x_vector* x, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *result = hqrnddiscrete(&(*state)->obj, &_x, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hqrndcontinuous(const char **errormsg, double* result, x_hqrndstate** state, x_vector* x, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *result = hqrndcontinuous(&(*state)->obj, &_x, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED kdtree obj;
} x_kdtree;
x_kdtree* x_obj_alloc_kdtree(ae_state *_state)
{
    x_kdtree *result;
    result = ae_malloc(sizeof(x_kdtree), _state);
    _kdtree_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_kdtree* x_obj_copy_kdtree(x_kdtree *src)
{
    x_kdtree *result;
    result = ae_malloc(sizeof(x_kdtree), NULL);
    _kdtree_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_kdtree(x_kdtree *obj)
{
    if( obj==NULL )
        return;
    _kdtree_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT ae_int32_t alglib_kdtreeserialize(const char **errormsg, x_kdtree **obj, char **s_out)
{
    ae_state state;
    ae_serializer serializer;
    jmp_buf _break_jump;
    ae_frame _frame_block;
    
    ae_state_init(&state);
    ae_serializer_init(&serializer);
    if( setjmp(_break_jump) )
    {
        if( state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&state, &_break_jump);
    ae_frame_make(&state, &_frame_block);
    
    ae_serializer_alloc_start(&serializer);
    kdtreealloc(&serializer, &((*obj)->obj), &state);
    x_malloc((void**)(s_out), ae_serializer_get_alloc_size(&serializer)+1);
    ae_serializer_sstart_str(&serializer, *s_out);
    kdtreeserialize(&serializer, &((*obj)->obj), &state);
    ae_serializer_stop(&serializer);
    
    ae_serializer_clear(&serializer);
    ae_state_clear(&state);
    return X_OK;
}    
    
DLLEXPORT ae_int32_t alglib_kdtreeunserialize(const char **errormsg, char **s_in, x_kdtree **obj)
{
    ae_state state;
    ae_serializer serializer;
    jmp_buf _break_jump;
    ae_frame _frame_block;
    
    ae_state_init(&state);
    ae_serializer_init(&serializer);
    if( setjmp(_break_jump) )
    {
        if( state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&state, &_break_jump);
    ae_frame_make(&state, &_frame_block);
    
    *obj = x_obj_alloc_kdtree(&state);
    ae_serializer_ustart_str(&serializer, *s_in);
    kdtreeunserialize(&serializer, &((*obj)->obj), &state);
    ae_serializer_stop(&serializer);
    
    ae_serializer_clear(&serializer);
    ae_state_clear(&state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_kdtreebuild(const char **errormsg, x_matrix* xy, ae_int_t* n, ae_int_t* nx, ae_int_t* ny, ae_int_t* normtype, x_kdtree** kdt)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *kdt = x_obj_alloc_kdtree(&_alglib_env_state);
    kdtreebuild(&_xy, *n, *nx, *ny, *normtype, &(*kdt)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_kdtreebuildtagged(const char **errormsg, x_matrix* xy, x_vector* tags, ae_int_t* n, ae_int_t* nx, ae_int_t* ny, ae_int_t* normtype, x_kdtree** kdt)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _tags;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_attach_to_x(&_tags, tags, &_alglib_env_state);
    *kdt = x_obj_alloc_kdtree(&_alglib_env_state);
    kdtreebuildtagged(&_xy, &_tags, *n, *nx, *ny, *normtype, &(*kdt)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_kdtreequeryknn(const char **errormsg, ae_int_t* result, x_kdtree** kdt, x_vector* x, ae_int_t* k, bool8* selfmatch)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *result = kdtreequeryknn(&(*kdt)->obj, &_x, *k, *selfmatch, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_kdtreequeryrnn(const char **errormsg, ae_int_t* result, x_kdtree** kdt, x_vector* x, double* r, bool8* selfmatch)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *result = kdtreequeryrnn(&(*kdt)->obj, &_x, *r, *selfmatch, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_kdtreequeryaknn(const char **errormsg, ae_int_t* result, x_kdtree** kdt, x_vector* x, ae_int_t* k, bool8* selfmatch, double* eps)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *result = kdtreequeryaknn(&(*kdt)->obj, &_x, *k, *selfmatch, *eps, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_kdtreequeryresultsx(const char **errormsg, x_kdtree** kdt, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    kdtreequeryresultsx(&(*kdt)->obj, &_x, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_kdtreequeryresultsxy(const char **errormsg, x_kdtree** kdt, x_matrix* xy)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    kdtreequeryresultsxy(&(*kdt)->obj, &_xy, &_alglib_env_state);
    ae_x_set_matrix(xy, &_xy, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_kdtreequeryresultstags(const char **errormsg, x_kdtree** kdt, x_vector* tags)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _tags;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_tags, tags, &_alglib_env_state);
    kdtreequeryresultstags(&(*kdt)->obj, &_tags, &_alglib_env_state);
    ae_x_set_vector(tags, &_tags, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_kdtreequeryresultsdistances(const char **errormsg, x_kdtree** kdt, x_vector* r)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _r;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_r, r, &_alglib_env_state);
    kdtreequeryresultsdistances(&(*kdt)->obj, &_r, &_alglib_env_state);
    ae_x_set_vector(r, &_r, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_kdtreequeryresultsxi(const char **errormsg, x_kdtree** kdt, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_x, 0, 0, DT_REAL, &_alglib_env_state);
    kdtreequeryresultsxi(&(*kdt)->obj, &_x, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_kdtreequeryresultsxyi(const char **errormsg, x_kdtree** kdt, x_matrix* xy)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_xy, 0, 0, DT_REAL, &_alglib_env_state);
    kdtreequeryresultsxyi(&(*kdt)->obj, &_xy, &_alglib_env_state);
    ae_x_set_matrix(xy, &_xy, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_kdtreequeryresultstagsi(const char **errormsg, x_kdtree** kdt, x_vector* tags)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _tags;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_tags, 0, DT_INT, &_alglib_env_state);
    kdtreequeryresultstagsi(&(*kdt)->obj, &_tags, &_alglib_env_state);
    ae_x_set_vector(tags, &_tags, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_kdtreequeryresultsdistancesi(const char **errormsg, x_kdtree** kdt, x_vector* r)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _r;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_r, 0, DT_REAL, &_alglib_env_state);
    kdtreequeryresultsdistancesi(&(*kdt)->obj, &_r, &_alglib_env_state);
    ae_x_set_vector(r, &_r, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t i;
    ALIGNED ae_complex c;
    ALIGNED x_vector a;
} x_xdebugrecord1;
void x_set_xdebugrecord1(x_xdebugrecord1 *dst, xdebugrecord1 *src, ae_state *_state)
{
    dst->i = src->i;
    dst->c = src->c;
    ae_x_set_vector(&dst->a, &src->a, _state);
}
void xdebugrecord1_init_from_x(xdebugrecord1 *dst, x_xdebugrecord1 *src, ae_state *_state)
{
    dst->i = src->i;
    dst->c = src->c;
    ae_vector_init_from_x(&dst->a, &src->a, _state);
}
DLLEXPORT ae_int32_t alglib_xdebuginitrecord1(const char **errormsg, x_xdebugrecord1* rec1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    xdebugrecord1 _rec1;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    _xdebugrecord1_init(&_rec1, &_alglib_env_state);
    xdebuginitrecord1(&_rec1, &_alglib_env_state);
    x_set_xdebugrecord1(rec1, &_rec1, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugb1count(const char **errormsg, ae_int_t* result, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    *result = xdebugb1count(&_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugb1not(const char **errormsg, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugb1not(&_a, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugb1appendcopy(const char **errormsg, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugb1appendcopy(&_a, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugb1outeven(const char **errormsg, ae_int_t* n, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_a, 0, DT_BOOL, &_alglib_env_state);
    xdebugb1outeven(*n, &_a, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugi1sum(const char **errormsg, ae_int_t* result, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    *result = xdebugi1sum(&_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugi1neg(const char **errormsg, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugi1neg(&_a, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugi1appendcopy(const char **errormsg, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugi1appendcopy(&_a, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugi1outeven(const char **errormsg, ae_int_t* n, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_a, 0, DT_INT, &_alglib_env_state);
    xdebugi1outeven(*n, &_a, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugr1sum(const char **errormsg, double* result, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    *result = xdebugr1sum(&_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugr1neg(const char **errormsg, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugr1neg(&_a, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugr1appendcopy(const char **errormsg, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugr1appendcopy(&_a, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugr1outeven(const char **errormsg, ae_int_t* n, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_a, 0, DT_REAL, &_alglib_env_state);
    xdebugr1outeven(*n, &_a, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugc1sum(const char **errormsg, ae_complex* result, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    *result = xdebugc1sum(&_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugc1neg(const char **errormsg, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugc1neg(&_a, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugc1appendcopy(const char **errormsg, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugc1appendcopy(&_a, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugc1outeven(const char **errormsg, ae_int_t* n, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_a, 0, DT_COMPLEX, &_alglib_env_state);
    xdebugc1outeven(*n, &_a, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugb2count(const char **errormsg, ae_int_t* result, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = xdebugb2count(&_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugb2not(const char **errormsg, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugb2not(&_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugb2transpose(const char **errormsg, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugb2transpose(&_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugb2outsin(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_a, 0, 0, DT_BOOL, &_alglib_env_state);
    xdebugb2outsin(*m, *n, &_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugi2sum(const char **errormsg, ae_int_t* result, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = xdebugi2sum(&_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugi2neg(const char **errormsg, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugi2neg(&_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugi2transpose(const char **errormsg, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugi2transpose(&_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugi2outsin(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_a, 0, 0, DT_INT, &_alglib_env_state);
    xdebugi2outsin(*m, *n, &_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugr2sum(const char **errormsg, double* result, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = xdebugr2sum(&_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugr2neg(const char **errormsg, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugr2neg(&_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugr2transpose(const char **errormsg, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugr2transpose(&_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugr2outsin(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_a, 0, 0, DT_REAL, &_alglib_env_state);
    xdebugr2outsin(*m, *n, &_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugc2sum(const char **errormsg, ae_complex* result, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = xdebugc2sum(&_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugc2neg(const char **errormsg, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugc2neg(&_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugc2transpose(const char **errormsg, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    xdebugc2transpose(&_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugc2outsincos(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_a, 0, 0, DT_COMPLEX, &_alglib_env_state);
    xdebugc2outsincos(*m, *n, &_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_xdebugmaskedbiasedproductsum(const char **errormsg, double* result, ae_int_t* m, ae_int_t* n, x_matrix* a, x_matrix* b, x_matrix* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    *result = xdebugmaskedbiasedproductsum(*m, *n, &_a, &_b, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixtranspose(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* ia, ae_int_t* ja, x_matrix* b, ae_int_t* ib, ae_int_t* jb)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    cmatrixtranspose(*m, *n, &_a, *ia, *ja, &_b, *ib, *jb, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixtranspose(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* ia, ae_int_t* ja, x_matrix* b, ae_int_t* ib, ae_int_t* jb)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    rmatrixtranspose(*m, *n, &_a, *ia, *ja, &_b, *ib, *jb, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixenforcesymmetricity(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    rmatrixenforcesymmetricity(&_a, *n, *isupper, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixcopy(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* ia, ae_int_t* ja, x_matrix* b, ae_int_t* ib, ae_int_t* jb)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    cmatrixcopy(*m, *n, &_a, *ia, *ja, &_b, *ib, *jb, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixcopy(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* ia, ae_int_t* ja, x_matrix* b, ae_int_t* ib, ae_int_t* jb)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    rmatrixcopy(*m, *n, &_a, *ia, *ja, &_b, *ib, *jb, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixrank1(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* ia, ae_int_t* ja, x_vector* u, ae_int_t* iu, x_vector* v, ae_int_t* iv)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _u;
    ae_vector _v;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_u, u, &_alglib_env_state);
    ae_vector_attach_to_x(&_v, v, &_alglib_env_state);
    cmatrixrank1(*m, *n, &_a, *ia, *ja, &_u, *iu, &_v, *iv, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(u, &_u, &_alglib_env_state);
    ae_x_set_vector(v, &_v, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixrank1(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* ia, ae_int_t* ja, x_vector* u, ae_int_t* iu, x_vector* v, ae_int_t* iv)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _u;
    ae_vector _v;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_u, u, &_alglib_env_state);
    ae_vector_attach_to_x(&_v, v, &_alglib_env_state);
    rmatrixrank1(*m, *n, &_a, *ia, *ja, &_u, *iu, &_v, *iv, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(u, &_u, &_alglib_env_state);
    ae_x_set_vector(v, &_v, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixmv(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* ia, ae_int_t* ja, ae_int_t* opa, x_vector* x, ae_int_t* ix, x_vector* y, ae_int_t* iy)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    cmatrixmv(*m, *n, &_a, *ia, *ja, *opa, &_x, *ix, &_y, *iy, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixmv(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* ia, ae_int_t* ja, ae_int_t* opa, x_vector* x, ae_int_t* ix, x_vector* y, ae_int_t* iy)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    rmatrixmv(*m, *n, &_a, *ia, *ja, *opa, &_x, *ix, &_y, *iy, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixrighttrsm(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* i1, ae_int_t* j1, bool8* isupper, bool8* isunit, ae_int_t* optype, x_matrix* x, ae_int_t* i2, ae_int_t* j2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    cmatrixrighttrsm(*m, *n, &_a, *i1, *j1, *isupper, *isunit, *optype, &_x, *i2, *j2, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixrighttrsm(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* i1, ae_int_t* j1, bool8* isupper, bool8* isunit, ae_int_t* optype, x_matrix* x, ae_int_t* i2, ae_int_t* j2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    _pexec_cmatrixrighttrsm(*m, *n, &_a, *i1, *j1, *isupper, *isunit, *optype, &_x, *i2, *j2, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixlefttrsm(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* i1, ae_int_t* j1, bool8* isupper, bool8* isunit, ae_int_t* optype, x_matrix* x, ae_int_t* i2, ae_int_t* j2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    cmatrixlefttrsm(*m, *n, &_a, *i1, *j1, *isupper, *isunit, *optype, &_x, *i2, *j2, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixlefttrsm(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* i1, ae_int_t* j1, bool8* isupper, bool8* isunit, ae_int_t* optype, x_matrix* x, ae_int_t* i2, ae_int_t* j2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    _pexec_cmatrixlefttrsm(*m, *n, &_a, *i1, *j1, *isupper, *isunit, *optype, &_x, *i2, *j2, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixrighttrsm(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* i1, ae_int_t* j1, bool8* isupper, bool8* isunit, ae_int_t* optype, x_matrix* x, ae_int_t* i2, ae_int_t* j2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    rmatrixrighttrsm(*m, *n, &_a, *i1, *j1, *isupper, *isunit, *optype, &_x, *i2, *j2, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixrighttrsm(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* i1, ae_int_t* j1, bool8* isupper, bool8* isunit, ae_int_t* optype, x_matrix* x, ae_int_t* i2, ae_int_t* j2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    _pexec_rmatrixrighttrsm(*m, *n, &_a, *i1, *j1, *isupper, *isunit, *optype, &_x, *i2, *j2, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixlefttrsm(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* i1, ae_int_t* j1, bool8* isupper, bool8* isunit, ae_int_t* optype, x_matrix* x, ae_int_t* i2, ae_int_t* j2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    rmatrixlefttrsm(*m, *n, &_a, *i1, *j1, *isupper, *isunit, *optype, &_x, *i2, *j2, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixlefttrsm(const char **errormsg, ae_int_t* m, ae_int_t* n, x_matrix* a, ae_int_t* i1, ae_int_t* j1, bool8* isupper, bool8* isunit, ae_int_t* optype, x_matrix* x, ae_int_t* i2, ae_int_t* j2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    _pexec_rmatrixlefttrsm(*m, *n, &_a, *i1, *j1, *isupper, *isunit, *optype, &_x, *i2, *j2, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixherk(const char **errormsg, ae_int_t* n, ae_int_t* k, double* alpha, x_matrix* a, ae_int_t* ia, ae_int_t* ja, ae_int_t* optypea, double* beta, x_matrix* c, ae_int_t* ic, ae_int_t* jc, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    cmatrixherk(*n, *k, *alpha, &_a, *ia, *ja, *optypea, *beta, &_c, *ic, *jc, *isupper, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixherk(const char **errormsg, ae_int_t* n, ae_int_t* k, double* alpha, x_matrix* a, ae_int_t* ia, ae_int_t* ja, ae_int_t* optypea, double* beta, x_matrix* c, ae_int_t* ic, ae_int_t* jc, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    _pexec_cmatrixherk(*n, *k, *alpha, &_a, *ia, *ja, *optypea, *beta, &_c, *ic, *jc, *isupper, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixsyrk(const char **errormsg, ae_int_t* n, ae_int_t* k, double* alpha, x_matrix* a, ae_int_t* ia, ae_int_t* ja, ae_int_t* optypea, double* beta, x_matrix* c, ae_int_t* ic, ae_int_t* jc, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    rmatrixsyrk(*n, *k, *alpha, &_a, *ia, *ja, *optypea, *beta, &_c, *ic, *jc, *isupper, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixsyrk(const char **errormsg, ae_int_t* n, ae_int_t* k, double* alpha, x_matrix* a, ae_int_t* ia, ae_int_t* ja, ae_int_t* optypea, double* beta, x_matrix* c, ae_int_t* ic, ae_int_t* jc, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    _pexec_rmatrixsyrk(*n, *k, *alpha, &_a, *ia, *ja, *optypea, *beta, &_c, *ic, *jc, *isupper, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixgemm(const char **errormsg, ae_int_t* m, ae_int_t* n, ae_int_t* k, ae_complex* alpha, x_matrix* a, ae_int_t* ia, ae_int_t* ja, ae_int_t* optypea, x_matrix* b, ae_int_t* ib, ae_int_t* jb, ae_int_t* optypeb, ae_complex* beta, x_matrix* c, ae_int_t* ic, ae_int_t* jc)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    cmatrixgemm(*m, *n, *k, *alpha, &_a, *ia, *ja, *optypea, &_b, *ib, *jb, *optypeb, *beta, &_c, *ic, *jc, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixgemm(const char **errormsg, ae_int_t* m, ae_int_t* n, ae_int_t* k, ae_complex* alpha, x_matrix* a, ae_int_t* ia, ae_int_t* ja, ae_int_t* optypea, x_matrix* b, ae_int_t* ib, ae_int_t* jb, ae_int_t* optypeb, ae_complex* beta, x_matrix* c, ae_int_t* ic, ae_int_t* jc)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    _pexec_cmatrixgemm(*m, *n, *k, *alpha, &_a, *ia, *ja, *optypea, &_b, *ib, *jb, *optypeb, *beta, &_c, *ic, *jc, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixgemm(const char **errormsg, ae_int_t* m, ae_int_t* n, ae_int_t* k, double* alpha, x_matrix* a, ae_int_t* ia, ae_int_t* ja, ae_int_t* optypea, x_matrix* b, ae_int_t* ib, ae_int_t* jb, ae_int_t* optypeb, double* beta, x_matrix* c, ae_int_t* ic, ae_int_t* jc)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    rmatrixgemm(*m, *n, *k, *alpha, &_a, *ia, *ja, *optypea, &_b, *ib, *jb, *optypeb, *beta, &_c, *ic, *jc, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixgemm(const char **errormsg, ae_int_t* m, ae_int_t* n, ae_int_t* k, double* alpha, x_matrix* a, ae_int_t* ia, ae_int_t* ja, ae_int_t* optypea, x_matrix* b, ae_int_t* ib, ae_int_t* jb, ae_int_t* optypeb, double* beta, x_matrix* c, ae_int_t* ic, ae_int_t* jc)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    _pexec_rmatrixgemm(*m, *n, *k, *alpha, &_a, *ia, *ja, *optypea, &_b, *ib, *jb, *optypeb, *beta, &_c, *ic, *jc, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixsyrk(const char **errormsg, ae_int_t* n, ae_int_t* k, double* alpha, x_matrix* a, ae_int_t* ia, ae_int_t* ja, ae_int_t* optypea, double* beta, x_matrix* c, ae_int_t* ic, ae_int_t* jc, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    cmatrixsyrk(*n, *k, *alpha, &_a, *ia, *ja, *optypea, *beta, &_c, *ic, *jc, *isupper, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixsyrk(const char **errormsg, ae_int_t* n, ae_int_t* k, double* alpha, x_matrix* a, ae_int_t* ia, ae_int_t* ja, ae_int_t* optypea, double* beta, x_matrix* c, ae_int_t* ic, ae_int_t* jc, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    _pexec_cmatrixsyrk(*n, *k, *alpha, &_a, *ia, *ja, *optypea, *beta, &_c, *ic, *jc, *isupper, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_samplemoments(const char **errormsg, x_vector* x, ae_int_t* n, double* mean, double* variance, double* skewness, double* kurtosis)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    samplemoments(&_x, *n, mean, variance, skewness, kurtosis, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_samplemean(const char **errormsg, double* result, x_vector* x, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *result = samplemean(&_x, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_samplevariance(const char **errormsg, double* result, x_vector* x, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *result = samplevariance(&_x, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sampleskewness(const char **errormsg, double* result, x_vector* x, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *result = sampleskewness(&_x, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_samplekurtosis(const char **errormsg, double* result, x_vector* x, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *result = samplekurtosis(&_x, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sampleadev(const char **errormsg, x_vector* x, ae_int_t* n, double* adev)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    sampleadev(&_x, *n, adev, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_samplemedian(const char **errormsg, x_vector* x, ae_int_t* n, double* median)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    samplemedian(&_x, *n, median, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_samplepercentile(const char **errormsg, x_vector* x, ae_int_t* n, double* p, double* v)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    samplepercentile(&_x, *n, *p, v, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cov2(const char **errormsg, double* result, x_vector* x, x_vector* y, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *result = cov2(&_x, &_y, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pearsoncorr2(const char **errormsg, double* result, x_vector* x, x_vector* y, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *result = pearsoncorr2(&_x, &_y, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spearmancorr2(const char **errormsg, double* result, x_vector* x, x_vector* y, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *result = spearmancorr2(&_x, &_y, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_covm(const char **errormsg, x_matrix* x, ae_int_t* n, ae_int_t* m, x_matrix* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_matrix_init(&_c, 0, 0, DT_REAL, &_alglib_env_state);
    covm(&_x, *n, *m, &_c, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_covm(const char **errormsg, x_matrix* x, ae_int_t* n, ae_int_t* m, x_matrix* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_matrix_init(&_c, 0, 0, DT_REAL, &_alglib_env_state);
    _pexec_covm(&_x, *n, *m, &_c, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pearsoncorrm(const char **errormsg, x_matrix* x, ae_int_t* n, ae_int_t* m, x_matrix* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_matrix_init(&_c, 0, 0, DT_REAL, &_alglib_env_state);
    pearsoncorrm(&_x, *n, *m, &_c, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_pearsoncorrm(const char **errormsg, x_matrix* x, ae_int_t* n, ae_int_t* m, x_matrix* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_matrix_init(&_c, 0, 0, DT_REAL, &_alglib_env_state);
    _pexec_pearsoncorrm(&_x, *n, *m, &_c, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spearmancorrm(const char **errormsg, x_matrix* x, ae_int_t* n, ae_int_t* m, x_matrix* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_matrix_init(&_c, 0, 0, DT_REAL, &_alglib_env_state);
    spearmancorrm(&_x, *n, *m, &_c, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spearmancorrm(const char **errormsg, x_matrix* x, ae_int_t* n, ae_int_t* m, x_matrix* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_matrix_init(&_c, 0, 0, DT_REAL, &_alglib_env_state);
    _pexec_spearmancorrm(&_x, *n, *m, &_c, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_covm2(const char **errormsg, x_matrix* x, x_matrix* y, ae_int_t* n, ae_int_t* m1, ae_int_t* m2, x_matrix* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_matrix _y;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_matrix_attach_to_x(&_y, y, &_alglib_env_state);
    ae_matrix_init(&_c, 0, 0, DT_REAL, &_alglib_env_state);
    covm2(&_x, &_y, *n, *m1, *m2, &_c, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_covm2(const char **errormsg, x_matrix* x, x_matrix* y, ae_int_t* n, ae_int_t* m1, ae_int_t* m2, x_matrix* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_matrix _y;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_matrix_attach_to_x(&_y, y, &_alglib_env_state);
    ae_matrix_init(&_c, 0, 0, DT_REAL, &_alglib_env_state);
    _pexec_covm2(&_x, &_y, *n, *m1, *m2, &_c, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pearsoncorrm2(const char **errormsg, x_matrix* x, x_matrix* y, ae_int_t* n, ae_int_t* m1, ae_int_t* m2, x_matrix* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_matrix _y;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_matrix_attach_to_x(&_y, y, &_alglib_env_state);
    ae_matrix_init(&_c, 0, 0, DT_REAL, &_alglib_env_state);
    pearsoncorrm2(&_x, &_y, *n, *m1, *m2, &_c, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_pearsoncorrm2(const char **errormsg, x_matrix* x, x_matrix* y, ae_int_t* n, ae_int_t* m1, ae_int_t* m2, x_matrix* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_matrix _y;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_matrix_attach_to_x(&_y, y, &_alglib_env_state);
    ae_matrix_init(&_c, 0, 0, DT_REAL, &_alglib_env_state);
    _pexec_pearsoncorrm2(&_x, &_y, *n, *m1, *m2, &_c, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spearmancorrm2(const char **errormsg, x_matrix* x, x_matrix* y, ae_int_t* n, ae_int_t* m1, ae_int_t* m2, x_matrix* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_matrix _y;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_matrix_attach_to_x(&_y, y, &_alglib_env_state);
    ae_matrix_init(&_c, 0, 0, DT_REAL, &_alglib_env_state);
    spearmancorrm2(&_x, &_y, *n, *m1, *m2, &_c, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spearmancorrm2(const char **errormsg, x_matrix* x, x_matrix* y, ae_int_t* n, ae_int_t* m1, ae_int_t* m2, x_matrix* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_matrix _y;
    ae_matrix _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_matrix_attach_to_x(&_y, y, &_alglib_env_state);
    ae_matrix_init(&_c, 0, 0, DT_REAL, &_alglib_env_state);
    _pexec_spearmancorrm2(&_x, &_y, *n, *m1, *m2, &_c, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rankdata(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nfeatures)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    rankdata(&_xy, *npoints, *nfeatures, &_alglib_env_state);
    ae_x_set_matrix(xy, &_xy, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rankdata(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nfeatures)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    _pexec_rankdata(&_xy, *npoints, *nfeatures, &_alglib_env_state);
    ae_x_set_matrix(xy, &_xy, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rankdatacentered(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nfeatures)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    rankdatacentered(&_xy, *npoints, *nfeatures, &_alglib_env_state);
    ae_x_set_matrix(xy, &_xy, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rankdatacentered(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nfeatures)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    _pexec_rankdatacentered(&_xy, *npoints, *nfeatures, &_alglib_env_state);
    ae_x_set_matrix(xy, &_xy, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pearsoncorrelation(const char **errormsg, double* result, x_vector* x, x_vector* y, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *result = pearsoncorrelation(&_x, &_y, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spearmanrankcorrelation(const char **errormsg, double* result, x_vector* x, x_vector* y, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *result = spearmanrankcorrelation(&_x, &_y, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_dsoptimalsplit2(const char **errormsg, x_vector* a, x_vector* c, ae_int_t* n, ae_int_t* info, double* threshold, double* pal, double* pbl, double* par, double* pbr, double* cve)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_c, c, &_alglib_env_state);
    dsoptimalsplit2(&_a, &_c, *n, info, threshold, pal, pbl, par, pbr, cve, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_dsoptimalsplit2fast(const char **errormsg, x_vector* a, x_vector* c, x_vector* tiesbuf, x_vector* cntbuf, x_vector* bufr, x_vector* bufi, ae_int_t* n, ae_int_t* nc, double* alpha, ae_int_t* info, double* threshold, double* rms, double* cvrms)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_vector _c;
    ae_vector _tiesbuf;
    ae_vector _cntbuf;
    ae_vector _bufr;
    ae_vector _bufi;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_c, c, &_alglib_env_state);
    ae_vector_attach_to_x(&_tiesbuf, tiesbuf, &_alglib_env_state);
    ae_vector_attach_to_x(&_cntbuf, cntbuf, &_alglib_env_state);
    ae_vector_attach_to_x(&_bufr, bufr, &_alglib_env_state);
    ae_vector_attach_to_x(&_bufi, bufi, &_alglib_env_state);
    dsoptimalsplit2fast(&_a, &_c, &_tiesbuf, &_cntbuf, &_bufr, &_bufi, *n, *nc, *alpha, info, threshold, rms, cvrms, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    ae_x_set_vector(tiesbuf, &_tiesbuf, &_alglib_env_state);
    ae_x_set_vector(cntbuf, &_cntbuf, &_alglib_env_state);
    ae_x_set_vector(bufr, &_bufr, &_alglib_env_state);
    ae_x_set_vector(bufi, &_bufi, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED clusterizerstate obj;
} x_clusterizerstate;
x_clusterizerstate* x_obj_alloc_clusterizerstate(ae_state *_state)
{
    x_clusterizerstate *result;
    result = ae_malloc(sizeof(x_clusterizerstate), _state);
    _clusterizerstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_clusterizerstate* x_obj_copy_clusterizerstate(x_clusterizerstate *src)
{
    x_clusterizerstate *result;
    result = ae_malloc(sizeof(x_clusterizerstate), NULL);
    _clusterizerstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_clusterizerstate(x_clusterizerstate *obj)
{
    if( obj==NULL )
        return;
    _clusterizerstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t terminationtype;
    ALIGNED ae_int_t npoints;
    ALIGNED x_vector p;
    ALIGNED x_matrix z;
    ALIGNED x_matrix pz;
    ALIGNED x_matrix pm;
    ALIGNED x_vector mergedist;
} x_ahcreport;
void x_set_ahcreport(x_ahcreport *dst, ahcreport *src, ae_state *_state)
{
    dst->terminationtype = src->terminationtype;
    dst->npoints = src->npoints;
    ae_x_set_vector(&dst->p, &src->p, _state);
    ae_x_set_matrix(&dst->z, &src->z, _state);
    ae_x_set_matrix(&dst->pz, &src->pz, _state);
    ae_x_set_matrix(&dst->pm, &src->pm, _state);
    ae_x_set_vector(&dst->mergedist, &src->mergedist, _state);
}
void ahcreport_init_from_x(ahcreport *dst, x_ahcreport *src, ae_state *_state)
{
    dst->terminationtype = src->terminationtype;
    dst->npoints = src->npoints;
    ae_vector_init_from_x(&dst->p, &src->p, _state);
    ae_matrix_init_from_x(&dst->z, &src->z, _state);
    ae_matrix_init_from_x(&dst->pz, &src->pz, _state);
    ae_matrix_init_from_x(&dst->pm, &src->pm, _state);
    ae_vector_init_from_x(&dst->mergedist, &src->mergedist, _state);
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t npoints;
    ALIGNED ae_int_t nfeatures;
    ALIGNED ae_int_t terminationtype;
    ALIGNED ae_int_t iterationscount;
    ALIGNED double energy;
    ALIGNED ae_int_t k;
    ALIGNED x_matrix c;
    ALIGNED x_vector cidx;
} x_kmeansreport;
void x_set_kmeansreport(x_kmeansreport *dst, kmeansreport *src, ae_state *_state)
{
    dst->npoints = src->npoints;
    dst->nfeatures = src->nfeatures;
    dst->terminationtype = src->terminationtype;
    dst->iterationscount = src->iterationscount;
    dst->energy = src->energy;
    dst->k = src->k;
    ae_x_set_matrix(&dst->c, &src->c, _state);
    ae_x_set_vector(&dst->cidx, &src->cidx, _state);
}
void kmeansreport_init_from_x(kmeansreport *dst, x_kmeansreport *src, ae_state *_state)
{
    dst->npoints = src->npoints;
    dst->nfeatures = src->nfeatures;
    dst->terminationtype = src->terminationtype;
    dst->iterationscount = src->iterationscount;
    dst->energy = src->energy;
    dst->k = src->k;
    ae_matrix_init_from_x(&dst->c, &src->c, _state);
    ae_vector_init_from_x(&dst->cidx, &src->cidx, _state);
}
DLLEXPORT ae_int32_t alglib_clusterizercreate(const char **errormsg, x_clusterizerstate** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *s = x_obj_alloc_clusterizerstate(&_alglib_env_state);
    clusterizercreate(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_clusterizersetpoints(const char **errormsg, x_clusterizerstate** s, x_matrix* xy, ae_int_t* npoints, ae_int_t* nfeatures, ae_int_t* disttype)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    clusterizersetpoints(&(*s)->obj, &_xy, *npoints, *nfeatures, *disttype, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_clusterizersetdistances(const char **errormsg, x_clusterizerstate** s, x_matrix* d, ae_int_t* npoints, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _d;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_d, d, &_alglib_env_state);
    clusterizersetdistances(&(*s)->obj, &_d, *npoints, *isupper, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_clusterizersetahcalgo(const char **errormsg, x_clusterizerstate** s, ae_int_t* algo)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    clusterizersetahcalgo(&(*s)->obj, *algo, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_clusterizersetkmeanslimits(const char **errormsg, x_clusterizerstate** s, ae_int_t* restarts, ae_int_t* maxits)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    clusterizersetkmeanslimits(&(*s)->obj, *restarts, *maxits, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_clusterizersetkmeansinit(const char **errormsg, x_clusterizerstate** s, ae_int_t* initalgo)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    clusterizersetkmeansinit(&(*s)->obj, *initalgo, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_clusterizerrunahc(const char **errormsg, x_clusterizerstate** s, x_ahcreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ahcreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    _ahcreport_init(&_rep, &_alglib_env_state);
    clusterizerrunahc(&(*s)->obj, &_rep, &_alglib_env_state);
    x_set_ahcreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_clusterizerrunahc(const char **errormsg, x_clusterizerstate** s, x_ahcreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ahcreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    _ahcreport_init(&_rep, &_alglib_env_state);
    _pexec_clusterizerrunahc(&(*s)->obj, &_rep, &_alglib_env_state);
    x_set_ahcreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_clusterizerrunkmeans(const char **errormsg, x_clusterizerstate** s, ae_int_t* k, x_kmeansreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    kmeansreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    _kmeansreport_init(&_rep, &_alglib_env_state);
    clusterizerrunkmeans(&(*s)->obj, *k, &_rep, &_alglib_env_state);
    x_set_kmeansreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_clusterizerrunkmeans(const char **errormsg, x_clusterizerstate** s, ae_int_t* k, x_kmeansreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    kmeansreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    _kmeansreport_init(&_rep, &_alglib_env_state);
    _pexec_clusterizerrunkmeans(&(*s)->obj, *k, &_rep, &_alglib_env_state);
    x_set_kmeansreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_clusterizergetdistances(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nfeatures, ae_int_t* disttype, x_matrix* d)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_matrix _d;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_matrix_init(&_d, 0, 0, DT_REAL, &_alglib_env_state);
    clusterizergetdistances(&_xy, *npoints, *nfeatures, *disttype, &_d, &_alglib_env_state);
    ae_x_set_matrix(d, &_d, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_clusterizergetdistances(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nfeatures, ae_int_t* disttype, x_matrix* d)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_matrix _d;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_matrix_init(&_d, 0, 0, DT_REAL, &_alglib_env_state);
    _pexec_clusterizergetdistances(&_xy, *npoints, *nfeatures, *disttype, &_d, &_alglib_env_state);
    ae_x_set_matrix(d, &_d, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_clusterizergetkclusters(const char **errormsg, x_ahcreport* rep, ae_int_t* k, x_vector* cidx, x_vector* cz)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ahcreport _rep;
    ae_vector _cidx;
    ae_vector _cz;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ahcreport_init_from_x(&_rep, rep, &_alglib_env_state);
    ae_vector_init(&_cidx, 0, DT_INT, &_alglib_env_state);
    ae_vector_init(&_cz, 0, DT_INT, &_alglib_env_state);
    clusterizergetkclusters(&_rep, *k, &_cidx, &_cz, &_alglib_env_state);
    ae_x_set_vector(cidx, &_cidx, &_alglib_env_state);
    ae_x_set_vector(cz, &_cz, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_clusterizerseparatedbydist(const char **errormsg, x_ahcreport* rep, double* r, ae_int_t* k, x_vector* cidx, x_vector* cz)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ahcreport _rep;
    ae_vector _cidx;
    ae_vector _cz;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ahcreport_init_from_x(&_rep, rep, &_alglib_env_state);
    ae_vector_init(&_cidx, 0, DT_INT, &_alglib_env_state);
    ae_vector_init(&_cz, 0, DT_INT, &_alglib_env_state);
    clusterizerseparatedbydist(&_rep, *r, k, &_cidx, &_cz, &_alglib_env_state);
    ae_x_set_vector(cidx, &_cidx, &_alglib_env_state);
    ae_x_set_vector(cz, &_cz, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_clusterizerseparatedbycorr(const char **errormsg, x_ahcreport* rep, double* r, ae_int_t* k, x_vector* cidx, x_vector* cz)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ahcreport _rep;
    ae_vector _cidx;
    ae_vector _cz;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ahcreport_init_from_x(&_rep, rep, &_alglib_env_state);
    ae_vector_init(&_cidx, 0, DT_INT, &_alglib_env_state);
    ae_vector_init(&_cz, 0, DT_INT, &_alglib_env_state);
    clusterizerseparatedbycorr(&_rep, *r, k, &_cidx, &_cz, &_alglib_env_state);
    ae_x_set_vector(cidx, &_cidx, &_alglib_env_state);
    ae_x_set_vector(cz, &_cz, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_kmeansgenerate(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nvars, ae_int_t* k, ae_int_t* restarts, ae_int_t* info, x_matrix* c, x_vector* xyc)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_matrix _c;
    ae_vector _xyc;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_matrix_init(&_c, 0, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_xyc, 0, DT_INT, &_alglib_env_state);
    kmeansgenerate(&_xy, *npoints, *nvars, *k, *restarts, info, &_c, &_xyc, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_x_set_vector(xyc, &_xyc, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED decisionforest obj;
} x_decisionforest;
x_decisionforest* x_obj_alloc_decisionforest(ae_state *_state)
{
    x_decisionforest *result;
    result = ae_malloc(sizeof(x_decisionforest), _state);
    _decisionforest_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_decisionforest* x_obj_copy_decisionforest(x_decisionforest *src)
{
    x_decisionforest *result;
    result = ae_malloc(sizeof(x_decisionforest), NULL);
    _decisionforest_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_decisionforest(x_decisionforest *obj)
{
    if( obj==NULL )
        return;
    _decisionforest_clear(&obj->obj);
    ae_free(obj);
    return;
}
typedef ALIGNED struct
{
    ALIGNED double relclserror;
    ALIGNED double avgce;
    ALIGNED double rmserror;
    ALIGNED double avgerror;
    ALIGNED double avgrelerror;
    ALIGNED double oobrelclserror;
    ALIGNED double oobavgce;
    ALIGNED double oobrmserror;
    ALIGNED double oobavgerror;
    ALIGNED double oobavgrelerror;
} x_dfreport;
void x_set_dfreport(x_dfreport *dst, dfreport *src, ae_state *_state)
{
    dst->relclserror = src->relclserror;
    dst->avgce = src->avgce;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
    dst->oobrelclserror = src->oobrelclserror;
    dst->oobavgce = src->oobavgce;
    dst->oobrmserror = src->oobrmserror;
    dst->oobavgerror = src->oobavgerror;
    dst->oobavgrelerror = src->oobavgrelerror;
}
void dfreport_init_from_x(dfreport *dst, x_dfreport *src, ae_state *_state)
{
    dst->relclserror = src->relclserror;
    dst->avgce = src->avgce;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
    dst->oobrelclserror = src->oobrelclserror;
    dst->oobavgce = src->oobavgce;
    dst->oobrmserror = src->oobrmserror;
    dst->oobavgerror = src->oobavgerror;
    dst->oobavgrelerror = src->oobavgrelerror;
}
DLLEXPORT ae_int32_t alglib_dfserialize(const char **errormsg, x_decisionforest **obj, char **s_out)
{
    ae_state state;
    ae_serializer serializer;
    jmp_buf _break_jump;
    ae_frame _frame_block;
    
    ae_state_init(&state);
    ae_serializer_init(&serializer);
    if( setjmp(_break_jump) )
    {
        if( state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&state, &_break_jump);
    ae_frame_make(&state, &_frame_block);
    
    ae_serializer_alloc_start(&serializer);
    dfalloc(&serializer, &((*obj)->obj), &state);
    x_malloc((void**)(s_out), ae_serializer_get_alloc_size(&serializer)+1);
    ae_serializer_sstart_str(&serializer, *s_out);
    dfserialize(&serializer, &((*obj)->obj), &state);
    ae_serializer_stop(&serializer);
    
    ae_serializer_clear(&serializer);
    ae_state_clear(&state);
    return X_OK;
}    
    
DLLEXPORT ae_int32_t alglib_dfunserialize(const char **errormsg, char **s_in, x_decisionforest **obj)
{
    ae_state state;
    ae_serializer serializer;
    jmp_buf _break_jump;
    ae_frame _frame_block;
    
    ae_state_init(&state);
    ae_serializer_init(&serializer);
    if( setjmp(_break_jump) )
    {
        if( state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&state, &_break_jump);
    ae_frame_make(&state, &_frame_block);
    
    *obj = x_obj_alloc_decisionforest(&state);
    ae_serializer_ustart_str(&serializer, *s_in);
    dfunserialize(&serializer, &((*obj)->obj), &state);
    ae_serializer_stop(&serializer);
    
    ae_serializer_clear(&serializer);
    ae_state_clear(&state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_dfbuildrandomdecisionforest(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nvars, ae_int_t* nclasses, ae_int_t* ntrees, double* r, ae_int_t* info, x_decisionforest** df, x_dfreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    dfreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *df = x_obj_alloc_decisionforest(&_alglib_env_state);
    _dfreport_init(&_rep, &_alglib_env_state);
    dfbuildrandomdecisionforest(&_xy, *npoints, *nvars, *nclasses, *ntrees, *r, info, &(*df)->obj, &_rep, &_alglib_env_state);
    x_set_dfreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_dfbuildrandomdecisionforestx1(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nvars, ae_int_t* nclasses, ae_int_t* ntrees, ae_int_t* nrndvars, double* r, ae_int_t* info, x_decisionforest** df, x_dfreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    dfreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *df = x_obj_alloc_decisionforest(&_alglib_env_state);
    _dfreport_init(&_rep, &_alglib_env_state);
    dfbuildrandomdecisionforestx1(&_xy, *npoints, *nvars, *nclasses, *ntrees, *nrndvars, *r, info, &(*df)->obj, &_rep, &_alglib_env_state);
    x_set_dfreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_dfprocess(const char **errormsg, x_decisionforest** df, x_vector* x, x_vector* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    dfprocess(&(*df)->obj, &_x, &_y, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_dfprocessi(const char **errormsg, x_decisionforest** df, x_vector* x, x_vector* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_init(&_y, 0, DT_REAL, &_alglib_env_state);
    dfprocessi(&(*df)->obj, &_x, &_y, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_dfrelclserror(const char **errormsg, double* result, x_decisionforest** df, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = dfrelclserror(&(*df)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_dfavgce(const char **errormsg, double* result, x_decisionforest** df, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = dfavgce(&(*df)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_dfrmserror(const char **errormsg, double* result, x_decisionforest** df, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = dfrmserror(&(*df)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_dfavgerror(const char **errormsg, double* result, x_decisionforest** df, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = dfavgerror(&(*df)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_dfavgrelerror(const char **errormsg, double* result, x_decisionforest** df, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = dfavgrelerror(&(*df)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_gammafunction(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = gammafunction(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lngamma(const char **errormsg, double* result, double* x, double* sgngam)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = lngamma(*x, sgngam, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_errorfunction(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = errorfunction(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_errorfunctionc(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = errorfunctionc(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_normaldistribution(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = normaldistribution(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_inverf(const char **errormsg, double* result, double* e)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = inverf(*e, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_invnormaldistribution(const char **errormsg, double* result, double* y0)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = invnormaldistribution(*y0, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_incompletegamma(const char **errormsg, double* result, double* a, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = incompletegamma(*a, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_incompletegammac(const char **errormsg, double* result, double* a, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = incompletegammac(*a, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_invincompletegammac(const char **errormsg, double* result, double* a, double* y0)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = invincompletegammac(*a, *y0, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixqr(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_tau, 0, DT_REAL, &_alglib_env_state);
    rmatrixqr(&_a, *m, *n, &_tau, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(tau, &_tau, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixqr(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_tau, 0, DT_REAL, &_alglib_env_state);
    _pexec_rmatrixqr(&_a, *m, *n, &_tau, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(tau, &_tau, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixlq(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_tau, 0, DT_REAL, &_alglib_env_state);
    rmatrixlq(&_a, *m, *n, &_tau, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(tau, &_tau, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixlq(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_tau, 0, DT_REAL, &_alglib_env_state);
    _pexec_rmatrixlq(&_a, *m, *n, &_tau, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(tau, &_tau, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixqr(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_tau, 0, DT_COMPLEX, &_alglib_env_state);
    cmatrixqr(&_a, *m, *n, &_tau, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(tau, &_tau, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixqr(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_tau, 0, DT_COMPLEX, &_alglib_env_state);
    _pexec_cmatrixqr(&_a, *m, *n, &_tau, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(tau, &_tau, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixlq(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_tau, 0, DT_COMPLEX, &_alglib_env_state);
    cmatrixlq(&_a, *m, *n, &_tau, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(tau, &_tau, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixlq(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_tau, 0, DT_COMPLEX, &_alglib_env_state);
    _pexec_cmatrixlq(&_a, *m, *n, &_tau, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(tau, &_tau, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixqrunpackq(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau, ae_int_t* qcolumns, x_matrix* q)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_matrix _q;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_tau, tau, &_alglib_env_state);
    ae_matrix_init(&_q, 0, 0, DT_REAL, &_alglib_env_state);
    rmatrixqrunpackq(&_a, *m, *n, &_tau, *qcolumns, &_q, &_alglib_env_state);
    ae_x_set_matrix(q, &_q, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixqrunpackq(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau, ae_int_t* qcolumns, x_matrix* q)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_matrix _q;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_tau, tau, &_alglib_env_state);
    ae_matrix_init(&_q, 0, 0, DT_REAL, &_alglib_env_state);
    _pexec_rmatrixqrunpackq(&_a, *m, *n, &_tau, *qcolumns, &_q, &_alglib_env_state);
    ae_x_set_matrix(q, &_q, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixqrunpackr(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_matrix* r)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _r;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_init(&_r, 0, 0, DT_REAL, &_alglib_env_state);
    rmatrixqrunpackr(&_a, *m, *n, &_r, &_alglib_env_state);
    ae_x_set_matrix(r, &_r, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixlqunpackq(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau, ae_int_t* qrows, x_matrix* q)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_matrix _q;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_tau, tau, &_alglib_env_state);
    ae_matrix_init(&_q, 0, 0, DT_REAL, &_alglib_env_state);
    rmatrixlqunpackq(&_a, *m, *n, &_tau, *qrows, &_q, &_alglib_env_state);
    ae_x_set_matrix(q, &_q, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixlqunpackq(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau, ae_int_t* qrows, x_matrix* q)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_matrix _q;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_tau, tau, &_alglib_env_state);
    ae_matrix_init(&_q, 0, 0, DT_REAL, &_alglib_env_state);
    _pexec_rmatrixlqunpackq(&_a, *m, *n, &_tau, *qrows, &_q, &_alglib_env_state);
    ae_x_set_matrix(q, &_q, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixlqunpackl(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_matrix* l)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _l;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_init(&_l, 0, 0, DT_REAL, &_alglib_env_state);
    rmatrixlqunpackl(&_a, *m, *n, &_l, &_alglib_env_state);
    ae_x_set_matrix(l, &_l, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixqrunpackq(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau, ae_int_t* qcolumns, x_matrix* q)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_matrix _q;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_tau, tau, &_alglib_env_state);
    ae_matrix_init(&_q, 0, 0, DT_COMPLEX, &_alglib_env_state);
    cmatrixqrunpackq(&_a, *m, *n, &_tau, *qcolumns, &_q, &_alglib_env_state);
    ae_x_set_matrix(q, &_q, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixqrunpackq(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau, ae_int_t* qcolumns, x_matrix* q)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_matrix _q;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_tau, tau, &_alglib_env_state);
    ae_matrix_init(&_q, 0, 0, DT_COMPLEX, &_alglib_env_state);
    _pexec_cmatrixqrunpackq(&_a, *m, *n, &_tau, *qcolumns, &_q, &_alglib_env_state);
    ae_x_set_matrix(q, &_q, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixqrunpackr(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_matrix* r)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _r;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_init(&_r, 0, 0, DT_COMPLEX, &_alglib_env_state);
    cmatrixqrunpackr(&_a, *m, *n, &_r, &_alglib_env_state);
    ae_x_set_matrix(r, &_r, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixlqunpackq(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau, ae_int_t* qrows, x_matrix* q)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_matrix _q;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_tau, tau, &_alglib_env_state);
    ae_matrix_init(&_q, 0, 0, DT_COMPLEX, &_alglib_env_state);
    cmatrixlqunpackq(&_a, *m, *n, &_tau, *qrows, &_q, &_alglib_env_state);
    ae_x_set_matrix(q, &_q, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixlqunpackq(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tau, ae_int_t* qrows, x_matrix* q)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_matrix _q;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_tau, tau, &_alglib_env_state);
    ae_matrix_init(&_q, 0, 0, DT_COMPLEX, &_alglib_env_state);
    _pexec_cmatrixlqunpackq(&_a, *m, *n, &_tau, *qrows, &_q, &_alglib_env_state);
    ae_x_set_matrix(q, &_q, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixlqunpackl(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_matrix* l)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _l;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_init(&_l, 0, 0, DT_COMPLEX, &_alglib_env_state);
    cmatrixlqunpackl(&_a, *m, *n, &_l, &_alglib_env_state);
    ae_x_set_matrix(l, &_l, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixbd(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* tauq, x_vector* taup)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tauq;
    ae_vector _taup;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_tauq, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_taup, 0, DT_REAL, &_alglib_env_state);
    rmatrixbd(&_a, *m, *n, &_tauq, &_taup, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(tauq, &_tauq, &_alglib_env_state);
    ae_x_set_vector(taup, &_taup, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixbdunpackq(const char **errormsg, x_matrix* qp, ae_int_t* m, ae_int_t* n, x_vector* tauq, ae_int_t* qcolumns, x_matrix* q)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _qp;
    ae_vector _tauq;
    ae_matrix _q;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_qp, qp, &_alglib_env_state);
    ae_vector_attach_to_x(&_tauq, tauq, &_alglib_env_state);
    ae_matrix_init(&_q, 0, 0, DT_REAL, &_alglib_env_state);
    rmatrixbdunpackq(&_qp, *m, *n, &_tauq, *qcolumns, &_q, &_alglib_env_state);
    ae_x_set_matrix(q, &_q, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixbdmultiplybyq(const char **errormsg, x_matrix* qp, ae_int_t* m, ae_int_t* n, x_vector* tauq, x_matrix* z, ae_int_t* zrows, ae_int_t* zcolumns, bool8* fromtheright, bool8* dotranspose)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _qp;
    ae_vector _tauq;
    ae_matrix _z;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_qp, qp, &_alglib_env_state);
    ae_vector_attach_to_x(&_tauq, tauq, &_alglib_env_state);
    ae_matrix_attach_to_x(&_z, z, &_alglib_env_state);
    rmatrixbdmultiplybyq(&_qp, *m, *n, &_tauq, &_z, *zrows, *zcolumns, *fromtheright, *dotranspose, &_alglib_env_state);
    ae_x_set_matrix(z, &_z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixbdunpackpt(const char **errormsg, x_matrix* qp, ae_int_t* m, ae_int_t* n, x_vector* taup, ae_int_t* ptrows, x_matrix* pt)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _qp;
    ae_vector _taup;
    ae_matrix _pt;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_qp, qp, &_alglib_env_state);
    ae_vector_attach_to_x(&_taup, taup, &_alglib_env_state);
    ae_matrix_init(&_pt, 0, 0, DT_REAL, &_alglib_env_state);
    rmatrixbdunpackpt(&_qp, *m, *n, &_taup, *ptrows, &_pt, &_alglib_env_state);
    ae_x_set_matrix(pt, &_pt, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixbdmultiplybyp(const char **errormsg, x_matrix* qp, ae_int_t* m, ae_int_t* n, x_vector* taup, x_matrix* z, ae_int_t* zrows, ae_int_t* zcolumns, bool8* fromtheright, bool8* dotranspose)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _qp;
    ae_vector _taup;
    ae_matrix _z;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_qp, qp, &_alglib_env_state);
    ae_vector_attach_to_x(&_taup, taup, &_alglib_env_state);
    ae_matrix_attach_to_x(&_z, z, &_alglib_env_state);
    rmatrixbdmultiplybyp(&_qp, *m, *n, &_taup, &_z, *zrows, *zcolumns, *fromtheright, *dotranspose, &_alglib_env_state);
    ae_x_set_matrix(z, &_z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixbdunpackdiagonals(const char **errormsg, x_matrix* b, ae_int_t* m, ae_int_t* n, bool8* isupper, x_vector* d, x_vector* e)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _b;
    ae_vector _d;
    ae_vector _e;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    ae_vector_init(&_d, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_e, 0, DT_REAL, &_alglib_env_state);
    rmatrixbdunpackdiagonals(&_b, *m, *n, isupper, &_d, &_e, &_alglib_env_state);
    ae_x_set_vector(d, &_d, &_alglib_env_state);
    ae_x_set_vector(e, &_e, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixhessenberg(const char **errormsg, x_matrix* a, ae_int_t* n, x_vector* tau)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_tau, 0, DT_REAL, &_alglib_env_state);
    rmatrixhessenberg(&_a, *n, &_tau, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(tau, &_tau, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixhessenbergunpackq(const char **errormsg, x_matrix* a, ae_int_t* n, x_vector* tau, x_matrix* q)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_matrix _q;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_tau, tau, &_alglib_env_state);
    ae_matrix_init(&_q, 0, 0, DT_REAL, &_alglib_env_state);
    rmatrixhessenbergunpackq(&_a, *n, &_tau, &_q, &_alglib_env_state);
    ae_x_set_matrix(q, &_q, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixhessenbergunpackh(const char **errormsg, x_matrix* a, ae_int_t* n, x_matrix* h)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _h;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_init(&_h, 0, 0, DT_REAL, &_alglib_env_state);
    rmatrixhessenbergunpackh(&_a, *n, &_h, &_alglib_env_state);
    ae_x_set_matrix(h, &_h, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smatrixtd(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* tau, x_vector* d, x_vector* e)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_vector _d;
    ae_vector _e;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_tau, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_d, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_e, 0, DT_REAL, &_alglib_env_state);
    smatrixtd(&_a, *n, *isupper, &_tau, &_d, &_e, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(tau, &_tau, &_alglib_env_state);
    ae_x_set_vector(d, &_d, &_alglib_env_state);
    ae_x_set_vector(e, &_e, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smatrixtdunpackq(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* tau, x_matrix* q)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_matrix _q;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_tau, tau, &_alglib_env_state);
    ae_matrix_init(&_q, 0, 0, DT_REAL, &_alglib_env_state);
    smatrixtdunpackq(&_a, *n, *isupper, &_tau, &_q, &_alglib_env_state);
    ae_x_set_matrix(q, &_q, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hmatrixtd(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* tau, x_vector* d, x_vector* e)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_vector _d;
    ae_vector _e;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_tau, 0, DT_COMPLEX, &_alglib_env_state);
    ae_vector_init(&_d, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_e, 0, DT_REAL, &_alglib_env_state);
    hmatrixtd(&_a, *n, *isupper, &_tau, &_d, &_e, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(tau, &_tau, &_alglib_env_state);
    ae_x_set_vector(d, &_d, &_alglib_env_state);
    ae_x_set_vector(e, &_e, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hmatrixtdunpackq(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* tau, x_matrix* q)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _tau;
    ae_matrix _q;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_tau, tau, &_alglib_env_state);
    ae_matrix_init(&_q, 0, 0, DT_COMPLEX, &_alglib_env_state);
    hmatrixtdunpackq(&_a, *n, *isupper, &_tau, &_q, &_alglib_env_state);
    ae_x_set_matrix(q, &_q, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixbdsvd(const char **errormsg, bool8* result, x_vector* d, x_vector* e, ae_int_t* n, bool8* isupper, bool8* isfractionalaccuracyrequired, x_matrix* u, ae_int_t* nru, x_matrix* c, ae_int_t* ncc, x_matrix* vt, ae_int_t* ncvt)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _d;
    ae_vector _e;
    ae_matrix _u;
    ae_matrix _c;
    ae_matrix _vt;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_d, d, &_alglib_env_state);
    ae_vector_attach_to_x(&_e, e, &_alglib_env_state);
    ae_matrix_attach_to_x(&_u, u, &_alglib_env_state);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    ae_matrix_attach_to_x(&_vt, vt, &_alglib_env_state);
    *result = rmatrixbdsvd(&_d, &_e, *n, *isupper, *isfractionalaccuracyrequired, &_u, *nru, &_c, *ncc, &_vt, *ncvt, &_alglib_env_state);
    ae_x_set_vector(d, &_d, &_alglib_env_state);
    ae_x_set_matrix(u, &_u, &_alglib_env_state);
    ae_x_set_matrix(c, &_c, &_alglib_env_state);
    ae_x_set_matrix(vt, &_vt, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixsvd(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* m, ae_int_t* n, ae_int_t* uneeded, ae_int_t* vtneeded, ae_int_t* additionalmemory, x_vector* w, x_matrix* u, x_matrix* vt)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _w;
    ae_matrix _u;
    ae_matrix _vt;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_u, 0, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_vt, 0, 0, DT_REAL, &_alglib_env_state);
    *result = rmatrixsvd(&_a, *m, *n, *uneeded, *vtneeded, *additionalmemory, &_w, &_u, &_vt, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_x_set_matrix(u, &_u, &_alglib_env_state);
    ae_x_set_matrix(vt, &_vt, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixsvd(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* m, ae_int_t* n, ae_int_t* uneeded, ae_int_t* vtneeded, ae_int_t* additionalmemory, x_vector* w, x_matrix* u, x_matrix* vt)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _w;
    ae_matrix _u;
    ae_matrix _vt;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_u, 0, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_vt, 0, 0, DT_REAL, &_alglib_env_state);
    *result = _pexec_rmatrixsvd(&_a, *m, *n, *uneeded, *vtneeded, *additionalmemory, &_w, &_u, &_vt, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_x_set_matrix(u, &_u, &_alglib_env_state);
    ae_x_set_matrix(vt, &_vt, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED linearmodel obj;
} x_linearmodel;
x_linearmodel* x_obj_alloc_linearmodel(ae_state *_state)
{
    x_linearmodel *result;
    result = ae_malloc(sizeof(x_linearmodel), _state);
    _linearmodel_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_linearmodel* x_obj_copy_linearmodel(x_linearmodel *src)
{
    x_linearmodel *result;
    result = ae_malloc(sizeof(x_linearmodel), NULL);
    _linearmodel_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_linearmodel(x_linearmodel *obj)
{
    if( obj==NULL )
        return;
    _linearmodel_clear(&obj->obj);
    ae_free(obj);
    return;
}
typedef ALIGNED struct
{
    ALIGNED x_matrix c;
    ALIGNED double rmserror;
    ALIGNED double avgerror;
    ALIGNED double avgrelerror;
    ALIGNED double cvrmserror;
    ALIGNED double cvavgerror;
    ALIGNED double cvavgrelerror;
    ALIGNED ae_int_t ncvdefects;
    ALIGNED x_vector cvdefects;
} x_lrreport;
void x_set_lrreport(x_lrreport *dst, lrreport *src, ae_state *_state)
{
    ae_x_set_matrix(&dst->c, &src->c, _state);
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
    dst->cvrmserror = src->cvrmserror;
    dst->cvavgerror = src->cvavgerror;
    dst->cvavgrelerror = src->cvavgrelerror;
    dst->ncvdefects = src->ncvdefects;
    ae_x_set_vector(&dst->cvdefects, &src->cvdefects, _state);
}
void lrreport_init_from_x(lrreport *dst, x_lrreport *src, ae_state *_state)
{
    ae_matrix_init_from_x(&dst->c, &src->c, _state);
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
    dst->cvrmserror = src->cvrmserror;
    dst->cvavgerror = src->cvavgerror;
    dst->cvavgrelerror = src->cvavgrelerror;
    dst->ncvdefects = src->ncvdefects;
    ae_vector_init_from_x(&dst->cvdefects, &src->cvdefects, _state);
}
DLLEXPORT ae_int32_t alglib_lrbuild(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nvars, ae_int_t* info, x_linearmodel** lm, x_lrreport* ar)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    lrreport _ar;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *lm = x_obj_alloc_linearmodel(&_alglib_env_state);
    _lrreport_init(&_ar, &_alglib_env_state);
    lrbuild(&_xy, *npoints, *nvars, info, &(*lm)->obj, &_ar, &_alglib_env_state);
    x_set_lrreport(ar, &_ar, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lrbuilds(const char **errormsg, x_matrix* xy, x_vector* s, ae_int_t* npoints, ae_int_t* nvars, ae_int_t* info, x_linearmodel** lm, x_lrreport* ar)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _s;
    lrreport _ar;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_attach_to_x(&_s, s, &_alglib_env_state);
    *lm = x_obj_alloc_linearmodel(&_alglib_env_state);
    _lrreport_init(&_ar, &_alglib_env_state);
    lrbuilds(&_xy, &_s, *npoints, *nvars, info, &(*lm)->obj, &_ar, &_alglib_env_state);
    x_set_lrreport(ar, &_ar, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lrbuildzs(const char **errormsg, x_matrix* xy, x_vector* s, ae_int_t* npoints, ae_int_t* nvars, ae_int_t* info, x_linearmodel** lm, x_lrreport* ar)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _s;
    lrreport _ar;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_attach_to_x(&_s, s, &_alglib_env_state);
    *lm = x_obj_alloc_linearmodel(&_alglib_env_state);
    _lrreport_init(&_ar, &_alglib_env_state);
    lrbuildzs(&_xy, &_s, *npoints, *nvars, info, &(*lm)->obj, &_ar, &_alglib_env_state);
    x_set_lrreport(ar, &_ar, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lrbuildz(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nvars, ae_int_t* info, x_linearmodel** lm, x_lrreport* ar)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    lrreport _ar;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *lm = x_obj_alloc_linearmodel(&_alglib_env_state);
    _lrreport_init(&_ar, &_alglib_env_state);
    lrbuildz(&_xy, *npoints, *nvars, info, &(*lm)->obj, &_ar, &_alglib_env_state);
    x_set_lrreport(ar, &_ar, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lrunpack(const char **errormsg, x_linearmodel** lm, x_vector* v, ae_int_t* nvars)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _v;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_v, 0, DT_REAL, &_alglib_env_state);
    lrunpack(&(*lm)->obj, &_v, nvars, &_alglib_env_state);
    ae_x_set_vector(v, &_v, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lrpack(const char **errormsg, x_vector* v, ae_int_t* nvars, x_linearmodel** lm)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _v;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_v, v, &_alglib_env_state);
    *lm = x_obj_alloc_linearmodel(&_alglib_env_state);
    lrpack(&_v, *nvars, &(*lm)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lrprocess(const char **errormsg, double* result, x_linearmodel** lm, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *result = lrprocess(&(*lm)->obj, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lrrmserror(const char **errormsg, double* result, x_linearmodel** lm, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = lrrmserror(&(*lm)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lravgerror(const char **errormsg, double* result, x_linearmodel** lm, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = lravgerror(&(*lm)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lravgrelerror(const char **errormsg, double* result, x_linearmodel** lm, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = lravgrelerror(&(*lm)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_filtersma(const char **errormsg, x_vector* x, ae_int_t* n, ae_int_t* k)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    filtersma(&_x, *n, *k, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_filterema(const char **errormsg, x_vector* x, ae_int_t* n, double* alpha)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    filterema(&_x, *n, *alpha, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_filterlrma(const char **errormsg, x_vector* x, ae_int_t* n, ae_int_t* k)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    filterlrma(&_x, *n, *k, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smatrixevd(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* n, ae_int_t* zneeded, bool8* isupper, x_vector* d, x_matrix* z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _d;
    ae_matrix _z;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_d, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_z, 0, 0, DT_REAL, &_alglib_env_state);
    *result = smatrixevd(&_a, *n, *zneeded, *isupper, &_d, &_z, &_alglib_env_state);
    ae_x_set_vector(d, &_d, &_alglib_env_state);
    ae_x_set_matrix(z, &_z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smatrixevdr(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* n, ae_int_t* zneeded, bool8* isupper, double* b1, double* b2, ae_int_t* m, x_vector* w, x_matrix* z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _w;
    ae_matrix _z;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_z, 0, 0, DT_REAL, &_alglib_env_state);
    *result = smatrixevdr(&_a, *n, *zneeded, *isupper, *b1, *b2, m, &_w, &_z, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_x_set_matrix(z, &_z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smatrixevdi(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* n, ae_int_t* zneeded, bool8* isupper, ae_int_t* i1, ae_int_t* i2, x_vector* w, x_matrix* z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _w;
    ae_matrix _z;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_z, 0, 0, DT_REAL, &_alglib_env_state);
    *result = smatrixevdi(&_a, *n, *zneeded, *isupper, *i1, *i2, &_w, &_z, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_x_set_matrix(z, &_z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hmatrixevd(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* n, ae_int_t* zneeded, bool8* isupper, x_vector* d, x_matrix* z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _d;
    ae_matrix _z;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_d, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_z, 0, 0, DT_COMPLEX, &_alglib_env_state);
    *result = hmatrixevd(&_a, *n, *zneeded, *isupper, &_d, &_z, &_alglib_env_state);
    ae_x_set_vector(d, &_d, &_alglib_env_state);
    ae_x_set_matrix(z, &_z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hmatrixevdr(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* n, ae_int_t* zneeded, bool8* isupper, double* b1, double* b2, ae_int_t* m, x_vector* w, x_matrix* z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _w;
    ae_matrix _z;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_z, 0, 0, DT_COMPLEX, &_alglib_env_state);
    *result = hmatrixevdr(&_a, *n, *zneeded, *isupper, *b1, *b2, m, &_w, &_z, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_x_set_matrix(z, &_z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hmatrixevdi(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* n, ae_int_t* zneeded, bool8* isupper, ae_int_t* i1, ae_int_t* i2, x_vector* w, x_matrix* z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _w;
    ae_matrix _z;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_z, 0, 0, DT_COMPLEX, &_alglib_env_state);
    *result = hmatrixevdi(&_a, *n, *zneeded, *isupper, *i1, *i2, &_w, &_z, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_x_set_matrix(z, &_z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smatrixtdevd(const char **errormsg, bool8* result, x_vector* d, x_vector* e, ae_int_t* n, ae_int_t* zneeded, x_matrix* z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _d;
    ae_vector _e;
    ae_matrix _z;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_d, d, &_alglib_env_state);
    ae_vector_attach_to_x(&_e, e, &_alglib_env_state);
    ae_matrix_attach_to_x(&_z, z, &_alglib_env_state);
    *result = smatrixtdevd(&_d, &_e, *n, *zneeded, &_z, &_alglib_env_state);
    ae_x_set_vector(d, &_d, &_alglib_env_state);
    ae_x_set_matrix(z, &_z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smatrixtdevdr(const char **errormsg, bool8* result, x_vector* d, x_vector* e, ae_int_t* n, ae_int_t* zneeded, double* a, double* b, ae_int_t* m, x_matrix* z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _d;
    ae_vector _e;
    ae_matrix _z;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_d, d, &_alglib_env_state);
    ae_vector_attach_to_x(&_e, e, &_alglib_env_state);
    ae_matrix_attach_to_x(&_z, z, &_alglib_env_state);
    *result = smatrixtdevdr(&_d, &_e, *n, *zneeded, *a, *b, m, &_z, &_alglib_env_state);
    ae_x_set_vector(d, &_d, &_alglib_env_state);
    ae_x_set_matrix(z, &_z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smatrixtdevdi(const char **errormsg, bool8* result, x_vector* d, x_vector* e, ae_int_t* n, ae_int_t* zneeded, ae_int_t* i1, ae_int_t* i2, x_matrix* z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _d;
    ae_vector _e;
    ae_matrix _z;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_d, d, &_alglib_env_state);
    ae_vector_attach_to_x(&_e, e, &_alglib_env_state);
    ae_matrix_attach_to_x(&_z, z, &_alglib_env_state);
    *result = smatrixtdevdi(&_d, &_e, *n, *zneeded, *i1, *i2, &_z, &_alglib_env_state);
    ae_x_set_vector(d, &_d, &_alglib_env_state);
    ae_x_set_matrix(z, &_z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixevd(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* n, ae_int_t* vneeded, x_vector* wr, x_vector* wi, x_matrix* vl, x_matrix* vr)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _wr;
    ae_vector _wi;
    ae_matrix _vl;
    ae_matrix _vr;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_wr, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_wi, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_vl, 0, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_vr, 0, 0, DT_REAL, &_alglib_env_state);
    *result = rmatrixevd(&_a, *n, *vneeded, &_wr, &_wi, &_vl, &_vr, &_alglib_env_state);
    ae_x_set_vector(wr, &_wr, &_alglib_env_state);
    ae_x_set_vector(wi, &_wi, &_alglib_env_state);
    ae_x_set_matrix(vl, &_vl, &_alglib_env_state);
    ae_x_set_matrix(vr, &_vr, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixrndorthogonal(const char **errormsg, ae_int_t* n, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_a, 0, 0, DT_REAL, &_alglib_env_state);
    rmatrixrndorthogonal(*n, &_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixrndcond(const char **errormsg, ae_int_t* n, double* c, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_a, 0, 0, DT_REAL, &_alglib_env_state);
    rmatrixrndcond(*n, *c, &_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixrndorthogonal(const char **errormsg, ae_int_t* n, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_a, 0, 0, DT_COMPLEX, &_alglib_env_state);
    cmatrixrndorthogonal(*n, &_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixrndcond(const char **errormsg, ae_int_t* n, double* c, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_a, 0, 0, DT_COMPLEX, &_alglib_env_state);
    cmatrixrndcond(*n, *c, &_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smatrixrndcond(const char **errormsg, ae_int_t* n, double* c, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_a, 0, 0, DT_REAL, &_alglib_env_state);
    smatrixrndcond(*n, *c, &_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixrndcond(const char **errormsg, ae_int_t* n, double* c, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_a, 0, 0, DT_REAL, &_alglib_env_state);
    spdmatrixrndcond(*n, *c, &_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hmatrixrndcond(const char **errormsg, ae_int_t* n, double* c, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_a, 0, 0, DT_COMPLEX, &_alglib_env_state);
    hmatrixrndcond(*n, *c, &_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hpdmatrixrndcond(const char **errormsg, ae_int_t* n, double* c, x_matrix* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_a, 0, 0, DT_COMPLEX, &_alglib_env_state);
    hpdmatrixrndcond(*n, *c, &_a, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixrndorthogonalfromtheright(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    rmatrixrndorthogonalfromtheright(&_a, *m, *n, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixrndorthogonalfromtheleft(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    rmatrixrndorthogonalfromtheleft(&_a, *m, *n, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixrndorthogonalfromtheright(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    cmatrixrndorthogonalfromtheright(&_a, *m, *n, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixrndorthogonalfromtheleft(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    cmatrixrndorthogonalfromtheleft(&_a, *m, *n, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smatrixrndmultiply(const char **errormsg, x_matrix* a, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    smatrixrndmultiply(&_a, *n, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hmatrixrndmultiply(const char **errormsg, x_matrix* a, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    hmatrixrndmultiply(&_a, *n, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED sparsematrix obj;
} x_sparsematrix;
x_sparsematrix* x_obj_alloc_sparsematrix(ae_state *_state)
{
    x_sparsematrix *result;
    result = ae_malloc(sizeof(x_sparsematrix), _state);
    _sparsematrix_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_sparsematrix* x_obj_copy_sparsematrix(x_sparsematrix *src)
{
    x_sparsematrix *result;
    result = ae_malloc(sizeof(x_sparsematrix), NULL);
    _sparsematrix_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_sparsematrix(x_sparsematrix *obj)
{
    if( obj==NULL )
        return;
    _sparsematrix_clear(&obj->obj);
    ae_free(obj);
    return;
}
typedef ALIGNED struct
{
    ALIGNED sparsebuffers obj;
} x_sparsebuffers;
x_sparsebuffers* x_obj_alloc_sparsebuffers(ae_state *_state)
{
    x_sparsebuffers *result;
    result = ae_malloc(sizeof(x_sparsebuffers), _state);
    _sparsebuffers_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_sparsebuffers* x_obj_copy_sparsebuffers(x_sparsebuffers *src)
{
    x_sparsebuffers *result;
    result = ae_malloc(sizeof(x_sparsebuffers), NULL);
    _sparsebuffers_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_sparsebuffers(x_sparsebuffers *obj)
{
    if( obj==NULL )
        return;
    _sparsebuffers_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT ae_int32_t alglib_sparsecreate(const char **errormsg, ae_int_t* m, ae_int_t* n, ae_int_t* k, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *s = x_obj_alloc_sparsematrix(&_alglib_env_state);
    sparsecreate(*m, *n, *k, &(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecreatebuf(const char **errormsg, ae_int_t* m, ae_int_t* n, ae_int_t* k, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparsecreatebuf(*m, *n, *k, &(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecreatecrs(const char **errormsg, ae_int_t* m, ae_int_t* n, x_vector* ner, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _ner;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_ner, ner, &_alglib_env_state);
    *s = x_obj_alloc_sparsematrix(&_alglib_env_state);
    sparsecreatecrs(*m, *n, &_ner, &(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecreatecrsbuf(const char **errormsg, ae_int_t* m, ae_int_t* n, x_vector* ner, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _ner;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_ner, ner, &_alglib_env_state);
    sparsecreatecrsbuf(*m, *n, &_ner, &(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecreatesks(const char **errormsg, ae_int_t* m, ae_int_t* n, x_vector* d, x_vector* u, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _d;
    ae_vector _u;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_d, d, &_alglib_env_state);
    ae_vector_attach_to_x(&_u, u, &_alglib_env_state);
    *s = x_obj_alloc_sparsematrix(&_alglib_env_state);
    sparsecreatesks(*m, *n, &_d, &_u, &(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecreatesksbuf(const char **errormsg, ae_int_t* m, ae_int_t* n, x_vector* d, x_vector* u, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _d;
    ae_vector _u;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_d, d, &_alglib_env_state);
    ae_vector_attach_to_x(&_u, u, &_alglib_env_state);
    sparsecreatesksbuf(*m, *n, &_d, &_u, &(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecopy(const char **errormsg, x_sparsematrix** s0, x_sparsematrix** s1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *s1 = x_obj_alloc_sparsematrix(&_alglib_env_state);
    sparsecopy(&(*s0)->obj, &(*s1)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecopybuf(const char **errormsg, x_sparsematrix** s0, x_sparsematrix** s1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparsecopybuf(&(*s0)->obj, &(*s1)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparseswap(const char **errormsg, x_sparsematrix** s0, x_sparsematrix** s1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparseswap(&(*s0)->obj, &(*s1)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparseadd(const char **errormsg, x_sparsematrix** s, ae_int_t* i, ae_int_t* j, double* v)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparseadd(&(*s)->obj, *i, *j, *v, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparseset(const char **errormsg, x_sparsematrix** s, ae_int_t* i, ae_int_t* j, double* v)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparseset(&(*s)->obj, *i, *j, *v, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparseget(const char **errormsg, double* result, x_sparsematrix** s, ae_int_t* i, ae_int_t* j)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = sparseget(&(*s)->obj, *i, *j, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsegetdiagonal(const char **errormsg, double* result, x_sparsematrix** s, ae_int_t* i)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = sparsegetdiagonal(&(*s)->obj, *i, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsemv(const char **errormsg, x_sparsematrix** s, x_vector* x, x_vector* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    sparsemv(&(*s)->obj, &_x, &_y, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsemtv(const char **errormsg, x_sparsematrix** s, x_vector* x, x_vector* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    sparsemtv(&(*s)->obj, &_x, &_y, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsemv2(const char **errormsg, x_sparsematrix** s, x_vector* x, x_vector* y0, x_vector* y1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y0;
    ae_vector _y1;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y0, y0, &_alglib_env_state);
    ae_vector_attach_to_x(&_y1, y1, &_alglib_env_state);
    sparsemv2(&(*s)->obj, &_x, &_y0, &_y1, &_alglib_env_state);
    ae_x_set_vector(y0, &_y0, &_alglib_env_state);
    ae_x_set_vector(y1, &_y1, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsesmv(const char **errormsg, x_sparsematrix** s, bool8* isupper, x_vector* x, x_vector* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    sparsesmv(&(*s)->obj, *isupper, &_x, &_y, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsevsmv(const char **errormsg, double* result, x_sparsematrix** s, bool8* isupper, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *result = sparsevsmv(&(*s)->obj, *isupper, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsemm(const char **errormsg, x_sparsematrix** s, x_matrix* a, ae_int_t* k, x_matrix* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    sparsemm(&(*s)->obj, &_a, *k, &_b, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsemtm(const char **errormsg, x_sparsematrix** s, x_matrix* a, ae_int_t* k, x_matrix* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    sparsemtm(&(*s)->obj, &_a, *k, &_b, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsemm2(const char **errormsg, x_sparsematrix** s, x_matrix* a, ae_int_t* k, x_matrix* b0, x_matrix* b1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b0;
    ae_matrix _b1;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b0, b0, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b1, b1, &_alglib_env_state);
    sparsemm2(&(*s)->obj, &_a, *k, &_b0, &_b1, &_alglib_env_state);
    ae_x_set_matrix(b0, &_b0, &_alglib_env_state);
    ae_x_set_matrix(b1, &_b1, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsesmm(const char **errormsg, x_sparsematrix** s, bool8* isupper, x_matrix* a, ae_int_t* k, x_matrix* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    sparsesmm(&(*s)->obj, *isupper, &_a, *k, &_b, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsetrmv(const char **errormsg, x_sparsematrix** s, bool8* isupper, bool8* isunit, ae_int_t* optype, x_vector* x, x_vector* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    sparsetrmv(&(*s)->obj, *isupper, *isunit, *optype, &_x, &_y, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsetrsv(const char **errormsg, x_sparsematrix** s, bool8* isupper, bool8* isunit, ae_int_t* optype, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    sparsetrsv(&(*s)->obj, *isupper, *isunit, *optype, &_x, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparseresizematrix(const char **errormsg, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparseresizematrix(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparseenumerate(const char **errormsg, bool8* result, x_sparsematrix** s, ae_int_t* t0, ae_int_t* t1, ae_int_t* i, ae_int_t* j, double* v)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = sparseenumerate(&(*s)->obj, t0, t1, i, j, v, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparserewriteexisting(const char **errormsg, bool8* result, x_sparsematrix** s, ae_int_t* i, ae_int_t* j, double* v)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = sparserewriteexisting(&(*s)->obj, *i, *j, *v, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsegetrow(const char **errormsg, x_sparsematrix** s, ae_int_t* i, x_vector* irow)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _irow;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_irow, irow, &_alglib_env_state);
    sparsegetrow(&(*s)->obj, *i, &_irow, &_alglib_env_state);
    ae_x_set_vector(irow, &_irow, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsegetcompressedrow(const char **errormsg, x_sparsematrix** s, ae_int_t* i, x_vector* colidx, x_vector* vals, ae_int_t* nzcnt)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _colidx;
    ae_vector _vals;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_colidx, colidx, &_alglib_env_state);
    ae_vector_attach_to_x(&_vals, vals, &_alglib_env_state);
    sparsegetcompressedrow(&(*s)->obj, *i, &_colidx, &_vals, nzcnt, &_alglib_env_state);
    ae_x_set_vector(colidx, &_colidx, &_alglib_env_state);
    ae_x_set_vector(vals, &_vals, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsetransposesks(const char **errormsg, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparsetransposesks(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparseconvertto(const char **errormsg, x_sparsematrix** s0, ae_int_t* fmt)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparseconvertto(&(*s0)->obj, *fmt, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecopytobuf(const char **errormsg, x_sparsematrix** s0, ae_int_t* fmt, x_sparsematrix** s1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparsecopytobuf(&(*s0)->obj, *fmt, &(*s1)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparseconverttohash(const char **errormsg, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparseconverttohash(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecopytohash(const char **errormsg, x_sparsematrix** s0, x_sparsematrix** s1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *s1 = x_obj_alloc_sparsematrix(&_alglib_env_state);
    sparsecopytohash(&(*s0)->obj, &(*s1)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecopytohashbuf(const char **errormsg, x_sparsematrix** s0, x_sparsematrix** s1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparsecopytohashbuf(&(*s0)->obj, &(*s1)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparseconverttocrs(const char **errormsg, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparseconverttocrs(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecopytocrs(const char **errormsg, x_sparsematrix** s0, x_sparsematrix** s1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *s1 = x_obj_alloc_sparsematrix(&_alglib_env_state);
    sparsecopytocrs(&(*s0)->obj, &(*s1)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecopytocrsbuf(const char **errormsg, x_sparsematrix** s0, x_sparsematrix** s1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparsecopytocrsbuf(&(*s0)->obj, &(*s1)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparseconverttosks(const char **errormsg, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparseconverttosks(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecopytosks(const char **errormsg, x_sparsematrix** s0, x_sparsematrix** s1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *s1 = x_obj_alloc_sparsematrix(&_alglib_env_state);
    sparsecopytosks(&(*s0)->obj, &(*s1)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecopytosksbuf(const char **errormsg, x_sparsematrix** s0, x_sparsematrix** s1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sparsecopytosksbuf(&(*s0)->obj, &(*s1)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsegetmatrixtype(const char **errormsg, ae_int_t* result, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = sparsegetmatrixtype(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparseishash(const char **errormsg, bool8* result, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = sparseishash(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparseiscrs(const char **errormsg, bool8* result, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = sparseiscrs(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparseissks(const char **errormsg, bool8* result, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = sparseissks(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsefree(const char **errormsg, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *s = x_obj_alloc_sparsematrix(&_alglib_env_state);
    sparsefree(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsegetnrows(const char **errormsg, ae_int_t* result, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = sparsegetnrows(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsegetncols(const char **errormsg, ae_int_t* result, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = sparsegetncols(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsegetuppercount(const char **errormsg, ae_int_t* result, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = sparsegetuppercount(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsegetlowercount(const char **errormsg, ae_int_t* result, x_sparsematrix** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = sparsegetlowercount(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixlu(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* pivots)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _pivots;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_pivots, 0, DT_INT, &_alglib_env_state);
    rmatrixlu(&_a, *m, *n, &_pivots, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(pivots, &_pivots, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixlu(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* pivots)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _pivots;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_pivots, 0, DT_INT, &_alglib_env_state);
    _pexec_rmatrixlu(&_a, *m, *n, &_pivots, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(pivots, &_pivots, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixlu(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* pivots)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _pivots;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_pivots, 0, DT_INT, &_alglib_env_state);
    cmatrixlu(&_a, *m, *n, &_pivots, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(pivots, &_pivots, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixlu(const char **errormsg, x_matrix* a, ae_int_t* m, ae_int_t* n, x_vector* pivots)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _pivots;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_pivots, 0, DT_INT, &_alglib_env_state);
    _pexec_cmatrixlu(&_a, *m, *n, &_pivots, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(pivots, &_pivots, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hpdmatrixcholesky(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* n, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = hpdmatrixcholesky(&_a, *n, *isupper, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_hpdmatrixcholesky(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* n, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = _pexec_hpdmatrixcholesky(&_a, *n, *isupper, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixcholesky(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* n, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = spdmatrixcholesky(&_a, *n, *isupper, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spdmatrixcholesky(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* n, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = _pexec_spdmatrixcholesky(&_a, *n, *isupper, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixcholeskyupdateadd1(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* u)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _u;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_u, u, &_alglib_env_state);
    spdmatrixcholeskyupdateadd1(&_a, *n, *isupper, &_u, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixcholeskyupdatefix(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* fix)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _fix;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_fix, fix, &_alglib_env_state);
    spdmatrixcholeskyupdatefix(&_a, *n, *isupper, &_fix, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixcholeskyupdateadd1buf(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* u, x_vector* bufr)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _u;
    ae_vector _bufr;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_u, u, &_alglib_env_state);
    ae_vector_attach_to_x(&_bufr, bufr, &_alglib_env_state);
    spdmatrixcholeskyupdateadd1buf(&_a, *n, *isupper, &_u, &_bufr, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(bufr, &_bufr, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixcholeskyupdatefixbuf(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* fix, x_vector* bufr)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _fix;
    ae_vector _bufr;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_fix, fix, &_alglib_env_state);
    ae_vector_attach_to_x(&_bufr, bufr, &_alglib_env_state);
    spdmatrixcholeskyupdatefixbuf(&_a, *n, *isupper, &_fix, &_bufr, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_vector(bufr, &_bufr, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sparsecholeskyskyline(const char **errormsg, bool8* result, x_sparsematrix** a, ae_int_t* n, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = sparsecholeskyskyline(&(*a)->obj, *n, *isupper, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixrcond1(const char **errormsg, double* result, x_matrix* a, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = rmatrixrcond1(&_a, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixrcondinf(const char **errormsg, double* result, x_matrix* a, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = rmatrixrcondinf(&_a, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixrcond(const char **errormsg, double* result, x_matrix* a, ae_int_t* n, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = spdmatrixrcond(&_a, *n, *isupper, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixtrrcond1(const char **errormsg, double* result, x_matrix* a, ae_int_t* n, bool8* isupper, bool8* isunit)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = rmatrixtrrcond1(&_a, *n, *isupper, *isunit, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixtrrcondinf(const char **errormsg, double* result, x_matrix* a, ae_int_t* n, bool8* isupper, bool8* isunit)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = rmatrixtrrcondinf(&_a, *n, *isupper, *isunit, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hpdmatrixrcond(const char **errormsg, double* result, x_matrix* a, ae_int_t* n, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = hpdmatrixrcond(&_a, *n, *isupper, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixrcond1(const char **errormsg, double* result, x_matrix* a, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = cmatrixrcond1(&_a, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixrcondinf(const char **errormsg, double* result, x_matrix* a, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = cmatrixrcondinf(&_a, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixlurcond1(const char **errormsg, double* result, x_matrix* lua, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    *result = rmatrixlurcond1(&_lua, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixlurcondinf(const char **errormsg, double* result, x_matrix* lua, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    *result = rmatrixlurcondinf(&_lua, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixcholeskyrcond(const char **errormsg, double* result, x_matrix* a, ae_int_t* n, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = spdmatrixcholeskyrcond(&_a, *n, *isupper, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hpdmatrixcholeskyrcond(const char **errormsg, double* result, x_matrix* a, ae_int_t* n, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = hpdmatrixcholeskyrcond(&_a, *n, *isupper, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixlurcond1(const char **errormsg, double* result, x_matrix* lua, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    *result = cmatrixlurcond1(&_lua, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixlurcondinf(const char **errormsg, double* result, x_matrix* lua, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    *result = cmatrixlurcondinf(&_lua, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixtrrcond1(const char **errormsg, double* result, x_matrix* a, ae_int_t* n, bool8* isupper, bool8* isunit)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = cmatrixtrrcond1(&_a, *n, *isupper, *isunit, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixtrrcondinf(const char **errormsg, double* result, x_matrix* a, ae_int_t* n, bool8* isupper, bool8* isunit)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = cmatrixtrrcondinf(&_a, *n, *isupper, *isunit, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED double r1;
    ALIGNED double rinf;
} x_matinvreport;
void x_set_matinvreport(x_matinvreport *dst, matinvreport *src, ae_state *_state)
{
    dst->r1 = src->r1;
    dst->rinf = src->rinf;
}
void matinvreport_init_from_x(matinvreport *dst, x_matinvreport *src, ae_state *_state)
{
    dst->r1 = src->r1;
    dst->rinf = src->rinf;
}
DLLEXPORT ae_int32_t alglib_rmatrixluinverse(const char **errormsg, x_matrix* a, x_vector* pivots, ae_int_t* n, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _pivots;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_pivots, pivots, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    rmatrixluinverse(&_a, &_pivots, *n, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixluinverse(const char **errormsg, x_matrix* a, x_vector* pivots, ae_int_t* n, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _pivots;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_pivots, pivots, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    _pexec_rmatrixluinverse(&_a, &_pivots, *n, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixinverse(const char **errormsg, x_matrix* a, ae_int_t* n, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    rmatrixinverse(&_a, *n, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixinverse(const char **errormsg, x_matrix* a, ae_int_t* n, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    _pexec_rmatrixinverse(&_a, *n, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixluinverse(const char **errormsg, x_matrix* a, x_vector* pivots, ae_int_t* n, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _pivots;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_pivots, pivots, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    cmatrixluinverse(&_a, &_pivots, *n, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixluinverse(const char **errormsg, x_matrix* a, x_vector* pivots, ae_int_t* n, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _pivots;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_pivots, pivots, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    _pexec_cmatrixluinverse(&_a, &_pivots, *n, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixinverse(const char **errormsg, x_matrix* a, ae_int_t* n, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    cmatrixinverse(&_a, *n, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixinverse(const char **errormsg, x_matrix* a, ae_int_t* n, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    _pexec_cmatrixinverse(&_a, *n, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixcholeskyinverse(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    spdmatrixcholeskyinverse(&_a, *n, *isupper, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spdmatrixcholeskyinverse(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    _pexec_spdmatrixcholeskyinverse(&_a, *n, *isupper, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixinverse(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    spdmatrixinverse(&_a, *n, *isupper, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spdmatrixinverse(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    _pexec_spdmatrixinverse(&_a, *n, *isupper, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hpdmatrixcholeskyinverse(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    hpdmatrixcholeskyinverse(&_a, *n, *isupper, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_hpdmatrixcholeskyinverse(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    _pexec_hpdmatrixcholeskyinverse(&_a, *n, *isupper, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hpdmatrixinverse(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    hpdmatrixinverse(&_a, *n, *isupper, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_hpdmatrixinverse(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    _pexec_hpdmatrixinverse(&_a, *n, *isupper, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixtrinverse(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, bool8* isunit, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    rmatrixtrinverse(&_a, *n, *isupper, *isunit, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixtrinverse(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, bool8* isunit, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    _pexec_rmatrixtrinverse(&_a, *n, *isupper, *isunit, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixtrinverse(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, bool8* isunit, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    cmatrixtrinverse(&_a, *n, *isupper, *isunit, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixtrinverse(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, bool8* isunit, ae_int_t* info, x_matinvreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    matinvreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    _matinvreport_init(&_rep, &_alglib_env_state);
    _pexec_cmatrixtrinverse(&_a, *n, *isupper, *isunit, info, &_rep, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    x_set_matinvreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_fisherlda(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nvars, ae_int_t* nclasses, ae_int_t* info, x_vector* w)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _w;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    fisherlda(&_xy, *npoints, *nvars, *nclasses, info, &_w, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_fisherldan(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nvars, ae_int_t* nclasses, ae_int_t* info, x_matrix* w)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_matrix _w;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_matrix_init(&_w, 0, 0, DT_REAL, &_alglib_env_state);
    fisherldan(&_xy, *npoints, *nvars, *nclasses, info, &_w, &_alglib_env_state);
    ae_x_set_matrix(w, &_w, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_fisherldan(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nvars, ae_int_t* nclasses, ae_int_t* info, x_matrix* w)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_matrix _w;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_matrix_init(&_w, 0, 0, DT_REAL, &_alglib_env_state);
    _pexec_fisherldan(&_xy, *npoints, *nvars, *nclasses, info, &_w, &_alglib_env_state);
    ae_x_set_matrix(w, &_w, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED double relclserror;
    ALIGNED double avgce;
    ALIGNED double rmserror;
    ALIGNED double avgerror;
    ALIGNED double avgrelerror;
} x_modelerrors;
void x_set_modelerrors(x_modelerrors *dst, modelerrors *src, ae_state *_state)
{
    dst->relclserror = src->relclserror;
    dst->avgce = src->avgce;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
}
void modelerrors_init_from_x(modelerrors *dst, x_modelerrors *src, ae_state *_state)
{
    dst->relclserror = src->relclserror;
    dst->avgce = src->avgce;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
}
typedef ALIGNED struct
{
    ALIGNED multilayerperceptron obj;
} x_multilayerperceptron;
x_multilayerperceptron* x_obj_alloc_multilayerperceptron(ae_state *_state)
{
    x_multilayerperceptron *result;
    result = ae_malloc(sizeof(x_multilayerperceptron), _state);
    _multilayerperceptron_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_multilayerperceptron* x_obj_copy_multilayerperceptron(x_multilayerperceptron *src)
{
    x_multilayerperceptron *result;
    result = ae_malloc(sizeof(x_multilayerperceptron), NULL);
    _multilayerperceptron_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_multilayerperceptron(x_multilayerperceptron *obj)
{
    if( obj==NULL )
        return;
    _multilayerperceptron_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT ae_int32_t alglib_mlpserialize(const char **errormsg, x_multilayerperceptron **obj, char **s_out)
{
    ae_state state;
    ae_serializer serializer;
    jmp_buf _break_jump;
    ae_frame _frame_block;
    
    ae_state_init(&state);
    ae_serializer_init(&serializer);
    if( setjmp(_break_jump) )
    {
        if( state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&state, &_break_jump);
    ae_frame_make(&state, &_frame_block);
    
    ae_serializer_alloc_start(&serializer);
    mlpalloc(&serializer, &((*obj)->obj), &state);
    x_malloc((void**)(s_out), ae_serializer_get_alloc_size(&serializer)+1);
    ae_serializer_sstart_str(&serializer, *s_out);
    mlpserialize(&serializer, &((*obj)->obj), &state);
    ae_serializer_stop(&serializer);
    
    ae_serializer_clear(&serializer);
    ae_state_clear(&state);
    return X_OK;
}    
    
DLLEXPORT ae_int32_t alglib_mlpunserialize(const char **errormsg, char **s_in, x_multilayerperceptron **obj)
{
    ae_state state;
    ae_serializer serializer;
    jmp_buf _break_jump;
    ae_frame _frame_block;
    
    ae_state_init(&state);
    ae_serializer_init(&serializer);
    if( setjmp(_break_jump) )
    {
        if( state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&state, &_break_jump);
    ae_frame_make(&state, &_frame_block);
    
    *obj = x_obj_alloc_multilayerperceptron(&state);
    ae_serializer_ustart_str(&serializer, *s_in);
    mlpunserialize(&serializer, &((*obj)->obj), &state);
    ae_serializer_stop(&serializer);
    
    ae_serializer_clear(&serializer);
    ae_state_clear(&state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcreate0(const char **errormsg, ae_int_t* nin, ae_int_t* nout, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *network = x_obj_alloc_multilayerperceptron(&_alglib_env_state);
    mlpcreate0(*nin, *nout, &(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcreate1(const char **errormsg, ae_int_t* nin, ae_int_t* nhid, ae_int_t* nout, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *network = x_obj_alloc_multilayerperceptron(&_alglib_env_state);
    mlpcreate1(*nin, *nhid, *nout, &(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcreate2(const char **errormsg, ae_int_t* nin, ae_int_t* nhid1, ae_int_t* nhid2, ae_int_t* nout, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *network = x_obj_alloc_multilayerperceptron(&_alglib_env_state);
    mlpcreate2(*nin, *nhid1, *nhid2, *nout, &(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcreateb0(const char **errormsg, ae_int_t* nin, ae_int_t* nout, double* b, double* d, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *network = x_obj_alloc_multilayerperceptron(&_alglib_env_state);
    mlpcreateb0(*nin, *nout, *b, *d, &(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcreateb1(const char **errormsg, ae_int_t* nin, ae_int_t* nhid, ae_int_t* nout, double* b, double* d, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *network = x_obj_alloc_multilayerperceptron(&_alglib_env_state);
    mlpcreateb1(*nin, *nhid, *nout, *b, *d, &(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcreateb2(const char **errormsg, ae_int_t* nin, ae_int_t* nhid1, ae_int_t* nhid2, ae_int_t* nout, double* b, double* d, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *network = x_obj_alloc_multilayerperceptron(&_alglib_env_state);
    mlpcreateb2(*nin, *nhid1, *nhid2, *nout, *b, *d, &(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcreater0(const char **errormsg, ae_int_t* nin, ae_int_t* nout, double* a, double* b, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *network = x_obj_alloc_multilayerperceptron(&_alglib_env_state);
    mlpcreater0(*nin, *nout, *a, *b, &(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcreater1(const char **errormsg, ae_int_t* nin, ae_int_t* nhid, ae_int_t* nout, double* a, double* b, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *network = x_obj_alloc_multilayerperceptron(&_alglib_env_state);
    mlpcreater1(*nin, *nhid, *nout, *a, *b, &(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcreater2(const char **errormsg, ae_int_t* nin, ae_int_t* nhid1, ae_int_t* nhid2, ae_int_t* nout, double* a, double* b, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *network = x_obj_alloc_multilayerperceptron(&_alglib_env_state);
    mlpcreater2(*nin, *nhid1, *nhid2, *nout, *a, *b, &(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcreatec0(const char **errormsg, ae_int_t* nin, ae_int_t* nout, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *network = x_obj_alloc_multilayerperceptron(&_alglib_env_state);
    mlpcreatec0(*nin, *nout, &(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcreatec1(const char **errormsg, ae_int_t* nin, ae_int_t* nhid, ae_int_t* nout, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *network = x_obj_alloc_multilayerperceptron(&_alglib_env_state);
    mlpcreatec1(*nin, *nhid, *nout, &(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcreatec2(const char **errormsg, ae_int_t* nin, ae_int_t* nhid1, ae_int_t* nhid2, ae_int_t* nout, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *network = x_obj_alloc_multilayerperceptron(&_alglib_env_state);
    mlpcreatec2(*nin, *nhid1, *nhid2, *nout, &(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcopy(const char **errormsg, x_multilayerperceptron** network1, x_multilayerperceptron** network2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *network2 = x_obj_alloc_multilayerperceptron(&_alglib_env_state);
    mlpcopy(&(*network1)->obj, &(*network2)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcopytunableparameters(const char **errormsg, x_multilayerperceptron** network1, x_multilayerperceptron** network2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpcopytunableparameters(&(*network1)->obj, &(*network2)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlprandomize(const char **errormsg, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlprandomize(&(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlprandomizefull(const char **errormsg, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlprandomizefull(&(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpinitpreprocessor(const char **errormsg, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* ssize)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    mlpinitpreprocessor(&(*network)->obj, &_xy, *ssize, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpproperties(const char **errormsg, x_multilayerperceptron** network, ae_int_t* nin, ae_int_t* nout, ae_int_t* wcount)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpproperties(&(*network)->obj, nin, nout, wcount, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgetinputscount(const char **errormsg, ae_int_t* result, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlpgetinputscount(&(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgetoutputscount(const char **errormsg, ae_int_t* result, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlpgetoutputscount(&(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgetweightscount(const char **errormsg, ae_int_t* result, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlpgetweightscount(&(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpissoftmax(const char **errormsg, bool8* result, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlpissoftmax(&(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgetlayerscount(const char **errormsg, ae_int_t* result, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlpgetlayerscount(&(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgetlayersize(const char **errormsg, ae_int_t* result, x_multilayerperceptron** network, ae_int_t* k)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlpgetlayersize(&(*network)->obj, *k, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgetinputscaling(const char **errormsg, x_multilayerperceptron** network, ae_int_t* i, double* mean, double* sigma)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpgetinputscaling(&(*network)->obj, *i, mean, sigma, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgetoutputscaling(const char **errormsg, x_multilayerperceptron** network, ae_int_t* i, double* mean, double* sigma)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpgetoutputscaling(&(*network)->obj, *i, mean, sigma, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgetneuroninfo(const char **errormsg, x_multilayerperceptron** network, ae_int_t* k, ae_int_t* i, ae_int_t* fkind, double* threshold)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpgetneuroninfo(&(*network)->obj, *k, *i, fkind, threshold, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgetweight(const char **errormsg, double* result, x_multilayerperceptron** network, ae_int_t* k0, ae_int_t* i0, ae_int_t* k1, ae_int_t* i1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlpgetweight(&(*network)->obj, *k0, *i0, *k1, *i1, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpsetinputscaling(const char **errormsg, x_multilayerperceptron** network, ae_int_t* i, double* mean, double* sigma)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpsetinputscaling(&(*network)->obj, *i, *mean, *sigma, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpsetoutputscaling(const char **errormsg, x_multilayerperceptron** network, ae_int_t* i, double* mean, double* sigma)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpsetoutputscaling(&(*network)->obj, *i, *mean, *sigma, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpsetneuroninfo(const char **errormsg, x_multilayerperceptron** network, ae_int_t* k, ae_int_t* i, ae_int_t* fkind, double* threshold)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpsetneuroninfo(&(*network)->obj, *k, *i, *fkind, *threshold, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpsetweight(const char **errormsg, x_multilayerperceptron** network, ae_int_t* k0, ae_int_t* i0, ae_int_t* k1, ae_int_t* i1, double* w)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpsetweight(&(*network)->obj, *k0, *i0, *k1, *i1, *w, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpactivationfunction(const char **errormsg, double* net, ae_int_t* k, double* f, double* df, double* d2f)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpactivationfunction(*net, *k, f, df, d2f, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpprocess(const char **errormsg, x_multilayerperceptron** network, x_vector* x, x_vector* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    mlpprocess(&(*network)->obj, &_x, &_y, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpprocessi(const char **errormsg, x_multilayerperceptron** network, x_vector* x, x_vector* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_init(&_y, 0, DT_REAL, &_alglib_env_state);
    mlpprocessi(&(*network)->obj, &_x, &_y, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlperror(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mlperror(&(*network)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlperror(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = _pexec_mlperror(&(*network)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlperrorsparse(const char **errormsg, double* result, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlperrorsparse(&(*network)->obj, &(*xy)->obj, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlperrorsparse(const char **errormsg, double* result, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = _pexec_mlperrorsparse(&(*network)->obj, &(*xy)->obj, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlperrorn(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* ssize)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mlperrorn(&(*network)->obj, &_xy, *ssize, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpclserror(const char **errormsg, ae_int_t* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mlpclserror(&(*network)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpclserror(const char **errormsg, ae_int_t* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = _pexec_mlpclserror(&(*network)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlprelclserror(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mlprelclserror(&(*network)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlprelclserror(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = _pexec_mlprelclserror(&(*network)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlprelclserrorsparse(const char **errormsg, double* result, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlprelclserrorsparse(&(*network)->obj, &(*xy)->obj, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlprelclserrorsparse(const char **errormsg, double* result, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = _pexec_mlprelclserrorsparse(&(*network)->obj, &(*xy)->obj, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpavgce(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mlpavgce(&(*network)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpavgce(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = _pexec_mlpavgce(&(*network)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpavgcesparse(const char **errormsg, double* result, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlpavgcesparse(&(*network)->obj, &(*xy)->obj, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpavgcesparse(const char **errormsg, double* result, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = _pexec_mlpavgcesparse(&(*network)->obj, &(*xy)->obj, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlprmserror(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mlprmserror(&(*network)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlprmserror(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = _pexec_mlprmserror(&(*network)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlprmserrorsparse(const char **errormsg, double* result, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlprmserrorsparse(&(*network)->obj, &(*xy)->obj, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlprmserrorsparse(const char **errormsg, double* result, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = _pexec_mlprmserrorsparse(&(*network)->obj, &(*xy)->obj, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpavgerror(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mlpavgerror(&(*network)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpavgerror(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = _pexec_mlpavgerror(&(*network)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpavgerrorsparse(const char **errormsg, double* result, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlpavgerrorsparse(&(*network)->obj, &(*xy)->obj, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpavgerrorsparse(const char **errormsg, double* result, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = _pexec_mlpavgerrorsparse(&(*network)->obj, &(*xy)->obj, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpavgrelerror(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mlpavgrelerror(&(*network)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpavgrelerror(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = _pexec_mlpavgrelerror(&(*network)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpavgrelerrorsparse(const char **errormsg, double* result, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlpavgrelerrorsparse(&(*network)->obj, &(*xy)->obj, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpavgrelerrorsparse(const char **errormsg, double* result, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = _pexec_mlpavgrelerrorsparse(&(*network)->obj, &(*xy)->obj, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgrad(const char **errormsg, x_multilayerperceptron** network, x_vector* x, x_vector* desiredy, double* e, x_vector* grad)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _desiredy;
    ae_vector _grad;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_desiredy, desiredy, &_alglib_env_state);
    ae_vector_attach_to_x(&_grad, grad, &_alglib_env_state);
    mlpgrad(&(*network)->obj, &_x, &_desiredy, e, &_grad, &_alglib_env_state);
    ae_x_set_vector(grad, &_grad, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgradn(const char **errormsg, x_multilayerperceptron** network, x_vector* x, x_vector* desiredy, double* e, x_vector* grad)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _desiredy;
    ae_vector _grad;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_desiredy, desiredy, &_alglib_env_state);
    ae_vector_attach_to_x(&_grad, grad, &_alglib_env_state);
    mlpgradn(&(*network)->obj, &_x, &_desiredy, e, &_grad, &_alglib_env_state);
    ae_x_set_vector(grad, &_grad, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgradbatch(const char **errormsg, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* ssize, double* e, x_vector* grad)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _grad;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_attach_to_x(&_grad, grad, &_alglib_env_state);
    mlpgradbatch(&(*network)->obj, &_xy, *ssize, e, &_grad, &_alglib_env_state);
    ae_x_set_vector(grad, &_grad, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpgradbatch(const char **errormsg, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* ssize, double* e, x_vector* grad)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _grad;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_attach_to_x(&_grad, grad, &_alglib_env_state);
    _pexec_mlpgradbatch(&(*network)->obj, &_xy, *ssize, e, &_grad, &_alglib_env_state);
    ae_x_set_vector(grad, &_grad, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgradbatchsparse(const char **errormsg, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* ssize, double* e, x_vector* grad)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _grad;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_grad, grad, &_alglib_env_state);
    mlpgradbatchsparse(&(*network)->obj, &(*xy)->obj, *ssize, e, &_grad, &_alglib_env_state);
    ae_x_set_vector(grad, &_grad, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpgradbatchsparse(const char **errormsg, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* ssize, double* e, x_vector* grad)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _grad;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_grad, grad, &_alglib_env_state);
    _pexec_mlpgradbatchsparse(&(*network)->obj, &(*xy)->obj, *ssize, e, &_grad, &_alglib_env_state);
    ae_x_set_vector(grad, &_grad, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgradbatchsubset(const char **errormsg, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* setsize, x_vector* idx, ae_int_t* subsetsize, double* e, x_vector* grad)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _idx;
    ae_vector _grad;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_attach_to_x(&_idx, idx, &_alglib_env_state);
    ae_vector_attach_to_x(&_grad, grad, &_alglib_env_state);
    mlpgradbatchsubset(&(*network)->obj, &_xy, *setsize, &_idx, *subsetsize, e, &_grad, &_alglib_env_state);
    ae_x_set_vector(grad, &_grad, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpgradbatchsubset(const char **errormsg, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* setsize, x_vector* idx, ae_int_t* subsetsize, double* e, x_vector* grad)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _idx;
    ae_vector _grad;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_attach_to_x(&_idx, idx, &_alglib_env_state);
    ae_vector_attach_to_x(&_grad, grad, &_alglib_env_state);
    _pexec_mlpgradbatchsubset(&(*network)->obj, &_xy, *setsize, &_idx, *subsetsize, e, &_grad, &_alglib_env_state);
    ae_x_set_vector(grad, &_grad, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgradbatchsparsesubset(const char **errormsg, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* setsize, x_vector* idx, ae_int_t* subsetsize, double* e, x_vector* grad)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _idx;
    ae_vector _grad;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_idx, idx, &_alglib_env_state);
    ae_vector_attach_to_x(&_grad, grad, &_alglib_env_state);
    mlpgradbatchsparsesubset(&(*network)->obj, &(*xy)->obj, *setsize, &_idx, *subsetsize, e, &_grad, &_alglib_env_state);
    ae_x_set_vector(grad, &_grad, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpgradbatchsparsesubset(const char **errormsg, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* setsize, x_vector* idx, ae_int_t* subsetsize, double* e, x_vector* grad)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _idx;
    ae_vector _grad;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_idx, idx, &_alglib_env_state);
    ae_vector_attach_to_x(&_grad, grad, &_alglib_env_state);
    _pexec_mlpgradbatchsparsesubset(&(*network)->obj, &(*xy)->obj, *setsize, &_idx, *subsetsize, e, &_grad, &_alglib_env_state);
    ae_x_set_vector(grad, &_grad, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpgradnbatch(const char **errormsg, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* ssize, double* e, x_vector* grad)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _grad;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_attach_to_x(&_grad, grad, &_alglib_env_state);
    mlpgradnbatch(&(*network)->obj, &_xy, *ssize, e, &_grad, &_alglib_env_state);
    ae_x_set_vector(grad, &_grad, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlphessiannbatch(const char **errormsg, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* ssize, double* e, x_vector* grad, x_matrix* h)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _grad;
    ae_matrix _h;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_attach_to_x(&_grad, grad, &_alglib_env_state);
    ae_matrix_attach_to_x(&_h, h, &_alglib_env_state);
    mlphessiannbatch(&(*network)->obj, &_xy, *ssize, e, &_grad, &_h, &_alglib_env_state);
    ae_x_set_vector(grad, &_grad, &_alglib_env_state);
    ae_x_set_matrix(h, &_h, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlphessianbatch(const char **errormsg, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* ssize, double* e, x_vector* grad, x_matrix* h)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _grad;
    ae_matrix _h;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_attach_to_x(&_grad, grad, &_alglib_env_state);
    ae_matrix_attach_to_x(&_h, h, &_alglib_env_state);
    mlphessianbatch(&(*network)->obj, &_xy, *ssize, e, &_grad, &_h, &_alglib_env_state);
    ae_x_set_vector(grad, &_grad, &_alglib_env_state);
    ae_x_set_matrix(h, &_h, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpallerrorssubset(const char **errormsg, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* setsize, x_vector* subset, ae_int_t* subsetsize, x_modelerrors* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _subset;
    modelerrors _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_attach_to_x(&_subset, subset, &_alglib_env_state);
    _modelerrors_init(&_rep, &_alglib_env_state);
    mlpallerrorssubset(&(*network)->obj, &_xy, *setsize, &_subset, *subsetsize, &_rep, &_alglib_env_state);
    x_set_modelerrors(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpallerrorssubset(const char **errormsg, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* setsize, x_vector* subset, ae_int_t* subsetsize, x_modelerrors* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _subset;
    modelerrors _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_attach_to_x(&_subset, subset, &_alglib_env_state);
    _modelerrors_init(&_rep, &_alglib_env_state);
    _pexec_mlpallerrorssubset(&(*network)->obj, &_xy, *setsize, &_subset, *subsetsize, &_rep, &_alglib_env_state);
    x_set_modelerrors(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpallerrorssparsesubset(const char **errormsg, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* setsize, x_vector* subset, ae_int_t* subsetsize, x_modelerrors* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _subset;
    modelerrors _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_subset, subset, &_alglib_env_state);
    _modelerrors_init(&_rep, &_alglib_env_state);
    mlpallerrorssparsesubset(&(*network)->obj, &(*xy)->obj, *setsize, &_subset, *subsetsize, &_rep, &_alglib_env_state);
    x_set_modelerrors(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpallerrorssparsesubset(const char **errormsg, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* setsize, x_vector* subset, ae_int_t* subsetsize, x_modelerrors* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _subset;
    modelerrors _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_subset, subset, &_alglib_env_state);
    _modelerrors_init(&_rep, &_alglib_env_state);
    _pexec_mlpallerrorssparsesubset(&(*network)->obj, &(*xy)->obj, *setsize, &_subset, *subsetsize, &_rep, &_alglib_env_state);
    x_set_modelerrors(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlperrorsubset(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* setsize, x_vector* subset, ae_int_t* subsetsize)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _subset;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_attach_to_x(&_subset, subset, &_alglib_env_state);
    *result = mlperrorsubset(&(*network)->obj, &_xy, *setsize, &_subset, *subsetsize, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlperrorsubset(const char **errormsg, double* result, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* setsize, x_vector* subset, ae_int_t* subsetsize)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_vector _subset;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    ae_vector_attach_to_x(&_subset, subset, &_alglib_env_state);
    *result = _pexec_mlperrorsubset(&(*network)->obj, &_xy, *setsize, &_subset, *subsetsize, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlperrorsparsesubset(const char **errormsg, double* result, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* setsize, x_vector* subset, ae_int_t* subsetsize)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _subset;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_subset, subset, &_alglib_env_state);
    *result = mlperrorsparsesubset(&(*network)->obj, &(*xy)->obj, *setsize, &_subset, *subsetsize, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlperrorsparsesubset(const char **errormsg, double* result, x_multilayerperceptron** network, x_sparsematrix** xy, ae_int_t* setsize, x_vector* subset, ae_int_t* subsetsize)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _subset;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_subset, subset, &_alglib_env_state);
    *result = _pexec_mlperrorsparsesubset(&(*network)->obj, &(*xy)->obj, *setsize, &_subset, *subsetsize, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED double r1;
    ALIGNED double rinf;
} x_densesolverreport;
void x_set_densesolverreport(x_densesolverreport *dst, densesolverreport *src, ae_state *_state)
{
    dst->r1 = src->r1;
    dst->rinf = src->rinf;
}
void densesolverreport_init_from_x(densesolverreport *dst, x_densesolverreport *src, ae_state *_state)
{
    dst->r1 = src->r1;
    dst->rinf = src->rinf;
}
typedef ALIGNED struct
{
    ALIGNED double r2;
    ALIGNED x_matrix cx;
    ALIGNED ae_int_t n;
    ALIGNED ae_int_t k;
} x_densesolverlsreport;
void x_set_densesolverlsreport(x_densesolverlsreport *dst, densesolverlsreport *src, ae_state *_state)
{
    dst->r2 = src->r2;
    ae_x_set_matrix(&dst->cx, &src->cx, _state);
    dst->n = src->n;
    dst->k = src->k;
}
void densesolverlsreport_init_from_x(densesolverlsreport *dst, x_densesolverlsreport *src, ae_state *_state)
{
    dst->r2 = src->r2;
    ae_matrix_init_from_x(&dst->cx, &src->cx, _state);
    dst->n = src->n;
    dst->k = src->k;
}
DLLEXPORT ae_int32_t alglib_rmatrixsolve(const char **errormsg, x_matrix* a, ae_int_t* n, x_vector* b, ae_int_t* info, x_densesolverreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    densesolverreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    rmatrixsolve(&_a, *n, &_b, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixsolve(const char **errormsg, x_matrix* a, ae_int_t* n, x_vector* b, ae_int_t* info, x_densesolverreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    densesolverreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    _pexec_rmatrixsolve(&_a, *n, &_b, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixsolvefast(const char **errormsg, x_matrix* a, ae_int_t* n, x_vector* b, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    rmatrixsolvefast(&_a, *n, &_b, info, &_alglib_env_state);
    ae_x_set_vector(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixsolvefast(const char **errormsg, x_matrix* a, ae_int_t* n, x_vector* b, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _pexec_rmatrixsolvefast(&_a, *n, &_b, info, &_alglib_env_state);
    ae_x_set_vector(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixsolvem(const char **errormsg, x_matrix* a, ae_int_t* n, x_matrix* b, ae_int_t* m, bool8* rfs, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_REAL, &_alglib_env_state);
    rmatrixsolvem(&_a, *n, &_b, *m, *rfs, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixsolvem(const char **errormsg, x_matrix* a, ae_int_t* n, x_matrix* b, ae_int_t* m, bool8* rfs, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_REAL, &_alglib_env_state);
    _pexec_rmatrixsolvem(&_a, *n, &_b, *m, *rfs, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixsolvemfast(const char **errormsg, x_matrix* a, ae_int_t* n, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    rmatrixsolvemfast(&_a, *n, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixsolvemfast(const char **errormsg, x_matrix* a, ae_int_t* n, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _pexec_rmatrixsolvemfast(&_a, *n, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixlusolve(const char **errormsg, x_matrix* lua, x_vector* p, ae_int_t* n, x_vector* b, ae_int_t* info, x_densesolverreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_vector _p;
    ae_vector _b;
    densesolverreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    rmatrixlusolve(&_lua, &_p, *n, &_b, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixlusolvefast(const char **errormsg, x_matrix* lua, x_vector* p, ae_int_t* n, x_vector* b, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_vector _p;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    rmatrixlusolvefast(&_lua, &_p, *n, &_b, info, &_alglib_env_state);
    ae_x_set_vector(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixlusolvem(const char **errormsg, x_matrix* lua, x_vector* p, ae_int_t* n, x_matrix* b, ae_int_t* m, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_vector _p;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_REAL, &_alglib_env_state);
    rmatrixlusolvem(&_lua, &_p, *n, &_b, *m, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixlusolvem(const char **errormsg, x_matrix* lua, x_vector* p, ae_int_t* n, x_matrix* b, ae_int_t* m, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_vector _p;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_REAL, &_alglib_env_state);
    _pexec_rmatrixlusolvem(&_lua, &_p, *n, &_b, *m, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixlusolvemfast(const char **errormsg, x_matrix* lua, x_vector* p, ae_int_t* n, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_vector _p;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    rmatrixlusolvemfast(&_lua, &_p, *n, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixlusolvemfast(const char **errormsg, x_matrix* lua, x_vector* p, ae_int_t* n, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_vector _p;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _pexec_rmatrixlusolvemfast(&_lua, &_p, *n, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixmixedsolve(const char **errormsg, x_matrix* a, x_matrix* lua, x_vector* p, ae_int_t* n, x_vector* b, ae_int_t* info, x_densesolverreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _lua;
    ae_vector _p;
    ae_vector _b;
    densesolverreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    rmatrixmixedsolve(&_a, &_lua, &_p, *n, &_b, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixmixedsolvem(const char **errormsg, x_matrix* a, x_matrix* lua, x_vector* p, ae_int_t* n, x_matrix* b, ae_int_t* m, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _lua;
    ae_vector _p;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_REAL, &_alglib_env_state);
    rmatrixmixedsolvem(&_a, &_lua, &_p, *n, &_b, *m, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixsolvem(const char **errormsg, x_matrix* a, ae_int_t* n, x_matrix* b, ae_int_t* m, bool8* rfs, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_COMPLEX, &_alglib_env_state);
    cmatrixsolvem(&_a, *n, &_b, *m, *rfs, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixsolvem(const char **errormsg, x_matrix* a, ae_int_t* n, x_matrix* b, ae_int_t* m, bool8* rfs, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_COMPLEX, &_alglib_env_state);
    _pexec_cmatrixsolvem(&_a, *n, &_b, *m, *rfs, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixsolvemfast(const char **errormsg, x_matrix* a, ae_int_t* n, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    cmatrixsolvemfast(&_a, *n, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixsolvemfast(const char **errormsg, x_matrix* a, ae_int_t* n, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _pexec_cmatrixsolvemfast(&_a, *n, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixsolve(const char **errormsg, x_matrix* a, ae_int_t* n, x_vector* b, ae_int_t* info, x_densesolverreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    densesolverreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_COMPLEX, &_alglib_env_state);
    cmatrixsolve(&_a, *n, &_b, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixsolve(const char **errormsg, x_matrix* a, ae_int_t* n, x_vector* b, ae_int_t* info, x_densesolverreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    densesolverreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_COMPLEX, &_alglib_env_state);
    _pexec_cmatrixsolve(&_a, *n, &_b, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixsolvefast(const char **errormsg, x_matrix* a, ae_int_t* n, x_vector* b, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    cmatrixsolvefast(&_a, *n, &_b, info, &_alglib_env_state);
    ae_x_set_vector(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixsolvefast(const char **errormsg, x_matrix* a, ae_int_t* n, x_vector* b, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _pexec_cmatrixsolvefast(&_a, *n, &_b, info, &_alglib_env_state);
    ae_x_set_vector(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixlusolvem(const char **errormsg, x_matrix* lua, x_vector* p, ae_int_t* n, x_matrix* b, ae_int_t* m, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_vector _p;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_COMPLEX, &_alglib_env_state);
    cmatrixlusolvem(&_lua, &_p, *n, &_b, *m, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixlusolvem(const char **errormsg, x_matrix* lua, x_vector* p, ae_int_t* n, x_matrix* b, ae_int_t* m, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_vector _p;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_COMPLEX, &_alglib_env_state);
    _pexec_cmatrixlusolvem(&_lua, &_p, *n, &_b, *m, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixlusolvemfast(const char **errormsg, x_matrix* lua, x_vector* p, ae_int_t* n, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_vector _p;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    cmatrixlusolvemfast(&_lua, &_p, *n, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_cmatrixlusolvemfast(const char **errormsg, x_matrix* lua, x_vector* p, ae_int_t* n, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_vector _p;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _pexec_cmatrixlusolvemfast(&_lua, &_p, *n, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixlusolve(const char **errormsg, x_matrix* lua, x_vector* p, ae_int_t* n, x_vector* b, ae_int_t* info, x_densesolverreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_vector _p;
    ae_vector _b;
    densesolverreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_COMPLEX, &_alglib_env_state);
    cmatrixlusolve(&_lua, &_p, *n, &_b, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixlusolvefast(const char **errormsg, x_matrix* lua, x_vector* p, ae_int_t* n, x_vector* b, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _lua;
    ae_vector _p;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    cmatrixlusolvefast(&_lua, &_p, *n, &_b, info, &_alglib_env_state);
    ae_x_set_vector(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixmixedsolvem(const char **errormsg, x_matrix* a, x_matrix* lua, x_vector* p, ae_int_t* n, x_matrix* b, ae_int_t* m, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _lua;
    ae_vector _p;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_COMPLEX, &_alglib_env_state);
    cmatrixmixedsolvem(&_a, &_lua, &_p, *n, &_b, *m, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixmixedsolve(const char **errormsg, x_matrix* a, x_matrix* lua, x_vector* p, ae_int_t* n, x_vector* b, ae_int_t* info, x_densesolverreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _lua;
    ae_vector _p;
    ae_vector _b;
    densesolverreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_lua, lua, &_alglib_env_state);
    ae_vector_attach_to_x(&_p, p, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_COMPLEX, &_alglib_env_state);
    cmatrixmixedsolve(&_a, &_lua, &_p, *n, &_b, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixsolvem(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_REAL, &_alglib_env_state);
    spdmatrixsolvem(&_a, *n, *isupper, &_b, *m, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spdmatrixsolvem(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_REAL, &_alglib_env_state);
    _pexec_spdmatrixsolvem(&_a, *n, *isupper, &_b, *m, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixsolvemfast(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    spdmatrixsolvemfast(&_a, *n, *isupper, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spdmatrixsolvemfast(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _pexec_spdmatrixsolvemfast(&_a, *n, *isupper, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixsolve(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* b, ae_int_t* info, x_densesolverreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    densesolverreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    spdmatrixsolve(&_a, *n, *isupper, &_b, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spdmatrixsolve(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* b, ae_int_t* info, x_densesolverreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    densesolverreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    _pexec_spdmatrixsolve(&_a, *n, *isupper, &_b, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixsolvefast(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* b, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    spdmatrixsolvefast(&_a, *n, *isupper, &_b, info, &_alglib_env_state);
    ae_x_set_vector(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spdmatrixsolvefast(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* b, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _pexec_spdmatrixsolvefast(&_a, *n, *isupper, &_b, info, &_alglib_env_state);
    ae_x_set_vector(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixcholeskysolvem(const char **errormsg, x_matrix* cha, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _cha;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_cha, cha, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_REAL, &_alglib_env_state);
    spdmatrixcholeskysolvem(&_cha, *n, *isupper, &_b, *m, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spdmatrixcholeskysolvem(const char **errormsg, x_matrix* cha, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _cha;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_cha, cha, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_REAL, &_alglib_env_state);
    _pexec_spdmatrixcholeskysolvem(&_cha, *n, *isupper, &_b, *m, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixcholeskysolvemfast(const char **errormsg, x_matrix* cha, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _cha;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_cha, cha, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    spdmatrixcholeskysolvemfast(&_cha, *n, *isupper, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spdmatrixcholeskysolvemfast(const char **errormsg, x_matrix* cha, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _cha;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_cha, cha, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _pexec_spdmatrixcholeskysolvemfast(&_cha, *n, *isupper, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixcholeskysolve(const char **errormsg, x_matrix* cha, ae_int_t* n, bool8* isupper, x_vector* b, ae_int_t* info, x_densesolverreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _cha;
    ae_vector _b;
    densesolverreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_cha, cha, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    spdmatrixcholeskysolve(&_cha, *n, *isupper, &_b, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixcholeskysolvefast(const char **errormsg, x_matrix* cha, ae_int_t* n, bool8* isupper, x_vector* b, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _cha;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_cha, cha, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    spdmatrixcholeskysolvefast(&_cha, *n, *isupper, &_b, info, &_alglib_env_state);
    ae_x_set_vector(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hpdmatrixsolvem(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_COMPLEX, &_alglib_env_state);
    hpdmatrixsolvem(&_a, *n, *isupper, &_b, *m, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_hpdmatrixsolvem(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_COMPLEX, &_alglib_env_state);
    _pexec_hpdmatrixsolvem(&_a, *n, *isupper, &_b, *m, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hpdmatrixsolvemfast(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    hpdmatrixsolvemfast(&_a, *n, *isupper, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_hpdmatrixsolvemfast(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _pexec_hpdmatrixsolvemfast(&_a, *n, *isupper, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hpdmatrixsolve(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* b, ae_int_t* info, x_densesolverreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    densesolverreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_COMPLEX, &_alglib_env_state);
    hpdmatrixsolve(&_a, *n, *isupper, &_b, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_hpdmatrixsolve(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* b, ae_int_t* info, x_densesolverreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    densesolverreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_COMPLEX, &_alglib_env_state);
    _pexec_hpdmatrixsolve(&_a, *n, *isupper, &_b, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hpdmatrixsolvefast(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* b, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    hpdmatrixsolvefast(&_a, *n, *isupper, &_b, info, &_alglib_env_state);
    ae_x_set_vector(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_hpdmatrixsolvefast(const char **errormsg, x_matrix* a, ae_int_t* n, bool8* isupper, x_vector* b, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _pexec_hpdmatrixsolvefast(&_a, *n, *isupper, &_b, info, &_alglib_env_state);
    ae_x_set_vector(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hpdmatrixcholeskysolvem(const char **errormsg, x_matrix* cha, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _cha;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_cha, cha, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_COMPLEX, &_alglib_env_state);
    hpdmatrixcholeskysolvem(&_cha, *n, *isupper, &_b, *m, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_hpdmatrixcholeskysolvem(const char **errormsg, x_matrix* cha, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info, x_densesolverreport* rep, x_matrix* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _cha;
    ae_matrix _b;
    densesolverreport _rep;
    ae_matrix _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_cha, cha, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_matrix_init(&_x, 0, 0, DT_COMPLEX, &_alglib_env_state);
    _pexec_hpdmatrixcholeskysolvem(&_cha, *n, *isupper, &_b, *m, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_matrix(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hpdmatrixcholeskysolvemfast(const char **errormsg, x_matrix* cha, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _cha;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_cha, cha, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    hpdmatrixcholeskysolvemfast(&_cha, *n, *isupper, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_hpdmatrixcholeskysolvemfast(const char **errormsg, x_matrix* cha, ae_int_t* n, bool8* isupper, x_matrix* b, ae_int_t* m, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _cha;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_cha, cha, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    _pexec_hpdmatrixcholeskysolvemfast(&_cha, *n, *isupper, &_b, *m, info, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hpdmatrixcholeskysolve(const char **errormsg, x_matrix* cha, ae_int_t* n, bool8* isupper, x_vector* b, ae_int_t* info, x_densesolverreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _cha;
    ae_vector _b;
    densesolverreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_cha, cha, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_COMPLEX, &_alglib_env_state);
    hpdmatrixcholeskysolve(&_cha, *n, *isupper, &_b, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hpdmatrixcholeskysolvefast(const char **errormsg, x_matrix* cha, ae_int_t* n, bool8* isupper, x_vector* b, ae_int_t* info)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _cha;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_cha, cha, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    hpdmatrixcholeskysolvefast(&_cha, *n, *isupper, &_b, info, &_alglib_env_state);
    ae_x_set_vector(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixsolvels(const char **errormsg, x_matrix* a, ae_int_t* nrows, ae_int_t* ncols, x_vector* b, double* threshold, ae_int_t* info, x_densesolverlsreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    densesolverlsreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverlsreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    rmatrixsolvels(&_a, *nrows, *ncols, &_b, *threshold, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverlsreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_rmatrixsolvels(const char **errormsg, x_matrix* a, ae_int_t* nrows, ae_int_t* ncols, x_vector* b, double* threshold, ae_int_t* info, x_densesolverlsreport* rep, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _b;
    densesolverlsreport _rep;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    _densesolverlsreport_init(&_rep, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    _pexec_rmatrixsolvels(&_a, *nrows, *ncols, &_b, *threshold, info, &_rep, &_x, &_alglib_env_state);
    x_set_densesolverlsreport(rep, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED logitmodel obj;
} x_logitmodel;
x_logitmodel* x_obj_alloc_logitmodel(ae_state *_state)
{
    x_logitmodel *result;
    result = ae_malloc(sizeof(x_logitmodel), _state);
    _logitmodel_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_logitmodel* x_obj_copy_logitmodel(x_logitmodel *src)
{
    x_logitmodel *result;
    result = ae_malloc(sizeof(x_logitmodel), NULL);
    _logitmodel_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_logitmodel(x_logitmodel *obj)
{
    if( obj==NULL )
        return;
    _logitmodel_clear(&obj->obj);
    ae_free(obj);
    return;
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t ngrad;
    ALIGNED ae_int_t nhess;
} x_mnlreport;
void x_set_mnlreport(x_mnlreport *dst, mnlreport *src, ae_state *_state)
{
    dst->ngrad = src->ngrad;
    dst->nhess = src->nhess;
}
void mnlreport_init_from_x(mnlreport *dst, x_mnlreport *src, ae_state *_state)
{
    dst->ngrad = src->ngrad;
    dst->nhess = src->nhess;
}
DLLEXPORT ae_int32_t alglib_mnltrainh(const char **errormsg, x_matrix* xy, ae_int_t* npoints, ae_int_t* nvars, ae_int_t* nclasses, ae_int_t* info, x_logitmodel** lm, x_mnlreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    mnlreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *lm = x_obj_alloc_logitmodel(&_alglib_env_state);
    _mnlreport_init(&_rep, &_alglib_env_state);
    mnltrainh(&_xy, *npoints, *nvars, *nclasses, info, &(*lm)->obj, &_rep, &_alglib_env_state);
    x_set_mnlreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mnlprocess(const char **errormsg, x_logitmodel** lm, x_vector* x, x_vector* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    mnlprocess(&(*lm)->obj, &_x, &_y, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mnlprocessi(const char **errormsg, x_logitmodel** lm, x_vector* x, x_vector* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_init(&_y, 0, DT_REAL, &_alglib_env_state);
    mnlprocessi(&(*lm)->obj, &_x, &_y, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mnlunpack(const char **errormsg, x_logitmodel** lm, x_matrix* a, ae_int_t* nvars, ae_int_t* nclasses)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_a, 0, 0, DT_REAL, &_alglib_env_state);
    mnlunpack(&(*lm)->obj, &_a, nvars, nclasses, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mnlpack(const char **errormsg, x_matrix* a, ae_int_t* nvars, ae_int_t* nclasses, x_logitmodel** lm)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *lm = x_obj_alloc_logitmodel(&_alglib_env_state);
    mnlpack(&_a, *nvars, *nclasses, &(*lm)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mnlavgce(const char **errormsg, double* result, x_logitmodel** lm, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mnlavgce(&(*lm)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mnlrelclserror(const char **errormsg, double* result, x_logitmodel** lm, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mnlrelclserror(&(*lm)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mnlrmserror(const char **errormsg, double* result, x_logitmodel** lm, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mnlrmserror(&(*lm)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mnlavgerror(const char **errormsg, double* result, x_logitmodel** lm, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mnlavgerror(&(*lm)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mnlavgrelerror(const char **errormsg, double* result, x_logitmodel** lm, x_matrix* xy, ae_int_t* ssize)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mnlavgrelerror(&(*lm)->obj, &_xy, *ssize, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mnlclserror(const char **errormsg, ae_int_t* result, x_logitmodel** lm, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mnlclserror(&(*lm)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED mincgstate obj;
} x_mincgstate;
x_mincgstate* x_obj_alloc_mincgstate(ae_state *_state)
{
    x_mincgstate *result;
    result = ae_malloc(sizeof(x_mincgstate), _state);
    _mincgstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_mincgstate* x_obj_copy_mincgstate(x_mincgstate *src)
{
    x_mincgstate *result;
    result = ae_malloc(sizeof(x_mincgstate), NULL);
    _mincgstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_mincgstate(x_mincgstate *obj)
{
    if( obj==NULL )
        return;
    _mincgstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT void x_mincgstate_get_needf(x_mincgstate *obj, bool8 *result)
{
    *result = obj->obj.needf;
}
DLLEXPORT void x_mincgstate_set_needf(x_mincgstate *obj, bool8 *result)
{
    obj->obj.needf = *result;
}
DLLEXPORT void x_mincgstate_get_needfg(x_mincgstate *obj, bool8 *result)
{
    *result = obj->obj.needfg;
}
DLLEXPORT void x_mincgstate_set_needfg(x_mincgstate *obj, bool8 *result)
{
    obj->obj.needfg = *result;
}
DLLEXPORT void x_mincgstate_get_xupdated(x_mincgstate *obj, bool8 *result)
{
    *result = obj->obj.xupdated;
}
DLLEXPORT void x_mincgstate_set_xupdated(x_mincgstate *obj, bool8 *result)
{
    obj->obj.xupdated = *result;
}
DLLEXPORT void x_mincgstate_get_f(x_mincgstate *obj, double *result)
{
    *result = obj->obj.f;
}
DLLEXPORT void x_mincgstate_set_f(x_mincgstate *obj, double *result)
{
    obj->obj.f = *result;
}
DLLEXPORT void x_mincgstate_get_g(x_mincgstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.g);
}
DLLEXPORT void x_mincgstate_get_x(x_mincgstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.x);
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t iterationscount;
    ALIGNED ae_int_t nfev;
    ALIGNED ae_int_t varidx;
    ALIGNED ae_int_t terminationtype;
} x_mincgreport;
void x_set_mincgreport(x_mincgreport *dst, mincgreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nfev = src->nfev;
    dst->varidx = src->varidx;
    dst->terminationtype = src->terminationtype;
}
void mincgreport_init_from_x(mincgreport *dst, x_mincgreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nfev = src->nfev;
    dst->varidx = src->varidx;
    dst->terminationtype = src->terminationtype;
}
DLLEXPORT ae_int32_t alglib_mincgcreate(const char **errormsg, ae_int_t* n, x_vector* x, x_mincgstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_mincgstate(&_alglib_env_state);
    mincgcreate(*n, &_x, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgcreatef(const char **errormsg, ae_int_t* n, x_vector* x, double* diffstep, x_mincgstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_mincgstate(&_alglib_env_state);
    mincgcreatef(*n, &_x, *diffstep, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgsetcond(const char **errormsg, x_mincgstate** state, double* epsg, double* epsf, double* epsx, ae_int_t* maxits)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mincgsetcond(&(*state)->obj, *epsg, *epsf, *epsx, *maxits, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgsetscale(const char **errormsg, x_mincgstate** state, x_vector* s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _s;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_s, s, &_alglib_env_state);
    mincgsetscale(&(*state)->obj, &_s, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgsetxrep(const char **errormsg, x_mincgstate** state, bool8* needxrep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mincgsetxrep(&(*state)->obj, *needxrep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgsetcgtype(const char **errormsg, x_mincgstate** state, ae_int_t* cgtype)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mincgsetcgtype(&(*state)->obj, *cgtype, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgsetstpmax(const char **errormsg, x_mincgstate** state, double* stpmax)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mincgsetstpmax(&(*state)->obj, *stpmax, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgsuggeststep(const char **errormsg, x_mincgstate** state, double* stp)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mincgsuggeststep(&(*state)->obj, *stp, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgsetprecdefault(const char **errormsg, x_mincgstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mincgsetprecdefault(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgsetprecdiag(const char **errormsg, x_mincgstate** state, x_vector* d)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _d;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_d, d, &_alglib_env_state);
    mincgsetprecdiag(&(*state)->obj, &_d, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgsetprecscale(const char **errormsg, x_mincgstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mincgsetprecscale(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgiteration(const char **errormsg, bool8* result, x_mincgstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mincgiteration(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgresults(const char **errormsg, x_mincgstate** state, x_vector* x, x_mincgreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    mincgreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    _mincgreport_init(&_rep, &_alglib_env_state);
    mincgresults(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_mincgreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgresultsbuf(const char **errormsg, x_mincgstate** state, x_vector* x, x_mincgreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    mincgreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    mincgreport_init_from_x(&_rep, rep, &_alglib_env_state);
    mincgresultsbuf(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_mincgreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgrestartfrom(const char **errormsg, x_mincgstate** state, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    mincgrestartfrom(&(*state)->obj, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgrequesttermination(const char **errormsg, x_mincgstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mincgrequesttermination(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mincgsetgradientcheck(const char **errormsg, x_mincgstate** state, double* teststep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mincgsetgradientcheck(&(*state)->obj, *teststep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED minbleicstate obj;
} x_minbleicstate;
x_minbleicstate* x_obj_alloc_minbleicstate(ae_state *_state)
{
    x_minbleicstate *result;
    result = ae_malloc(sizeof(x_minbleicstate), _state);
    _minbleicstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_minbleicstate* x_obj_copy_minbleicstate(x_minbleicstate *src)
{
    x_minbleicstate *result;
    result = ae_malloc(sizeof(x_minbleicstate), NULL);
    _minbleicstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_minbleicstate(x_minbleicstate *obj)
{
    if( obj==NULL )
        return;
    _minbleicstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT void x_minbleicstate_get_needf(x_minbleicstate *obj, bool8 *result)
{
    *result = obj->obj.needf;
}
DLLEXPORT void x_minbleicstate_set_needf(x_minbleicstate *obj, bool8 *result)
{
    obj->obj.needf = *result;
}
DLLEXPORT void x_minbleicstate_get_needfg(x_minbleicstate *obj, bool8 *result)
{
    *result = obj->obj.needfg;
}
DLLEXPORT void x_minbleicstate_set_needfg(x_minbleicstate *obj, bool8 *result)
{
    obj->obj.needfg = *result;
}
DLLEXPORT void x_minbleicstate_get_xupdated(x_minbleicstate *obj, bool8 *result)
{
    *result = obj->obj.xupdated;
}
DLLEXPORT void x_minbleicstate_set_xupdated(x_minbleicstate *obj, bool8 *result)
{
    obj->obj.xupdated = *result;
}
DLLEXPORT void x_minbleicstate_get_f(x_minbleicstate *obj, double *result)
{
    *result = obj->obj.f;
}
DLLEXPORT void x_minbleicstate_set_f(x_minbleicstate *obj, double *result)
{
    obj->obj.f = *result;
}
DLLEXPORT void x_minbleicstate_get_g(x_minbleicstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.g);
}
DLLEXPORT void x_minbleicstate_get_x(x_minbleicstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.x);
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t iterationscount;
    ALIGNED ae_int_t nfev;
    ALIGNED ae_int_t varidx;
    ALIGNED ae_int_t terminationtype;
    ALIGNED double debugeqerr;
    ALIGNED double debugfs;
    ALIGNED double debugff;
    ALIGNED double debugdx;
    ALIGNED ae_int_t debugfeasqpits;
    ALIGNED ae_int_t debugfeasgpaits;
    ALIGNED ae_int_t inneriterationscount;
    ALIGNED ae_int_t outeriterationscount;
} x_minbleicreport;
void x_set_minbleicreport(x_minbleicreport *dst, minbleicreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nfev = src->nfev;
    dst->varidx = src->varidx;
    dst->terminationtype = src->terminationtype;
    dst->debugeqerr = src->debugeqerr;
    dst->debugfs = src->debugfs;
    dst->debugff = src->debugff;
    dst->debugdx = src->debugdx;
    dst->debugfeasqpits = src->debugfeasqpits;
    dst->debugfeasgpaits = src->debugfeasgpaits;
    dst->inneriterationscount = src->inneriterationscount;
    dst->outeriterationscount = src->outeriterationscount;
}
void minbleicreport_init_from_x(minbleicreport *dst, x_minbleicreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nfev = src->nfev;
    dst->varidx = src->varidx;
    dst->terminationtype = src->terminationtype;
    dst->debugeqerr = src->debugeqerr;
    dst->debugfs = src->debugfs;
    dst->debugff = src->debugff;
    dst->debugdx = src->debugdx;
    dst->debugfeasqpits = src->debugfeasqpits;
    dst->debugfeasgpaits = src->debugfeasgpaits;
    dst->inneriterationscount = src->inneriterationscount;
    dst->outeriterationscount = src->outeriterationscount;
}
DLLEXPORT ae_int32_t alglib_minbleiccreate(const char **errormsg, ae_int_t* n, x_vector* x, x_minbleicstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_minbleicstate(&_alglib_env_state);
    minbleiccreate(*n, &_x, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleiccreatef(const char **errormsg, ae_int_t* n, x_vector* x, double* diffstep, x_minbleicstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_minbleicstate(&_alglib_env_state);
    minbleiccreatef(*n, &_x, *diffstep, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicsetbc(const char **errormsg, x_minbleicstate** state, x_vector* bndl, x_vector* bndu)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _bndl;
    ae_vector _bndu;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_bndl, bndl, &_alglib_env_state);
    ae_vector_attach_to_x(&_bndu, bndu, &_alglib_env_state);
    minbleicsetbc(&(*state)->obj, &_bndl, &_bndu, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicsetlc(const char **errormsg, x_minbleicstate** state, x_matrix* c, x_vector* ct, ae_int_t* k)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _c;
    ae_vector _ct;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    ae_vector_attach_to_x(&_ct, ct, &_alglib_env_state);
    minbleicsetlc(&(*state)->obj, &_c, &_ct, *k, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicsetcond(const char **errormsg, x_minbleicstate** state, double* epsg, double* epsf, double* epsx, ae_int_t* maxits)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minbleicsetcond(&(*state)->obj, *epsg, *epsf, *epsx, *maxits, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicsetscale(const char **errormsg, x_minbleicstate** state, x_vector* s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _s;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_s, s, &_alglib_env_state);
    minbleicsetscale(&(*state)->obj, &_s, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicsetprecdefault(const char **errormsg, x_minbleicstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minbleicsetprecdefault(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicsetprecdiag(const char **errormsg, x_minbleicstate** state, x_vector* d)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _d;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_d, d, &_alglib_env_state);
    minbleicsetprecdiag(&(*state)->obj, &_d, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicsetprecscale(const char **errormsg, x_minbleicstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minbleicsetprecscale(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicsetxrep(const char **errormsg, x_minbleicstate** state, bool8* needxrep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minbleicsetxrep(&(*state)->obj, *needxrep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicsetstpmax(const char **errormsg, x_minbleicstate** state, double* stpmax)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minbleicsetstpmax(&(*state)->obj, *stpmax, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleiciteration(const char **errormsg, bool8* result, x_minbleicstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = minbleiciteration(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicresults(const char **errormsg, x_minbleicstate** state, x_vector* x, x_minbleicreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    minbleicreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    _minbleicreport_init(&_rep, &_alglib_env_state);
    minbleicresults(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_minbleicreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicresultsbuf(const char **errormsg, x_minbleicstate** state, x_vector* x, x_minbleicreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    minbleicreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    minbleicreport_init_from_x(&_rep, rep, &_alglib_env_state);
    minbleicresultsbuf(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_minbleicreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicrestartfrom(const char **errormsg, x_minbleicstate** state, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    minbleicrestartfrom(&(*state)->obj, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicrequesttermination(const char **errormsg, x_minbleicstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minbleicrequesttermination(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicsetgradientcheck(const char **errormsg, x_minbleicstate** state, double* teststep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minbleicsetgradientcheck(&(*state)->obj, *teststep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED mcpdstate obj;
} x_mcpdstate;
x_mcpdstate* x_obj_alloc_mcpdstate(ae_state *_state)
{
    x_mcpdstate *result;
    result = ae_malloc(sizeof(x_mcpdstate), _state);
    _mcpdstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_mcpdstate* x_obj_copy_mcpdstate(x_mcpdstate *src)
{
    x_mcpdstate *result;
    result = ae_malloc(sizeof(x_mcpdstate), NULL);
    _mcpdstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_mcpdstate(x_mcpdstate *obj)
{
    if( obj==NULL )
        return;
    _mcpdstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t inneriterationscount;
    ALIGNED ae_int_t outeriterationscount;
    ALIGNED ae_int_t nfev;
    ALIGNED ae_int_t terminationtype;
} x_mcpdreport;
void x_set_mcpdreport(x_mcpdreport *dst, mcpdreport *src, ae_state *_state)
{
    dst->inneriterationscount = src->inneriterationscount;
    dst->outeriterationscount = src->outeriterationscount;
    dst->nfev = src->nfev;
    dst->terminationtype = src->terminationtype;
}
void mcpdreport_init_from_x(mcpdreport *dst, x_mcpdreport *src, ae_state *_state)
{
    dst->inneriterationscount = src->inneriterationscount;
    dst->outeriterationscount = src->outeriterationscount;
    dst->nfev = src->nfev;
    dst->terminationtype = src->terminationtype;
}
DLLEXPORT ae_int32_t alglib_mcpdcreate(const char **errormsg, ae_int_t* n, x_mcpdstate** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *s = x_obj_alloc_mcpdstate(&_alglib_env_state);
    mcpdcreate(*n, &(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mcpdcreateentry(const char **errormsg, ae_int_t* n, ae_int_t* entrystate, x_mcpdstate** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *s = x_obj_alloc_mcpdstate(&_alglib_env_state);
    mcpdcreateentry(*n, *entrystate, &(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mcpdcreateexit(const char **errormsg, ae_int_t* n, ae_int_t* exitstate, x_mcpdstate** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *s = x_obj_alloc_mcpdstate(&_alglib_env_state);
    mcpdcreateexit(*n, *exitstate, &(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mcpdcreateentryexit(const char **errormsg, ae_int_t* n, ae_int_t* entrystate, ae_int_t* exitstate, x_mcpdstate** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *s = x_obj_alloc_mcpdstate(&_alglib_env_state);
    mcpdcreateentryexit(*n, *entrystate, *exitstate, &(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mcpdaddtrack(const char **errormsg, x_mcpdstate** s, x_matrix* xy, ae_int_t* k)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    mcpdaddtrack(&(*s)->obj, &_xy, *k, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mcpdsetec(const char **errormsg, x_mcpdstate** s, x_matrix* ec)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _ec;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_ec, ec, &_alglib_env_state);
    mcpdsetec(&(*s)->obj, &_ec, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mcpdaddec(const char **errormsg, x_mcpdstate** s, ae_int_t* i, ae_int_t* j, double* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mcpdaddec(&(*s)->obj, *i, *j, *c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mcpdsetbc(const char **errormsg, x_mcpdstate** s, x_matrix* bndl, x_matrix* bndu)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _bndl;
    ae_matrix _bndu;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_bndl, bndl, &_alglib_env_state);
    ae_matrix_attach_to_x(&_bndu, bndu, &_alglib_env_state);
    mcpdsetbc(&(*s)->obj, &_bndl, &_bndu, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mcpdaddbc(const char **errormsg, x_mcpdstate** s, ae_int_t* i, ae_int_t* j, double* bndl, double* bndu)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mcpdaddbc(&(*s)->obj, *i, *j, *bndl, *bndu, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mcpdsetlc(const char **errormsg, x_mcpdstate** s, x_matrix* c, x_vector* ct, ae_int_t* k)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _c;
    ae_vector _ct;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    ae_vector_attach_to_x(&_ct, ct, &_alglib_env_state);
    mcpdsetlc(&(*s)->obj, &_c, &_ct, *k, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mcpdsettikhonovregularizer(const char **errormsg, x_mcpdstate** s, double* v)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mcpdsettikhonovregularizer(&(*s)->obj, *v, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mcpdsetprior(const char **errormsg, x_mcpdstate** s, x_matrix* pp)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _pp;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_pp, pp, &_alglib_env_state);
    mcpdsetprior(&(*s)->obj, &_pp, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mcpdsetpredictionweights(const char **errormsg, x_mcpdstate** s, x_vector* pw)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _pw;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_pw, pw, &_alglib_env_state);
    mcpdsetpredictionweights(&(*s)->obj, &_pw, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mcpdsolve(const char **errormsg, x_mcpdstate** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mcpdsolve(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mcpdresults(const char **errormsg, x_mcpdstate** s, x_matrix* p, x_mcpdreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _p;
    mcpdreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_p, 0, 0, DT_REAL, &_alglib_env_state);
    _mcpdreport_init(&_rep, &_alglib_env_state);
    mcpdresults(&(*s)->obj, &_p, &_rep, &_alglib_env_state);
    ae_x_set_matrix(p, &_p, &_alglib_env_state);
    x_set_mcpdreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED mlpensemble obj;
} x_mlpensemble;
x_mlpensemble* x_obj_alloc_mlpensemble(ae_state *_state)
{
    x_mlpensemble *result;
    result = ae_malloc(sizeof(x_mlpensemble), _state);
    _mlpensemble_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_mlpensemble* x_obj_copy_mlpensemble(x_mlpensemble *src)
{
    x_mlpensemble *result;
    result = ae_malloc(sizeof(x_mlpensemble), NULL);
    _mlpensemble_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_mlpensemble(x_mlpensemble *obj)
{
    if( obj==NULL )
        return;
    _mlpensemble_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT ae_int32_t alglib_mlpeserialize(const char **errormsg, x_mlpensemble **obj, char **s_out)
{
    ae_state state;
    ae_serializer serializer;
    jmp_buf _break_jump;
    ae_frame _frame_block;
    
    ae_state_init(&state);
    ae_serializer_init(&serializer);
    if( setjmp(_break_jump) )
    {
        if( state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&state, &_break_jump);
    ae_frame_make(&state, &_frame_block);
    
    ae_serializer_alloc_start(&serializer);
    mlpealloc(&serializer, &((*obj)->obj), &state);
    x_malloc((void**)(s_out), ae_serializer_get_alloc_size(&serializer)+1);
    ae_serializer_sstart_str(&serializer, *s_out);
    mlpeserialize(&serializer, &((*obj)->obj), &state);
    ae_serializer_stop(&serializer);
    
    ae_serializer_clear(&serializer);
    ae_state_clear(&state);
    return X_OK;
}    
    
DLLEXPORT ae_int32_t alglib_mlpeunserialize(const char **errormsg, char **s_in, x_mlpensemble **obj)
{
    ae_state state;
    ae_serializer serializer;
    jmp_buf _break_jump;
    ae_frame _frame_block;
    
    ae_state_init(&state);
    ae_serializer_init(&serializer);
    if( setjmp(_break_jump) )
    {
        if( state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&state, &_break_jump);
    ae_frame_make(&state, &_frame_block);
    
    *obj = x_obj_alloc_mlpensemble(&state);
    ae_serializer_ustart_str(&serializer, *s_in);
    mlpeunserialize(&serializer, &((*obj)->obj), &state);
    ae_serializer_stop(&serializer);
    
    ae_serializer_clear(&serializer);
    ae_state_clear(&state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpecreate0(const char **errormsg, ae_int_t* nin, ae_int_t* nout, ae_int_t* ensemblesize, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *ensemble = x_obj_alloc_mlpensemble(&_alglib_env_state);
    mlpecreate0(*nin, *nout, *ensemblesize, &(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpecreate1(const char **errormsg, ae_int_t* nin, ae_int_t* nhid, ae_int_t* nout, ae_int_t* ensemblesize, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *ensemble = x_obj_alloc_mlpensemble(&_alglib_env_state);
    mlpecreate1(*nin, *nhid, *nout, *ensemblesize, &(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpecreate2(const char **errormsg, ae_int_t* nin, ae_int_t* nhid1, ae_int_t* nhid2, ae_int_t* nout, ae_int_t* ensemblesize, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *ensemble = x_obj_alloc_mlpensemble(&_alglib_env_state);
    mlpecreate2(*nin, *nhid1, *nhid2, *nout, *ensemblesize, &(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpecreateb0(const char **errormsg, ae_int_t* nin, ae_int_t* nout, double* b, double* d, ae_int_t* ensemblesize, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *ensemble = x_obj_alloc_mlpensemble(&_alglib_env_state);
    mlpecreateb0(*nin, *nout, *b, *d, *ensemblesize, &(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpecreateb1(const char **errormsg, ae_int_t* nin, ae_int_t* nhid, ae_int_t* nout, double* b, double* d, ae_int_t* ensemblesize, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *ensemble = x_obj_alloc_mlpensemble(&_alglib_env_state);
    mlpecreateb1(*nin, *nhid, *nout, *b, *d, *ensemblesize, &(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpecreateb2(const char **errormsg, ae_int_t* nin, ae_int_t* nhid1, ae_int_t* nhid2, ae_int_t* nout, double* b, double* d, ae_int_t* ensemblesize, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *ensemble = x_obj_alloc_mlpensemble(&_alglib_env_state);
    mlpecreateb2(*nin, *nhid1, *nhid2, *nout, *b, *d, *ensemblesize, &(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpecreater0(const char **errormsg, ae_int_t* nin, ae_int_t* nout, double* a, double* b, ae_int_t* ensemblesize, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *ensemble = x_obj_alloc_mlpensemble(&_alglib_env_state);
    mlpecreater0(*nin, *nout, *a, *b, *ensemblesize, &(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpecreater1(const char **errormsg, ae_int_t* nin, ae_int_t* nhid, ae_int_t* nout, double* a, double* b, ae_int_t* ensemblesize, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *ensemble = x_obj_alloc_mlpensemble(&_alglib_env_state);
    mlpecreater1(*nin, *nhid, *nout, *a, *b, *ensemblesize, &(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpecreater2(const char **errormsg, ae_int_t* nin, ae_int_t* nhid1, ae_int_t* nhid2, ae_int_t* nout, double* a, double* b, ae_int_t* ensemblesize, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *ensemble = x_obj_alloc_mlpensemble(&_alglib_env_state);
    mlpecreater2(*nin, *nhid1, *nhid2, *nout, *a, *b, *ensemblesize, &(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpecreatec0(const char **errormsg, ae_int_t* nin, ae_int_t* nout, ae_int_t* ensemblesize, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *ensemble = x_obj_alloc_mlpensemble(&_alglib_env_state);
    mlpecreatec0(*nin, *nout, *ensemblesize, &(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpecreatec1(const char **errormsg, ae_int_t* nin, ae_int_t* nhid, ae_int_t* nout, ae_int_t* ensemblesize, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *ensemble = x_obj_alloc_mlpensemble(&_alglib_env_state);
    mlpecreatec1(*nin, *nhid, *nout, *ensemblesize, &(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpecreatec2(const char **errormsg, ae_int_t* nin, ae_int_t* nhid1, ae_int_t* nhid2, ae_int_t* nout, ae_int_t* ensemblesize, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *ensemble = x_obj_alloc_mlpensemble(&_alglib_env_state);
    mlpecreatec2(*nin, *nhid1, *nhid2, *nout, *ensemblesize, &(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpecreatefromnetwork(const char **errormsg, x_multilayerperceptron** network, ae_int_t* ensemblesize, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *ensemble = x_obj_alloc_mlpensemble(&_alglib_env_state);
    mlpecreatefromnetwork(&(*network)->obj, *ensemblesize, &(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlperandomize(const char **errormsg, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlperandomize(&(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpeproperties(const char **errormsg, x_mlpensemble** ensemble, ae_int_t* nin, ae_int_t* nout)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpeproperties(&(*ensemble)->obj, nin, nout, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpeissoftmax(const char **errormsg, bool8* result, x_mlpensemble** ensemble)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlpeissoftmax(&(*ensemble)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpeprocess(const char **errormsg, x_mlpensemble** ensemble, x_vector* x, x_vector* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    mlpeprocess(&(*ensemble)->obj, &_x, &_y, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpeprocessi(const char **errormsg, x_mlpensemble** ensemble, x_vector* x, x_vector* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_init(&_y, 0, DT_REAL, &_alglib_env_state);
    mlpeprocessi(&(*ensemble)->obj, &_x, &_y, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlperelclserror(const char **errormsg, double* result, x_mlpensemble** ensemble, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mlperelclserror(&(*ensemble)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpeavgce(const char **errormsg, double* result, x_mlpensemble** ensemble, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mlpeavgce(&(*ensemble)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpermserror(const char **errormsg, double* result, x_mlpensemble** ensemble, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mlpermserror(&(*ensemble)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpeavgerror(const char **errormsg, double* result, x_mlpensemble** ensemble, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mlpeavgerror(&(*ensemble)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpeavgrelerror(const char **errormsg, double* result, x_mlpensemble** ensemble, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *result = mlpeavgrelerror(&(*ensemble)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED minlbfgsstate obj;
} x_minlbfgsstate;
x_minlbfgsstate* x_obj_alloc_minlbfgsstate(ae_state *_state)
{
    x_minlbfgsstate *result;
    result = ae_malloc(sizeof(x_minlbfgsstate), _state);
    _minlbfgsstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_minlbfgsstate* x_obj_copy_minlbfgsstate(x_minlbfgsstate *src)
{
    x_minlbfgsstate *result;
    result = ae_malloc(sizeof(x_minlbfgsstate), NULL);
    _minlbfgsstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_minlbfgsstate(x_minlbfgsstate *obj)
{
    if( obj==NULL )
        return;
    _minlbfgsstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT void x_minlbfgsstate_get_needf(x_minlbfgsstate *obj, bool8 *result)
{
    *result = obj->obj.needf;
}
DLLEXPORT void x_minlbfgsstate_set_needf(x_minlbfgsstate *obj, bool8 *result)
{
    obj->obj.needf = *result;
}
DLLEXPORT void x_minlbfgsstate_get_needfg(x_minlbfgsstate *obj, bool8 *result)
{
    *result = obj->obj.needfg;
}
DLLEXPORT void x_minlbfgsstate_set_needfg(x_minlbfgsstate *obj, bool8 *result)
{
    obj->obj.needfg = *result;
}
DLLEXPORT void x_minlbfgsstate_get_xupdated(x_minlbfgsstate *obj, bool8 *result)
{
    *result = obj->obj.xupdated;
}
DLLEXPORT void x_minlbfgsstate_set_xupdated(x_minlbfgsstate *obj, bool8 *result)
{
    obj->obj.xupdated = *result;
}
DLLEXPORT void x_minlbfgsstate_get_f(x_minlbfgsstate *obj, double *result)
{
    *result = obj->obj.f;
}
DLLEXPORT void x_minlbfgsstate_set_f(x_minlbfgsstate *obj, double *result)
{
    obj->obj.f = *result;
}
DLLEXPORT void x_minlbfgsstate_get_g(x_minlbfgsstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.g);
}
DLLEXPORT void x_minlbfgsstate_get_x(x_minlbfgsstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.x);
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t iterationscount;
    ALIGNED ae_int_t nfev;
    ALIGNED ae_int_t varidx;
    ALIGNED ae_int_t terminationtype;
} x_minlbfgsreport;
void x_set_minlbfgsreport(x_minlbfgsreport *dst, minlbfgsreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nfev = src->nfev;
    dst->varidx = src->varidx;
    dst->terminationtype = src->terminationtype;
}
void minlbfgsreport_init_from_x(minlbfgsreport *dst, x_minlbfgsreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nfev = src->nfev;
    dst->varidx = src->varidx;
    dst->terminationtype = src->terminationtype;
}
DLLEXPORT ae_int32_t alglib_minlbfgscreate(const char **errormsg, ae_int_t* n, ae_int_t* m, x_vector* x, x_minlbfgsstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_minlbfgsstate(&_alglib_env_state);
    minlbfgscreate(*n, *m, &_x, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgscreatef(const char **errormsg, ae_int_t* n, ae_int_t* m, x_vector* x, double* diffstep, x_minlbfgsstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_minlbfgsstate(&_alglib_env_state);
    minlbfgscreatef(*n, *m, &_x, *diffstep, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgssetcond(const char **errormsg, x_minlbfgsstate** state, double* epsg, double* epsf, double* epsx, ae_int_t* maxits)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minlbfgssetcond(&(*state)->obj, *epsg, *epsf, *epsx, *maxits, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgssetxrep(const char **errormsg, x_minlbfgsstate** state, bool8* needxrep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minlbfgssetxrep(&(*state)->obj, *needxrep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgssetstpmax(const char **errormsg, x_minlbfgsstate** state, double* stpmax)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minlbfgssetstpmax(&(*state)->obj, *stpmax, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgssetscale(const char **errormsg, x_minlbfgsstate** state, x_vector* s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _s;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_s, s, &_alglib_env_state);
    minlbfgssetscale(&(*state)->obj, &_s, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgssetprecdefault(const char **errormsg, x_minlbfgsstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minlbfgssetprecdefault(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgssetpreccholesky(const char **errormsg, x_minlbfgsstate** state, x_matrix* p, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _p;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_p, p, &_alglib_env_state);
    minlbfgssetpreccholesky(&(*state)->obj, &_p, *isupper, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgssetprecdiag(const char **errormsg, x_minlbfgsstate** state, x_vector* d)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _d;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_d, d, &_alglib_env_state);
    minlbfgssetprecdiag(&(*state)->obj, &_d, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgssetprecscale(const char **errormsg, x_minlbfgsstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minlbfgssetprecscale(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgsiteration(const char **errormsg, bool8* result, x_minlbfgsstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = minlbfgsiteration(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgsresults(const char **errormsg, x_minlbfgsstate** state, x_vector* x, x_minlbfgsreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    minlbfgsreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    _minlbfgsreport_init(&_rep, &_alglib_env_state);
    minlbfgsresults(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_minlbfgsreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgsresultsbuf(const char **errormsg, x_minlbfgsstate** state, x_vector* x, x_minlbfgsreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    minlbfgsreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    minlbfgsreport_init_from_x(&_rep, rep, &_alglib_env_state);
    minlbfgsresultsbuf(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_minlbfgsreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgsrestartfrom(const char **errormsg, x_minlbfgsstate** state, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    minlbfgsrestartfrom(&(*state)->obj, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgsrequesttermination(const char **errormsg, x_minlbfgsstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minlbfgsrequesttermination(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgssetgradientcheck(const char **errormsg, x_minlbfgsstate** state, double* teststep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minlbfgssetgradientcheck(&(*state)->obj, *teststep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED double relclserror;
    ALIGNED double avgce;
    ALIGNED double rmserror;
    ALIGNED double avgerror;
    ALIGNED double avgrelerror;
    ALIGNED ae_int_t ngrad;
    ALIGNED ae_int_t nhess;
    ALIGNED ae_int_t ncholesky;
} x_mlpreport;
void x_set_mlpreport(x_mlpreport *dst, mlpreport *src, ae_state *_state)
{
    dst->relclserror = src->relclserror;
    dst->avgce = src->avgce;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
    dst->ngrad = src->ngrad;
    dst->nhess = src->nhess;
    dst->ncholesky = src->ncholesky;
}
void mlpreport_init_from_x(mlpreport *dst, x_mlpreport *src, ae_state *_state)
{
    dst->relclserror = src->relclserror;
    dst->avgce = src->avgce;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
    dst->ngrad = src->ngrad;
    dst->nhess = src->nhess;
    dst->ncholesky = src->ncholesky;
}
typedef ALIGNED struct
{
    ALIGNED double relclserror;
    ALIGNED double avgce;
    ALIGNED double rmserror;
    ALIGNED double avgerror;
    ALIGNED double avgrelerror;
} x_mlpcvreport;
void x_set_mlpcvreport(x_mlpcvreport *dst, mlpcvreport *src, ae_state *_state)
{
    dst->relclserror = src->relclserror;
    dst->avgce = src->avgce;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
}
void mlpcvreport_init_from_x(mlpcvreport *dst, x_mlpcvreport *src, ae_state *_state)
{
    dst->relclserror = src->relclserror;
    dst->avgce = src->avgce;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
}
typedef ALIGNED struct
{
    ALIGNED mlptrainer obj;
} x_mlptrainer;
x_mlptrainer* x_obj_alloc_mlptrainer(ae_state *_state)
{
    x_mlptrainer *result;
    result = ae_malloc(sizeof(x_mlptrainer), _state);
    _mlptrainer_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_mlptrainer* x_obj_copy_mlptrainer(x_mlptrainer *src)
{
    x_mlptrainer *result;
    result = ae_malloc(sizeof(x_mlptrainer), NULL);
    _mlptrainer_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_mlptrainer(x_mlptrainer *obj)
{
    if( obj==NULL )
        return;
    _mlptrainer_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT ae_int32_t alglib_mlptrainlm(const char **errormsg, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints, double* decay, ae_int_t* restarts, ae_int_t* info, x_mlpreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    mlpreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    _mlpreport_init(&_rep, &_alglib_env_state);
    mlptrainlm(&(*network)->obj, &_xy, *npoints, *decay, *restarts, info, &_rep, &_alglib_env_state);
    x_set_mlpreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlptrainlbfgs(const char **errormsg, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints, double* decay, ae_int_t* restarts, double* wstep, ae_int_t* maxits, ae_int_t* info, x_mlpreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    mlpreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    _mlpreport_init(&_rep, &_alglib_env_state);
    mlptrainlbfgs(&(*network)->obj, &_xy, *npoints, *decay, *restarts, *wstep, *maxits, info, &_rep, &_alglib_env_state);
    x_set_mlpreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlptraines(const char **errormsg, x_multilayerperceptron** network, x_matrix* trnxy, ae_int_t* trnsize, x_matrix* valxy, ae_int_t* valsize, double* decay, ae_int_t* restarts, ae_int_t* info, x_mlpreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _trnxy;
    ae_matrix _valxy;
    mlpreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_trnxy, trnxy, &_alglib_env_state);
    ae_matrix_attach_to_x(&_valxy, valxy, &_alglib_env_state);
    _mlpreport_init(&_rep, &_alglib_env_state);
    mlptraines(&(*network)->obj, &_trnxy, *trnsize, &_valxy, *valsize, *decay, *restarts, info, &_rep, &_alglib_env_state);
    x_set_mlpreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpkfoldcvlbfgs(const char **errormsg, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints, double* decay, ae_int_t* restarts, double* wstep, ae_int_t* maxits, ae_int_t* foldscount, ae_int_t* info, x_mlpreport* rep, x_mlpcvreport* cvrep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    mlpreport _rep;
    mlpcvreport _cvrep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    _mlpreport_init(&_rep, &_alglib_env_state);
    _mlpcvreport_init(&_cvrep, &_alglib_env_state);
    mlpkfoldcvlbfgs(&(*network)->obj, &_xy, *npoints, *decay, *restarts, *wstep, *maxits, *foldscount, info, &_rep, &_cvrep, &_alglib_env_state);
    x_set_mlpreport(rep, &_rep, &_alglib_env_state);
    x_set_mlpcvreport(cvrep, &_cvrep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpkfoldcvlm(const char **errormsg, x_multilayerperceptron** network, x_matrix* xy, ae_int_t* npoints, double* decay, ae_int_t* restarts, ae_int_t* foldscount, ae_int_t* info, x_mlpreport* rep, x_mlpcvreport* cvrep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    mlpreport _rep;
    mlpcvreport _cvrep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    _mlpreport_init(&_rep, &_alglib_env_state);
    _mlpcvreport_init(&_cvrep, &_alglib_env_state);
    mlpkfoldcvlm(&(*network)->obj, &_xy, *npoints, *decay, *restarts, *foldscount, info, &_rep, &_cvrep, &_alglib_env_state);
    x_set_mlpreport(rep, &_rep, &_alglib_env_state);
    x_set_mlpcvreport(cvrep, &_cvrep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpkfoldcv(const char **errormsg, x_mlptrainer** s, x_multilayerperceptron** network, ae_int_t* nrestarts, ae_int_t* foldscount, x_mlpreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    mlpreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    _mlpreport_init(&_rep, &_alglib_env_state);
    mlpkfoldcv(&(*s)->obj, &(*network)->obj, *nrestarts, *foldscount, &_rep, &_alglib_env_state);
    x_set_mlpreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpkfoldcv(const char **errormsg, x_mlptrainer** s, x_multilayerperceptron** network, ae_int_t* nrestarts, ae_int_t* foldscount, x_mlpreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    mlpreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    _mlpreport_init(&_rep, &_alglib_env_state);
    _pexec_mlpkfoldcv(&(*s)->obj, &(*network)->obj, *nrestarts, *foldscount, &_rep, &_alglib_env_state);
    x_set_mlpreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcreatetrainer(const char **errormsg, ae_int_t* nin, ae_int_t* nout, x_mlptrainer** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *s = x_obj_alloc_mlptrainer(&_alglib_env_state);
    mlpcreatetrainer(*nin, *nout, &(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcreatetrainercls(const char **errormsg, ae_int_t* nin, ae_int_t* nclasses, x_mlptrainer** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *s = x_obj_alloc_mlptrainer(&_alglib_env_state);
    mlpcreatetrainercls(*nin, *nclasses, &(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpsetdataset(const char **errormsg, x_mlptrainer** s, x_matrix* xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    mlpsetdataset(&(*s)->obj, &_xy, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpsetsparsedataset(const char **errormsg, x_mlptrainer** s, x_sparsematrix** xy, ae_int_t* npoints)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpsetsparsedataset(&(*s)->obj, &(*xy)->obj, *npoints, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpsetdecay(const char **errormsg, x_mlptrainer** s, double* decay)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpsetdecay(&(*s)->obj, *decay, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpsetcond(const char **errormsg, x_mlptrainer** s, double* wstep, ae_int_t* maxits)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpsetcond(&(*s)->obj, *wstep, *maxits, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpsetalgobatch(const char **errormsg, x_mlptrainer** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpsetalgobatch(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlptrainnetwork(const char **errormsg, x_mlptrainer** s, x_multilayerperceptron** network, ae_int_t* nrestarts, x_mlpreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    mlpreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    _mlpreport_init(&_rep, &_alglib_env_state);
    mlptrainnetwork(&(*s)->obj, &(*network)->obj, *nrestarts, &_rep, &_alglib_env_state);
    x_set_mlpreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlptrainnetwork(const char **errormsg, x_mlptrainer** s, x_multilayerperceptron** network, ae_int_t* nrestarts, x_mlpreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    mlpreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    _mlpreport_init(&_rep, &_alglib_env_state);
    _pexec_mlptrainnetwork(&(*s)->obj, &(*network)->obj, *nrestarts, &_rep, &_alglib_env_state);
    x_set_mlpreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpstarttraining(const char **errormsg, x_mlptrainer** s, x_multilayerperceptron** network, bool8* randomstart)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    mlpstarttraining(&(*s)->obj, &(*network)->obj, *randomstart, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpcontinuetraining(const char **errormsg, bool8* result, x_mlptrainer** s, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = mlpcontinuetraining(&(*s)->obj, &(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlpcontinuetraining(const char **errormsg, bool8* result, x_mlptrainer** s, x_multilayerperceptron** network)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = _pexec_mlpcontinuetraining(&(*s)->obj, &(*network)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpebagginglm(const char **errormsg, x_mlpensemble** ensemble, x_matrix* xy, ae_int_t* npoints, double* decay, ae_int_t* restarts, ae_int_t* info, x_mlpreport* rep, x_mlpcvreport* ooberrors)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    mlpreport _rep;
    mlpcvreport _ooberrors;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    _mlpreport_init(&_rep, &_alglib_env_state);
    _mlpcvreport_init(&_ooberrors, &_alglib_env_state);
    mlpebagginglm(&(*ensemble)->obj, &_xy, *npoints, *decay, *restarts, info, &_rep, &_ooberrors, &_alglib_env_state);
    x_set_mlpreport(rep, &_rep, &_alglib_env_state);
    x_set_mlpcvreport(ooberrors, &_ooberrors, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpebagginglbfgs(const char **errormsg, x_mlpensemble** ensemble, x_matrix* xy, ae_int_t* npoints, double* decay, ae_int_t* restarts, double* wstep, ae_int_t* maxits, ae_int_t* info, x_mlpreport* rep, x_mlpcvreport* ooberrors)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    mlpreport _rep;
    mlpcvreport _ooberrors;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    _mlpreport_init(&_rep, &_alglib_env_state);
    _mlpcvreport_init(&_ooberrors, &_alglib_env_state);
    mlpebagginglbfgs(&(*ensemble)->obj, &_xy, *npoints, *decay, *restarts, *wstep, *maxits, info, &_rep, &_ooberrors, &_alglib_env_state);
    x_set_mlpreport(rep, &_rep, &_alglib_env_state);
    x_set_mlpcvreport(ooberrors, &_ooberrors, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlpetraines(const char **errormsg, x_mlpensemble** ensemble, x_matrix* xy, ae_int_t* npoints, double* decay, ae_int_t* restarts, ae_int_t* info, x_mlpreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    mlpreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    _mlpreport_init(&_rep, &_alglib_env_state);
    mlpetraines(&(*ensemble)->obj, &_xy, *npoints, *decay, *restarts, info, &_rep, &_alglib_env_state);
    x_set_mlpreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mlptrainensemblees(const char **errormsg, x_mlptrainer** s, x_mlpensemble** ensemble, ae_int_t* nrestarts, x_mlpreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    mlpreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    _mlpreport_init(&_rep, &_alglib_env_state);
    mlptrainensemblees(&(*s)->obj, &(*ensemble)->obj, *nrestarts, &_rep, &_alglib_env_state);
    x_set_mlpreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_mlptrainensemblees(const char **errormsg, x_mlptrainer** s, x_mlpensemble** ensemble, ae_int_t* nrestarts, x_mlpreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    mlpreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    _mlpreport_init(&_rep, &_alglib_env_state);
    _pexec_mlptrainensemblees(&(*s)->obj, &(*ensemble)->obj, *nrestarts, &_rep, &_alglib_env_state);
    x_set_mlpreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pcabuildbasis(const char **errormsg, x_matrix* x, ae_int_t* npoints, ae_int_t* nvars, ae_int_t* info, x_vector* s2, x_matrix* v)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_vector _s2;
    ae_matrix _v;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_init(&_s2, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_v, 0, 0, DT_REAL, &_alglib_env_state);
    pcabuildbasis(&_x, *npoints, *nvars, info, &_s2, &_v, &_alglib_env_state);
    ae_x_set_vector(s2, &_s2, &_alglib_env_state);
    ae_x_set_matrix(v, &_v, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED odesolverstate obj;
} x_odesolverstate;
x_odesolverstate* x_obj_alloc_odesolverstate(ae_state *_state)
{
    x_odesolverstate *result;
    result = ae_malloc(sizeof(x_odesolverstate), _state);
    _odesolverstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_odesolverstate* x_obj_copy_odesolverstate(x_odesolverstate *src)
{
    x_odesolverstate *result;
    result = ae_malloc(sizeof(x_odesolverstate), NULL);
    _odesolverstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_odesolverstate(x_odesolverstate *obj)
{
    if( obj==NULL )
        return;
    _odesolverstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT void x_odesolverstate_get_needdy(x_odesolverstate *obj, bool8 *result)
{
    *result = obj->obj.needdy;
}
DLLEXPORT void x_odesolverstate_set_needdy(x_odesolverstate *obj, bool8 *result)
{
    obj->obj.needdy = *result;
}
DLLEXPORT void x_odesolverstate_get_y(x_odesolverstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.y);
}
DLLEXPORT void x_odesolverstate_get_dy(x_odesolverstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.dy);
}
DLLEXPORT void x_odesolverstate_get_x(x_odesolverstate *obj, double *result)
{
    *result = obj->obj.x;
}
DLLEXPORT void x_odesolverstate_set_x(x_odesolverstate *obj, double *result)
{
    obj->obj.x = *result;
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t nfev;
    ALIGNED ae_int_t terminationtype;
} x_odesolverreport;
void x_set_odesolverreport(x_odesolverreport *dst, odesolverreport *src, ae_state *_state)
{
    dst->nfev = src->nfev;
    dst->terminationtype = src->terminationtype;
}
void odesolverreport_init_from_x(odesolverreport *dst, x_odesolverreport *src, ae_state *_state)
{
    dst->nfev = src->nfev;
    dst->terminationtype = src->terminationtype;
}
DLLEXPORT ae_int32_t alglib_odesolverrkck(const char **errormsg, x_vector* y, ae_int_t* n, x_vector* x, ae_int_t* m, double* eps, double* h, x_odesolverstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _y;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_odesolverstate(&_alglib_env_state);
    odesolverrkck(&_y, *n, &_x, *m, *eps, *h, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_odesolveriteration(const char **errormsg, bool8* result, x_odesolverstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = odesolveriteration(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_odesolverresults(const char **errormsg, x_odesolverstate** state, ae_int_t* m, x_vector* xtbl, x_matrix* ytbl, x_odesolverreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _xtbl;
    ae_matrix _ytbl;
    odesolverreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_xtbl, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_ytbl, 0, 0, DT_REAL, &_alglib_env_state);
    _odesolverreport_init(&_rep, &_alglib_env_state);
    odesolverresults(&(*state)->obj, m, &_xtbl, &_ytbl, &_rep, &_alglib_env_state);
    ae_x_set_vector(xtbl, &_xtbl, &_alglib_env_state);
    ae_x_set_matrix(ytbl, &_ytbl, &_alglib_env_state);
    x_set_odesolverreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_fftc1d(const char **errormsg, x_vector* a, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    fftc1d(&_a, *n, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_fftc1dinv(const char **errormsg, x_vector* a, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    fftc1dinv(&_a, *n, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_fftr1d(const char **errormsg, x_vector* a, ae_int_t* n, x_vector* f)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_vector _f;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_f, 0, DT_COMPLEX, &_alglib_env_state);
    fftr1d(&_a, *n, &_f, &_alglib_env_state);
    ae_x_set_vector(f, &_f, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_fftr1dinv(const char **errormsg, x_vector* f, ae_int_t* n, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _f;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_f, f, &_alglib_env_state);
    ae_vector_init(&_a, 0, DT_REAL, &_alglib_env_state);
    fftr1dinv(&_f, *n, &_a, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_convc1d(const char **errormsg, x_vector* a, ae_int_t* m, x_vector* b, ae_int_t* n, x_vector* r)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_vector _b;
    ae_vector _r;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    ae_vector_init(&_r, 0, DT_COMPLEX, &_alglib_env_state);
    convc1d(&_a, *m, &_b, *n, &_r, &_alglib_env_state);
    ae_x_set_vector(r, &_r, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_convc1dinv(const char **errormsg, x_vector* a, ae_int_t* m, x_vector* b, ae_int_t* n, x_vector* r)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_vector _b;
    ae_vector _r;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    ae_vector_init(&_r, 0, DT_COMPLEX, &_alglib_env_state);
    convc1dinv(&_a, *m, &_b, *n, &_r, &_alglib_env_state);
    ae_x_set_vector(r, &_r, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_convc1dcircular(const char **errormsg, x_vector* s, ae_int_t* m, x_vector* r, ae_int_t* n, x_vector* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _s;
    ae_vector _r;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_s, s, &_alglib_env_state);
    ae_vector_attach_to_x(&_r, r, &_alglib_env_state);
    ae_vector_init(&_c, 0, DT_COMPLEX, &_alglib_env_state);
    convc1dcircular(&_s, *m, &_r, *n, &_c, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_convc1dcircularinv(const char **errormsg, x_vector* a, ae_int_t* m, x_vector* b, ae_int_t* n, x_vector* r)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_vector _b;
    ae_vector _r;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    ae_vector_init(&_r, 0, DT_COMPLEX, &_alglib_env_state);
    convc1dcircularinv(&_a, *m, &_b, *n, &_r, &_alglib_env_state);
    ae_x_set_vector(r, &_r, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_convr1d(const char **errormsg, x_vector* a, ae_int_t* m, x_vector* b, ae_int_t* n, x_vector* r)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_vector _b;
    ae_vector _r;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    ae_vector_init(&_r, 0, DT_REAL, &_alglib_env_state);
    convr1d(&_a, *m, &_b, *n, &_r, &_alglib_env_state);
    ae_x_set_vector(r, &_r, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_convr1dinv(const char **errormsg, x_vector* a, ae_int_t* m, x_vector* b, ae_int_t* n, x_vector* r)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_vector _b;
    ae_vector _r;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    ae_vector_init(&_r, 0, DT_REAL, &_alglib_env_state);
    convr1dinv(&_a, *m, &_b, *n, &_r, &_alglib_env_state);
    ae_x_set_vector(r, &_r, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_convr1dcircular(const char **errormsg, x_vector* s, ae_int_t* m, x_vector* r, ae_int_t* n, x_vector* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _s;
    ae_vector _r;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_s, s, &_alglib_env_state);
    ae_vector_attach_to_x(&_r, r, &_alglib_env_state);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    convr1dcircular(&_s, *m, &_r, *n, &_c, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_convr1dcircularinv(const char **errormsg, x_vector* a, ae_int_t* m, x_vector* b, ae_int_t* n, x_vector* r)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_vector _b;
    ae_vector _r;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    ae_vector_init(&_r, 0, DT_REAL, &_alglib_env_state);
    convr1dcircularinv(&_a, *m, &_b, *n, &_r, &_alglib_env_state);
    ae_x_set_vector(r, &_r, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_corrc1d(const char **errormsg, x_vector* signal, ae_int_t* n, x_vector* pattern, ae_int_t* m, x_vector* r)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _signal;
    ae_vector _pattern;
    ae_vector _r;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_signal, signal, &_alglib_env_state);
    ae_vector_attach_to_x(&_pattern, pattern, &_alglib_env_state);
    ae_vector_init(&_r, 0, DT_COMPLEX, &_alglib_env_state);
    corrc1d(&_signal, *n, &_pattern, *m, &_r, &_alglib_env_state);
    ae_x_set_vector(r, &_r, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_corrc1dcircular(const char **errormsg, x_vector* signal, ae_int_t* m, x_vector* pattern, ae_int_t* n, x_vector* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _signal;
    ae_vector _pattern;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_signal, signal, &_alglib_env_state);
    ae_vector_attach_to_x(&_pattern, pattern, &_alglib_env_state);
    ae_vector_init(&_c, 0, DT_COMPLEX, &_alglib_env_state);
    corrc1dcircular(&_signal, *m, &_pattern, *n, &_c, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_corrr1d(const char **errormsg, x_vector* signal, ae_int_t* n, x_vector* pattern, ae_int_t* m, x_vector* r)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _signal;
    ae_vector _pattern;
    ae_vector _r;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_signal, signal, &_alglib_env_state);
    ae_vector_attach_to_x(&_pattern, pattern, &_alglib_env_state);
    ae_vector_init(&_r, 0, DT_REAL, &_alglib_env_state);
    corrr1d(&_signal, *n, &_pattern, *m, &_r, &_alglib_env_state);
    ae_x_set_vector(r, &_r, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_corrr1dcircular(const char **errormsg, x_vector* signal, ae_int_t* m, x_vector* pattern, ae_int_t* n, x_vector* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _signal;
    ae_vector _pattern;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_signal, signal, &_alglib_env_state);
    ae_vector_attach_to_x(&_pattern, pattern, &_alglib_env_state);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    corrr1dcircular(&_signal, *m, &_pattern, *n, &_c, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_fhtr1d(const char **errormsg, x_vector* a, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    fhtr1d(&_a, *n, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_fhtr1dinv(const char **errormsg, x_vector* a, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    fhtr1dinv(&_a, *n, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_gqgeneraterec(const char **errormsg, x_vector* alpha, x_vector* beta, double* mu0, ae_int_t* n, ae_int_t* info, x_vector* x, x_vector* w)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _alpha;
    ae_vector _beta;
    ae_vector _x;
    ae_vector _w;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_alpha, alpha, &_alglib_env_state);
    ae_vector_attach_to_x(&_beta, beta, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    gqgeneraterec(&_alpha, &_beta, *mu0, *n, info, &_x, &_w, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_gqgenerategausslobattorec(const char **errormsg, x_vector* alpha, x_vector* beta, double* mu0, double* a, double* b, ae_int_t* n, ae_int_t* info, x_vector* x, x_vector* w)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _alpha;
    ae_vector _beta;
    ae_vector _x;
    ae_vector _w;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_alpha, alpha, &_alglib_env_state);
    ae_vector_attach_to_x(&_beta, beta, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    gqgenerategausslobattorec(&_alpha, &_beta, *mu0, *a, *b, *n, info, &_x, &_w, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_gqgenerategaussradaurec(const char **errormsg, x_vector* alpha, x_vector* beta, double* mu0, double* a, ae_int_t* n, ae_int_t* info, x_vector* x, x_vector* w)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _alpha;
    ae_vector _beta;
    ae_vector _x;
    ae_vector _w;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_alpha, alpha, &_alglib_env_state);
    ae_vector_attach_to_x(&_beta, beta, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    gqgenerategaussradaurec(&_alpha, &_beta, *mu0, *a, *n, info, &_x, &_w, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_gqgenerategausslegendre(const char **errormsg, ae_int_t* n, ae_int_t* info, x_vector* x, x_vector* w)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _w;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    gqgenerategausslegendre(*n, info, &_x, &_w, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_gqgenerategaussjacobi(const char **errormsg, ae_int_t* n, double* alpha, double* beta, ae_int_t* info, x_vector* x, x_vector* w)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _w;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    gqgenerategaussjacobi(*n, *alpha, *beta, info, &_x, &_w, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_gqgenerategausslaguerre(const char **errormsg, ae_int_t* n, double* alpha, ae_int_t* info, x_vector* x, x_vector* w)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _w;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    gqgenerategausslaguerre(*n, *alpha, info, &_x, &_w, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_gqgenerategausshermite(const char **errormsg, ae_int_t* n, ae_int_t* info, x_vector* x, x_vector* w)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _w;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    gqgenerategausshermite(*n, info, &_x, &_w, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_gkqgeneraterec(const char **errormsg, x_vector* alpha, x_vector* beta, double* mu0, ae_int_t* n, ae_int_t* info, x_vector* x, x_vector* wkronrod, x_vector* wgauss)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _alpha;
    ae_vector _beta;
    ae_vector _x;
    ae_vector _wkronrod;
    ae_vector _wgauss;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_alpha, alpha, &_alglib_env_state);
    ae_vector_attach_to_x(&_beta, beta, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_wkronrod, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_wgauss, 0, DT_REAL, &_alglib_env_state);
    gkqgeneraterec(&_alpha, &_beta, *mu0, *n, info, &_x, &_wkronrod, &_wgauss, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_x_set_vector(wkronrod, &_wkronrod, &_alglib_env_state);
    ae_x_set_vector(wgauss, &_wgauss, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_gkqgenerategausslegendre(const char **errormsg, ae_int_t* n, ae_int_t* info, x_vector* x, x_vector* wkronrod, x_vector* wgauss)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _wkronrod;
    ae_vector _wgauss;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_wkronrod, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_wgauss, 0, DT_REAL, &_alglib_env_state);
    gkqgenerategausslegendre(*n, info, &_x, &_wkronrod, &_wgauss, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_x_set_vector(wkronrod, &_wkronrod, &_alglib_env_state);
    ae_x_set_vector(wgauss, &_wgauss, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_gkqgenerategaussjacobi(const char **errormsg, ae_int_t* n, double* alpha, double* beta, ae_int_t* info, x_vector* x, x_vector* wkronrod, x_vector* wgauss)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _wkronrod;
    ae_vector _wgauss;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_wkronrod, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_wgauss, 0, DT_REAL, &_alglib_env_state);
    gkqgenerategaussjacobi(*n, *alpha, *beta, info, &_x, &_wkronrod, &_wgauss, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_x_set_vector(wkronrod, &_wkronrod, &_alglib_env_state);
    ae_x_set_vector(wgauss, &_wgauss, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_gkqlegendrecalc(const char **errormsg, ae_int_t* n, ae_int_t* info, x_vector* x, x_vector* wkronrod, x_vector* wgauss)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _wkronrod;
    ae_vector _wgauss;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_wkronrod, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_wgauss, 0, DT_REAL, &_alglib_env_state);
    gkqlegendrecalc(*n, info, &_x, &_wkronrod, &_wgauss, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_x_set_vector(wkronrod, &_wkronrod, &_alglib_env_state);
    ae_x_set_vector(wgauss, &_wgauss, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_gkqlegendretbl(const char **errormsg, ae_int_t* n, x_vector* x, x_vector* wkronrod, x_vector* wgauss, double* eps)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _wkronrod;
    ae_vector _wgauss;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_wkronrod, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_wgauss, 0, DT_REAL, &_alglib_env_state);
    gkqlegendretbl(*n, &_x, &_wkronrod, &_wgauss, eps, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_x_set_vector(wkronrod, &_wkronrod, &_alglib_env_state);
    ae_x_set_vector(wgauss, &_wgauss, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t terminationtype;
    ALIGNED ae_int_t nfev;
    ALIGNED ae_int_t nintervals;
} x_autogkreport;
void x_set_autogkreport(x_autogkreport *dst, autogkreport *src, ae_state *_state)
{
    dst->terminationtype = src->terminationtype;
    dst->nfev = src->nfev;
    dst->nintervals = src->nintervals;
}
void autogkreport_init_from_x(autogkreport *dst, x_autogkreport *src, ae_state *_state)
{
    dst->terminationtype = src->terminationtype;
    dst->nfev = src->nfev;
    dst->nintervals = src->nintervals;
}
typedef ALIGNED struct
{
    ALIGNED autogkstate obj;
} x_autogkstate;
x_autogkstate* x_obj_alloc_autogkstate(ae_state *_state)
{
    x_autogkstate *result;
    result = ae_malloc(sizeof(x_autogkstate), _state);
    _autogkstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_autogkstate* x_obj_copy_autogkstate(x_autogkstate *src)
{
    x_autogkstate *result;
    result = ae_malloc(sizeof(x_autogkstate), NULL);
    _autogkstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_autogkstate(x_autogkstate *obj)
{
    if( obj==NULL )
        return;
    _autogkstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT void x_autogkstate_get_needf(x_autogkstate *obj, bool8 *result)
{
    *result = obj->obj.needf;
}
DLLEXPORT void x_autogkstate_set_needf(x_autogkstate *obj, bool8 *result)
{
    obj->obj.needf = *result;
}
DLLEXPORT void x_autogkstate_get_x(x_autogkstate *obj, double *result)
{
    *result = obj->obj.x;
}
DLLEXPORT void x_autogkstate_set_x(x_autogkstate *obj, double *result)
{
    obj->obj.x = *result;
}
DLLEXPORT void x_autogkstate_get_xminusa(x_autogkstate *obj, double *result)
{
    *result = obj->obj.xminusa;
}
DLLEXPORT void x_autogkstate_set_xminusa(x_autogkstate *obj, double *result)
{
    obj->obj.xminusa = *result;
}
DLLEXPORT void x_autogkstate_get_bminusx(x_autogkstate *obj, double *result)
{
    *result = obj->obj.bminusx;
}
DLLEXPORT void x_autogkstate_set_bminusx(x_autogkstate *obj, double *result)
{
    obj->obj.bminusx = *result;
}
DLLEXPORT void x_autogkstate_get_f(x_autogkstate *obj, double *result)
{
    *result = obj->obj.f;
}
DLLEXPORT void x_autogkstate_set_f(x_autogkstate *obj, double *result)
{
    obj->obj.f = *result;
}
DLLEXPORT ae_int32_t alglib_autogksmooth(const char **errormsg, double* a, double* b, x_autogkstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *state = x_obj_alloc_autogkstate(&_alglib_env_state);
    autogksmooth(*a, *b, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_autogksmoothw(const char **errormsg, double* a, double* b, double* xwidth, x_autogkstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *state = x_obj_alloc_autogkstate(&_alglib_env_state);
    autogksmoothw(*a, *b, *xwidth, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_autogksingular(const char **errormsg, double* a, double* b, double* alpha, double* beta, x_autogkstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *state = x_obj_alloc_autogkstate(&_alglib_env_state);
    autogksingular(*a, *b, *alpha, *beta, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_autogkiteration(const char **errormsg, bool8* result, x_autogkstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = autogkiteration(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_autogkresults(const char **errormsg, x_autogkstate** state, double* v, x_autogkreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    autogkreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    _autogkreport_init(&_rep, &_alglib_env_state);
    autogkresults(&(*state)->obj, v, &_rep, &_alglib_env_state);
    x_set_autogkreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED idwinterpolant obj;
} x_idwinterpolant;
x_idwinterpolant* x_obj_alloc_idwinterpolant(ae_state *_state)
{
    x_idwinterpolant *result;
    result = ae_malloc(sizeof(x_idwinterpolant), _state);
    _idwinterpolant_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_idwinterpolant* x_obj_copy_idwinterpolant(x_idwinterpolant *src)
{
    x_idwinterpolant *result;
    result = ae_malloc(sizeof(x_idwinterpolant), NULL);
    _idwinterpolant_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_idwinterpolant(x_idwinterpolant *obj)
{
    if( obj==NULL )
        return;
    _idwinterpolant_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT ae_int32_t alglib_idwcalc(const char **errormsg, double* result, x_idwinterpolant** z, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *result = idwcalc(&(*z)->obj, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_idwbuildmodifiedshepard(const char **errormsg, x_matrix* xy, ae_int_t* n, ae_int_t* nx, ae_int_t* d, ae_int_t* nq, ae_int_t* nw, x_idwinterpolant** z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *z = x_obj_alloc_idwinterpolant(&_alglib_env_state);
    idwbuildmodifiedshepard(&_xy, *n, *nx, *d, *nq, *nw, &(*z)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_idwbuildmodifiedshepardr(const char **errormsg, x_matrix* xy, ae_int_t* n, ae_int_t* nx, double* r, x_idwinterpolant** z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *z = x_obj_alloc_idwinterpolant(&_alglib_env_state);
    idwbuildmodifiedshepardr(&_xy, *n, *nx, *r, &(*z)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_idwbuildnoisy(const char **errormsg, x_matrix* xy, ae_int_t* n, ae_int_t* nx, ae_int_t* d, ae_int_t* nq, ae_int_t* nw, x_idwinterpolant** z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *z = x_obj_alloc_idwinterpolant(&_alglib_env_state);
    idwbuildnoisy(&_xy, *n, *nx, *d, *nq, *nw, &(*z)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED barycentricinterpolant obj;
} x_barycentricinterpolant;
x_barycentricinterpolant* x_obj_alloc_barycentricinterpolant(ae_state *_state)
{
    x_barycentricinterpolant *result;
    result = ae_malloc(sizeof(x_barycentricinterpolant), _state);
    _barycentricinterpolant_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_barycentricinterpolant* x_obj_copy_barycentricinterpolant(x_barycentricinterpolant *src)
{
    x_barycentricinterpolant *result;
    result = ae_malloc(sizeof(x_barycentricinterpolant), NULL);
    _barycentricinterpolant_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_barycentricinterpolant(x_barycentricinterpolant *obj)
{
    if( obj==NULL )
        return;
    _barycentricinterpolant_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT ae_int32_t alglib_barycentriccalc(const char **errormsg, double* result, x_barycentricinterpolant** b, double* t)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = barycentriccalc(&(*b)->obj, *t, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_barycentricdiff1(const char **errormsg, x_barycentricinterpolant** b, double* t, double* f, double* df)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    barycentricdiff1(&(*b)->obj, *t, f, df, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_barycentricdiff2(const char **errormsg, x_barycentricinterpolant** b, double* t, double* f, double* df, double* d2f)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    barycentricdiff2(&(*b)->obj, *t, f, df, d2f, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_barycentriclintransx(const char **errormsg, x_barycentricinterpolant** b, double* ca, double* cb)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    barycentriclintransx(&(*b)->obj, *ca, *cb, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_barycentriclintransy(const char **errormsg, x_barycentricinterpolant** b, double* ca, double* cb)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    barycentriclintransy(&(*b)->obj, *ca, *cb, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_barycentricunpack(const char **errormsg, x_barycentricinterpolant** b, ae_int_t* n, x_vector* x, x_vector* y, x_vector* w)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _w;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_y, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_w, 0, DT_REAL, &_alglib_env_state);
    barycentricunpack(&(*b)->obj, n, &_x, &_y, &_w, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_x_set_vector(w, &_w, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_barycentricbuildxyw(const char **errormsg, x_vector* x, x_vector* y, x_vector* w, ae_int_t* n, x_barycentricinterpolant** b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _w;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    *b = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    barycentricbuildxyw(&_x, &_y, &_w, *n, &(*b)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_barycentricbuildfloaterhormann(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* d, x_barycentricinterpolant** b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *b = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    barycentricbuildfloaterhormann(&_x, &_y, *n, *d, &(*b)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_polynomialbar2cheb(const char **errormsg, x_barycentricinterpolant** p, double* a, double* b, x_vector* t)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _t;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_t, 0, DT_REAL, &_alglib_env_state);
    polynomialbar2cheb(&(*p)->obj, *a, *b, &_t, &_alglib_env_state);
    ae_x_set_vector(t, &_t, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_polynomialcheb2bar(const char **errormsg, x_vector* t, ae_int_t* n, double* a, double* b, x_barycentricinterpolant** p)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _t;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_t, t, &_alglib_env_state);
    *p = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    polynomialcheb2bar(&_t, *n, *a, *b, &(*p)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_polynomialbar2pow(const char **errormsg, x_barycentricinterpolant** p, double* c, double* s, x_vector* a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_a, 0, DT_REAL, &_alglib_env_state);
    polynomialbar2pow(&(*p)->obj, *c, *s, &_a, &_alglib_env_state);
    ae_x_set_vector(a, &_a, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_polynomialpow2bar(const char **errormsg, x_vector* a, ae_int_t* n, double* c, double* s, x_barycentricinterpolant** p)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    *p = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    polynomialpow2bar(&_a, *n, *c, *s, &(*p)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_polynomialbuild(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, x_barycentricinterpolant** p)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *p = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    polynomialbuild(&_x, &_y, *n, &(*p)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_polynomialbuildeqdist(const char **errormsg, double* a, double* b, x_vector* y, ae_int_t* n, x_barycentricinterpolant** p)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *p = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    polynomialbuildeqdist(*a, *b, &_y, *n, &(*p)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_polynomialbuildcheb1(const char **errormsg, double* a, double* b, x_vector* y, ae_int_t* n, x_barycentricinterpolant** p)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *p = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    polynomialbuildcheb1(*a, *b, &_y, *n, &(*p)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_polynomialbuildcheb2(const char **errormsg, double* a, double* b, x_vector* y, ae_int_t* n, x_barycentricinterpolant** p)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *p = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    polynomialbuildcheb2(*a, *b, &_y, *n, &(*p)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_polynomialcalceqdist(const char **errormsg, double* result, double* a, double* b, x_vector* f, ae_int_t* n, double* t)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _f;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_f, f, &_alglib_env_state);
    *result = polynomialcalceqdist(*a, *b, &_f, *n, *t, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_polynomialcalccheb1(const char **errormsg, double* result, double* a, double* b, x_vector* f, ae_int_t* n, double* t)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _f;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_f, f, &_alglib_env_state);
    *result = polynomialcalccheb1(*a, *b, &_f, *n, *t, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_polynomialcalccheb2(const char **errormsg, double* result, double* a, double* b, x_vector* f, ae_int_t* n, double* t)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _f;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_f, f, &_alglib_env_state);
    *result = polynomialcalccheb2(*a, *b, &_f, *n, *t, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED spline1dinterpolant obj;
} x_spline1dinterpolant;
x_spline1dinterpolant* x_obj_alloc_spline1dinterpolant(ae_state *_state)
{
    x_spline1dinterpolant *result;
    result = ae_malloc(sizeof(x_spline1dinterpolant), _state);
    _spline1dinterpolant_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_spline1dinterpolant* x_obj_copy_spline1dinterpolant(x_spline1dinterpolant *src)
{
    x_spline1dinterpolant *result;
    result = ae_malloc(sizeof(x_spline1dinterpolant), NULL);
    _spline1dinterpolant_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_spline1dinterpolant(x_spline1dinterpolant *obj)
{
    if( obj==NULL )
        return;
    _spline1dinterpolant_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT ae_int32_t alglib_spline1dbuildlinear(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, x_spline1dinterpolant** c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *c = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    spline1dbuildlinear(&_x, &_y, *n, &(*c)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dbuildcubic(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* boundltype, double* boundl, ae_int_t* boundrtype, double* boundr, x_spline1dinterpolant** c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *c = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    spline1dbuildcubic(&_x, &_y, *n, *boundltype, *boundl, *boundrtype, *boundr, &(*c)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dgriddiffcubic(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* boundltype, double* boundl, ae_int_t* boundrtype, double* boundr, x_vector* d)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _d;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_init(&_d, 0, DT_REAL, &_alglib_env_state);
    spline1dgriddiffcubic(&_x, &_y, *n, *boundltype, *boundl, *boundrtype, *boundr, &_d, &_alglib_env_state);
    ae_x_set_vector(d, &_d, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dgriddiff2cubic(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* boundltype, double* boundl, ae_int_t* boundrtype, double* boundr, x_vector* d1, x_vector* d2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _d1;
    ae_vector _d2;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_init(&_d1, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_d2, 0, DT_REAL, &_alglib_env_state);
    spline1dgriddiff2cubic(&_x, &_y, *n, *boundltype, *boundl, *boundrtype, *boundr, &_d1, &_d2, &_alglib_env_state);
    ae_x_set_vector(d1, &_d1, &_alglib_env_state);
    ae_x_set_vector(d2, &_d2, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dconvcubic(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* boundltype, double* boundl, ae_int_t* boundrtype, double* boundr, x_vector* x2, ae_int_t* n2, x_vector* y2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _x2;
    ae_vector _y2;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_x2, x2, &_alglib_env_state);
    ae_vector_init(&_y2, 0, DT_REAL, &_alglib_env_state);
    spline1dconvcubic(&_x, &_y, *n, *boundltype, *boundl, *boundrtype, *boundr, &_x2, *n2, &_y2, &_alglib_env_state);
    ae_x_set_vector(y2, &_y2, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dconvdiffcubic(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* boundltype, double* boundl, ae_int_t* boundrtype, double* boundr, x_vector* x2, ae_int_t* n2, x_vector* y2, x_vector* d2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _x2;
    ae_vector _y2;
    ae_vector _d2;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_x2, x2, &_alglib_env_state);
    ae_vector_init(&_y2, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_d2, 0, DT_REAL, &_alglib_env_state);
    spline1dconvdiffcubic(&_x, &_y, *n, *boundltype, *boundl, *boundrtype, *boundr, &_x2, *n2, &_y2, &_d2, &_alglib_env_state);
    ae_x_set_vector(y2, &_y2, &_alglib_env_state);
    ae_x_set_vector(d2, &_d2, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dconvdiff2cubic(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* boundltype, double* boundl, ae_int_t* boundrtype, double* boundr, x_vector* x2, ae_int_t* n2, x_vector* y2, x_vector* d2, x_vector* dd2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _x2;
    ae_vector _y2;
    ae_vector _d2;
    ae_vector _dd2;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_x2, x2, &_alglib_env_state);
    ae_vector_init(&_y2, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_d2, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_dd2, 0, DT_REAL, &_alglib_env_state);
    spline1dconvdiff2cubic(&_x, &_y, *n, *boundltype, *boundl, *boundrtype, *boundr, &_x2, *n2, &_y2, &_d2, &_dd2, &_alglib_env_state);
    ae_x_set_vector(y2, &_y2, &_alglib_env_state);
    ae_x_set_vector(d2, &_d2, &_alglib_env_state);
    ae_x_set_vector(dd2, &_dd2, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dbuildcatmullrom(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* boundtype, double* tension, x_spline1dinterpolant** c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *c = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    spline1dbuildcatmullrom(&_x, &_y, *n, *boundtype, *tension, &(*c)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dbuildhermite(const char **errormsg, x_vector* x, x_vector* y, x_vector* d, ae_int_t* n, x_spline1dinterpolant** c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _d;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_d, d, &_alglib_env_state);
    *c = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    spline1dbuildhermite(&_x, &_y, &_d, *n, &(*c)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dbuildakima(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, x_spline1dinterpolant** c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *c = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    spline1dbuildakima(&_x, &_y, *n, &(*c)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dcalc(const char **errormsg, double* result, x_spline1dinterpolant** c, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = spline1dcalc(&(*c)->obj, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1ddiff(const char **errormsg, x_spline1dinterpolant** c, double* x, double* s, double* ds, double* d2s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    spline1ddiff(&(*c)->obj, *x, s, ds, d2s, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dunpack(const char **errormsg, x_spline1dinterpolant** c, ae_int_t* n, x_matrix* tbl)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _tbl;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_tbl, 0, 0, DT_REAL, &_alglib_env_state);
    spline1dunpack(&(*c)->obj, n, &_tbl, &_alglib_env_state);
    ae_x_set_matrix(tbl, &_tbl, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dlintransx(const char **errormsg, x_spline1dinterpolant** c, double* a, double* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    spline1dlintransx(&(*c)->obj, *a, *b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dlintransy(const char **errormsg, x_spline1dinterpolant** c, double* a, double* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    spline1dlintransy(&(*c)->obj, *a, *b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dintegrate(const char **errormsg, double* result, x_spline1dinterpolant** c, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = spline1dintegrate(&(*c)->obj, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dbuildmonotone(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, x_spline1dinterpolant** c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *c = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    spline1dbuildmonotone(&_x, &_y, *n, &(*c)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED normestimatorstate obj;
} x_normestimatorstate;
x_normestimatorstate* x_obj_alloc_normestimatorstate(ae_state *_state)
{
    x_normestimatorstate *result;
    result = ae_malloc(sizeof(x_normestimatorstate), _state);
    _normestimatorstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_normestimatorstate* x_obj_copy_normestimatorstate(x_normestimatorstate *src)
{
    x_normestimatorstate *result;
    result = ae_malloc(sizeof(x_normestimatorstate), NULL);
    _normestimatorstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_normestimatorstate(x_normestimatorstate *obj)
{
    if( obj==NULL )
        return;
    _normestimatorstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT ae_int32_t alglib_normestimatorcreate(const char **errormsg, ae_int_t* m, ae_int_t* n, ae_int_t* nstart, ae_int_t* nits, x_normestimatorstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *state = x_obj_alloc_normestimatorstate(&_alglib_env_state);
    normestimatorcreate(*m, *n, *nstart, *nits, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_normestimatorsetseed(const char **errormsg, x_normestimatorstate** state, ae_int_t* seedval)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    normestimatorsetseed(&(*state)->obj, *seedval, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_normestimatorestimatesparse(const char **errormsg, x_normestimatorstate** state, x_sparsematrix** a)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    normestimatorestimatesparse(&(*state)->obj, &(*a)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_normestimatorresults(const char **errormsg, x_normestimatorstate** state, double* nrm)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    normestimatorresults(&(*state)->obj, nrm, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED minqpstate obj;
} x_minqpstate;
x_minqpstate* x_obj_alloc_minqpstate(ae_state *_state)
{
    x_minqpstate *result;
    result = ae_malloc(sizeof(x_minqpstate), _state);
    _minqpstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_minqpstate* x_obj_copy_minqpstate(x_minqpstate *src)
{
    x_minqpstate *result;
    result = ae_malloc(sizeof(x_minqpstate), NULL);
    _minqpstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_minqpstate(x_minqpstate *obj)
{
    if( obj==NULL )
        return;
    _minqpstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t inneriterationscount;
    ALIGNED ae_int_t outeriterationscount;
    ALIGNED ae_int_t nmv;
    ALIGNED ae_int_t ncholesky;
    ALIGNED ae_int_t terminationtype;
} x_minqpreport;
void x_set_minqpreport(x_minqpreport *dst, minqpreport *src, ae_state *_state)
{
    dst->inneriterationscount = src->inneriterationscount;
    dst->outeriterationscount = src->outeriterationscount;
    dst->nmv = src->nmv;
    dst->ncholesky = src->ncholesky;
    dst->terminationtype = src->terminationtype;
}
void minqpreport_init_from_x(minqpreport *dst, x_minqpreport *src, ae_state *_state)
{
    dst->inneriterationscount = src->inneriterationscount;
    dst->outeriterationscount = src->outeriterationscount;
    dst->nmv = src->nmv;
    dst->ncholesky = src->ncholesky;
    dst->terminationtype = src->terminationtype;
}
DLLEXPORT ae_int32_t alglib_minqpcreate(const char **errormsg, ae_int_t* n, x_minqpstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *state = x_obj_alloc_minqpstate(&_alglib_env_state);
    minqpcreate(*n, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minqpsetlinearterm(const char **errormsg, x_minqpstate** state, x_vector* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    minqpsetlinearterm(&(*state)->obj, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minqpsetquadraticterm(const char **errormsg, x_minqpstate** state, x_matrix* a, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    minqpsetquadraticterm(&(*state)->obj, &_a, *isupper, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minqpsetquadratictermsparse(const char **errormsg, x_minqpstate** state, x_sparsematrix** a, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minqpsetquadratictermsparse(&(*state)->obj, &(*a)->obj, *isupper, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minqpsetstartingpoint(const char **errormsg, x_minqpstate** state, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    minqpsetstartingpoint(&(*state)->obj, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minqpsetorigin(const char **errormsg, x_minqpstate** state, x_vector* xorigin)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _xorigin;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_xorigin, xorigin, &_alglib_env_state);
    minqpsetorigin(&(*state)->obj, &_xorigin, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minqpsetscale(const char **errormsg, x_minqpstate** state, x_vector* s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _s;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_s, s, &_alglib_env_state);
    minqpsetscale(&(*state)->obj, &_s, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minqpsetalgocholesky(const char **errormsg, x_minqpstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minqpsetalgocholesky(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minqpsetalgobleic(const char **errormsg, x_minqpstate** state, double* epsg, double* epsf, double* epsx, ae_int_t* maxits)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minqpsetalgobleic(&(*state)->obj, *epsg, *epsf, *epsx, *maxits, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minqpsetalgoquickqp(const char **errormsg, x_minqpstate** state, double* epsg, double* epsf, double* epsx, ae_int_t* maxouterits, bool8* usenewton)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minqpsetalgoquickqp(&(*state)->obj, *epsg, *epsf, *epsx, *maxouterits, *usenewton, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minqpsetbc(const char **errormsg, x_minqpstate** state, x_vector* bndl, x_vector* bndu)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _bndl;
    ae_vector _bndu;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_bndl, bndl, &_alglib_env_state);
    ae_vector_attach_to_x(&_bndu, bndu, &_alglib_env_state);
    minqpsetbc(&(*state)->obj, &_bndl, &_bndu, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minqpsetlc(const char **errormsg, x_minqpstate** state, x_matrix* c, x_vector* ct, ae_int_t* k)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _c;
    ae_vector _ct;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    ae_vector_attach_to_x(&_ct, ct, &_alglib_env_state);
    minqpsetlc(&(*state)->obj, &_c, &_ct, *k, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minqpoptimize(const char **errormsg, x_minqpstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minqpoptimize(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minqpresults(const char **errormsg, x_minqpstate** state, x_vector* x, x_minqpreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    minqpreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    _minqpreport_init(&_rep, &_alglib_env_state);
    minqpresults(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_minqpreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minqpresultsbuf(const char **errormsg, x_minqpstate** state, x_vector* x, x_minqpreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    minqpreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    minqpreport_init_from_x(&_rep, rep, &_alglib_env_state);
    minqpresultsbuf(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_minqpreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED minlmstate obj;
} x_minlmstate;
x_minlmstate* x_obj_alloc_minlmstate(ae_state *_state)
{
    x_minlmstate *result;
    result = ae_malloc(sizeof(x_minlmstate), _state);
    _minlmstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_minlmstate* x_obj_copy_minlmstate(x_minlmstate *src)
{
    x_minlmstate *result;
    result = ae_malloc(sizeof(x_minlmstate), NULL);
    _minlmstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_minlmstate(x_minlmstate *obj)
{
    if( obj==NULL )
        return;
    _minlmstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT void x_minlmstate_get_needf(x_minlmstate *obj, bool8 *result)
{
    *result = obj->obj.needf;
}
DLLEXPORT void x_minlmstate_set_needf(x_minlmstate *obj, bool8 *result)
{
    obj->obj.needf = *result;
}
DLLEXPORT void x_minlmstate_get_needfg(x_minlmstate *obj, bool8 *result)
{
    *result = obj->obj.needfg;
}
DLLEXPORT void x_minlmstate_set_needfg(x_minlmstate *obj, bool8 *result)
{
    obj->obj.needfg = *result;
}
DLLEXPORT void x_minlmstate_get_needfgh(x_minlmstate *obj, bool8 *result)
{
    *result = obj->obj.needfgh;
}
DLLEXPORT void x_minlmstate_set_needfgh(x_minlmstate *obj, bool8 *result)
{
    obj->obj.needfgh = *result;
}
DLLEXPORT void x_minlmstate_get_needfi(x_minlmstate *obj, bool8 *result)
{
    *result = obj->obj.needfi;
}
DLLEXPORT void x_minlmstate_set_needfi(x_minlmstate *obj, bool8 *result)
{
    obj->obj.needfi = *result;
}
DLLEXPORT void x_minlmstate_get_needfij(x_minlmstate *obj, bool8 *result)
{
    *result = obj->obj.needfij;
}
DLLEXPORT void x_minlmstate_set_needfij(x_minlmstate *obj, bool8 *result)
{
    obj->obj.needfij = *result;
}
DLLEXPORT void x_minlmstate_get_xupdated(x_minlmstate *obj, bool8 *result)
{
    *result = obj->obj.xupdated;
}
DLLEXPORT void x_minlmstate_set_xupdated(x_minlmstate *obj, bool8 *result)
{
    obj->obj.xupdated = *result;
}
DLLEXPORT void x_minlmstate_get_f(x_minlmstate *obj, double *result)
{
    *result = obj->obj.f;
}
DLLEXPORT void x_minlmstate_set_f(x_minlmstate *obj, double *result)
{
    obj->obj.f = *result;
}
DLLEXPORT void x_minlmstate_get_fi(x_minlmstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.fi);
}
DLLEXPORT void x_minlmstate_get_g(x_minlmstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.g);
}
DLLEXPORT void x_minlmstate_get_h(x_minlmstate *obj, x_matrix *result)
{
    ae_x_attach_to_matrix(result, &obj->obj.h);
}
DLLEXPORT void x_minlmstate_get_j(x_minlmstate *obj, x_matrix *result)
{
    ae_x_attach_to_matrix(result, &obj->obj.j);
}
DLLEXPORT void x_minlmstate_get_x(x_minlmstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.x);
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t iterationscount;
    ALIGNED ae_int_t terminationtype;
    ALIGNED ae_int_t funcidx;
    ALIGNED ae_int_t varidx;
    ALIGNED ae_int_t nfunc;
    ALIGNED ae_int_t njac;
    ALIGNED ae_int_t ngrad;
    ALIGNED ae_int_t nhess;
    ALIGNED ae_int_t ncholesky;
} x_minlmreport;
void x_set_minlmreport(x_minlmreport *dst, minlmreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->terminationtype = src->terminationtype;
    dst->funcidx = src->funcidx;
    dst->varidx = src->varidx;
    dst->nfunc = src->nfunc;
    dst->njac = src->njac;
    dst->ngrad = src->ngrad;
    dst->nhess = src->nhess;
    dst->ncholesky = src->ncholesky;
}
void minlmreport_init_from_x(minlmreport *dst, x_minlmreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->terminationtype = src->terminationtype;
    dst->funcidx = src->funcidx;
    dst->varidx = src->varidx;
    dst->nfunc = src->nfunc;
    dst->njac = src->njac;
    dst->ngrad = src->ngrad;
    dst->nhess = src->nhess;
    dst->ncholesky = src->ncholesky;
}
DLLEXPORT ae_int32_t alglib_minlmcreatevj(const char **errormsg, ae_int_t* n, ae_int_t* m, x_vector* x, x_minlmstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_minlmstate(&_alglib_env_state);
    minlmcreatevj(*n, *m, &_x, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmcreatev(const char **errormsg, ae_int_t* n, ae_int_t* m, x_vector* x, double* diffstep, x_minlmstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_minlmstate(&_alglib_env_state);
    minlmcreatev(*n, *m, &_x, *diffstep, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmcreatefgh(const char **errormsg, ae_int_t* n, x_vector* x, x_minlmstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_minlmstate(&_alglib_env_state);
    minlmcreatefgh(*n, &_x, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmsetcond(const char **errormsg, x_minlmstate** state, double* epsg, double* epsf, double* epsx, ae_int_t* maxits)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minlmsetcond(&(*state)->obj, *epsg, *epsf, *epsx, *maxits, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmsetxrep(const char **errormsg, x_minlmstate** state, bool8* needxrep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minlmsetxrep(&(*state)->obj, *needxrep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmsetstpmax(const char **errormsg, x_minlmstate** state, double* stpmax)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minlmsetstpmax(&(*state)->obj, *stpmax, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmsetscale(const char **errormsg, x_minlmstate** state, x_vector* s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _s;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_s, s, &_alglib_env_state);
    minlmsetscale(&(*state)->obj, &_s, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmsetbc(const char **errormsg, x_minlmstate** state, x_vector* bndl, x_vector* bndu)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _bndl;
    ae_vector _bndu;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_bndl, bndl, &_alglib_env_state);
    ae_vector_attach_to_x(&_bndu, bndu, &_alglib_env_state);
    minlmsetbc(&(*state)->obj, &_bndl, &_bndu, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmsetacctype(const char **errormsg, x_minlmstate** state, ae_int_t* acctype)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minlmsetacctype(&(*state)->obj, *acctype, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmiteration(const char **errormsg, bool8* result, x_minlmstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = minlmiteration(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmresults(const char **errormsg, x_minlmstate** state, x_vector* x, x_minlmreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    minlmreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    _minlmreport_init(&_rep, &_alglib_env_state);
    minlmresults(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_minlmreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmresultsbuf(const char **errormsg, x_minlmstate** state, x_vector* x, x_minlmreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    minlmreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    minlmreport_init_from_x(&_rep, rep, &_alglib_env_state);
    minlmresultsbuf(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_minlmreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmrestartfrom(const char **errormsg, x_minlmstate** state, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    minlmrestartfrom(&(*state)->obj, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmrequesttermination(const char **errormsg, x_minlmstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minlmrequesttermination(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmcreatevgj(const char **errormsg, ae_int_t* n, ae_int_t* m, x_vector* x, x_minlmstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_minlmstate(&_alglib_env_state);
    minlmcreatevgj(*n, *m, &_x, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmcreatefgj(const char **errormsg, ae_int_t* n, ae_int_t* m, x_vector* x, x_minlmstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_minlmstate(&_alglib_env_state);
    minlmcreatefgj(*n, *m, &_x, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmcreatefj(const char **errormsg, ae_int_t* n, ae_int_t* m, x_vector* x, x_minlmstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_minlmstate(&_alglib_env_state);
    minlmcreatefj(*n, *m, &_x, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlmsetgradientcheck(const char **errormsg, x_minlmstate** state, double* teststep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minlmsetgradientcheck(&(*state)->obj, *teststep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED double taskrcond;
    ALIGNED double rmserror;
    ALIGNED double avgerror;
    ALIGNED double avgrelerror;
    ALIGNED double maxerror;
} x_polynomialfitreport;
void x_set_polynomialfitreport(x_polynomialfitreport *dst, polynomialfitreport *src, ae_state *_state)
{
    dst->taskrcond = src->taskrcond;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
    dst->maxerror = src->maxerror;
}
void polynomialfitreport_init_from_x(polynomialfitreport *dst, x_polynomialfitreport *src, ae_state *_state)
{
    dst->taskrcond = src->taskrcond;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
    dst->maxerror = src->maxerror;
}
typedef ALIGNED struct
{
    ALIGNED double taskrcond;
    ALIGNED ae_int_t dbest;
    ALIGNED double rmserror;
    ALIGNED double avgerror;
    ALIGNED double avgrelerror;
    ALIGNED double maxerror;
} x_barycentricfitreport;
void x_set_barycentricfitreport(x_barycentricfitreport *dst, barycentricfitreport *src, ae_state *_state)
{
    dst->taskrcond = src->taskrcond;
    dst->dbest = src->dbest;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
    dst->maxerror = src->maxerror;
}
void barycentricfitreport_init_from_x(barycentricfitreport *dst, x_barycentricfitreport *src, ae_state *_state)
{
    dst->taskrcond = src->taskrcond;
    dst->dbest = src->dbest;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
    dst->maxerror = src->maxerror;
}
typedef ALIGNED struct
{
    ALIGNED double taskrcond;
    ALIGNED double rmserror;
    ALIGNED double avgerror;
    ALIGNED double avgrelerror;
    ALIGNED double maxerror;
} x_spline1dfitreport;
void x_set_spline1dfitreport(x_spline1dfitreport *dst, spline1dfitreport *src, ae_state *_state)
{
    dst->taskrcond = src->taskrcond;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
    dst->maxerror = src->maxerror;
}
void spline1dfitreport_init_from_x(spline1dfitreport *dst, x_spline1dfitreport *src, ae_state *_state)
{
    dst->taskrcond = src->taskrcond;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
    dst->maxerror = src->maxerror;
}
typedef ALIGNED struct
{
    ALIGNED double taskrcond;
    ALIGNED ae_int_t iterationscount;
    ALIGNED ae_int_t varidx;
    ALIGNED double rmserror;
    ALIGNED double avgerror;
    ALIGNED double avgrelerror;
    ALIGNED double maxerror;
    ALIGNED double wrmserror;
    ALIGNED x_matrix covpar;
    ALIGNED x_vector errpar;
    ALIGNED x_vector errcurve;
    ALIGNED x_vector noise;
    ALIGNED double r2;
} x_lsfitreport;
void x_set_lsfitreport(x_lsfitreport *dst, lsfitreport *src, ae_state *_state)
{
    dst->taskrcond = src->taskrcond;
    dst->iterationscount = src->iterationscount;
    dst->varidx = src->varidx;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
    dst->maxerror = src->maxerror;
    dst->wrmserror = src->wrmserror;
    ae_x_set_matrix(&dst->covpar, &src->covpar, _state);
    ae_x_set_vector(&dst->errpar, &src->errpar, _state);
    ae_x_set_vector(&dst->errcurve, &src->errcurve, _state);
    ae_x_set_vector(&dst->noise, &src->noise, _state);
    dst->r2 = src->r2;
}
void lsfitreport_init_from_x(lsfitreport *dst, x_lsfitreport *src, ae_state *_state)
{
    dst->taskrcond = src->taskrcond;
    dst->iterationscount = src->iterationscount;
    dst->varidx = src->varidx;
    dst->rmserror = src->rmserror;
    dst->avgerror = src->avgerror;
    dst->avgrelerror = src->avgrelerror;
    dst->maxerror = src->maxerror;
    dst->wrmserror = src->wrmserror;
    ae_matrix_init_from_x(&dst->covpar, &src->covpar, _state);
    ae_vector_init_from_x(&dst->errpar, &src->errpar, _state);
    ae_vector_init_from_x(&dst->errcurve, &src->errcurve, _state);
    ae_vector_init_from_x(&dst->noise, &src->noise, _state);
    dst->r2 = src->r2;
}
typedef ALIGNED struct
{
    ALIGNED lsfitstate obj;
} x_lsfitstate;
x_lsfitstate* x_obj_alloc_lsfitstate(ae_state *_state)
{
    x_lsfitstate *result;
    result = ae_malloc(sizeof(x_lsfitstate), _state);
    _lsfitstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_lsfitstate* x_obj_copy_lsfitstate(x_lsfitstate *src)
{
    x_lsfitstate *result;
    result = ae_malloc(sizeof(x_lsfitstate), NULL);
    _lsfitstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_lsfitstate(x_lsfitstate *obj)
{
    if( obj==NULL )
        return;
    _lsfitstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT void x_lsfitstate_get_needf(x_lsfitstate *obj, bool8 *result)
{
    *result = obj->obj.needf;
}
DLLEXPORT void x_lsfitstate_set_needf(x_lsfitstate *obj, bool8 *result)
{
    obj->obj.needf = *result;
}
DLLEXPORT void x_lsfitstate_get_needfg(x_lsfitstate *obj, bool8 *result)
{
    *result = obj->obj.needfg;
}
DLLEXPORT void x_lsfitstate_set_needfg(x_lsfitstate *obj, bool8 *result)
{
    obj->obj.needfg = *result;
}
DLLEXPORT void x_lsfitstate_get_needfgh(x_lsfitstate *obj, bool8 *result)
{
    *result = obj->obj.needfgh;
}
DLLEXPORT void x_lsfitstate_set_needfgh(x_lsfitstate *obj, bool8 *result)
{
    obj->obj.needfgh = *result;
}
DLLEXPORT void x_lsfitstate_get_xupdated(x_lsfitstate *obj, bool8 *result)
{
    *result = obj->obj.xupdated;
}
DLLEXPORT void x_lsfitstate_set_xupdated(x_lsfitstate *obj, bool8 *result)
{
    obj->obj.xupdated = *result;
}
DLLEXPORT void x_lsfitstate_get_c(x_lsfitstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.c);
}
DLLEXPORT void x_lsfitstate_get_f(x_lsfitstate *obj, double *result)
{
    *result = obj->obj.f;
}
DLLEXPORT void x_lsfitstate_set_f(x_lsfitstate *obj, double *result)
{
    obj->obj.f = *result;
}
DLLEXPORT void x_lsfitstate_get_g(x_lsfitstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.g);
}
DLLEXPORT void x_lsfitstate_get_h(x_lsfitstate *obj, x_matrix *result)
{
    ae_x_attach_to_matrix(result, &obj->obj.h);
}
DLLEXPORT void x_lsfitstate_get_x(x_lsfitstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.x);
}
DLLEXPORT ae_int32_t alglib_lstfitpiecewiselinearrdpfixed(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* m, x_vector* x2, x_vector* y2, ae_int_t* nsections)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _x2;
    ae_vector _y2;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_init(&_x2, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_y2, 0, DT_REAL, &_alglib_env_state);
    lstfitpiecewiselinearrdpfixed(&_x, &_y, *n, *m, &_x2, &_y2, nsections, &_alglib_env_state);
    ae_x_set_vector(x2, &_x2, &_alglib_env_state);
    ae_x_set_vector(y2, &_y2, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lstfitpiecewiselinearrdp(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, double* eps, x_vector* x2, x_vector* y2, ae_int_t* nsections)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _x2;
    ae_vector _y2;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_init(&_x2, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_y2, 0, DT_REAL, &_alglib_env_state);
    lstfitpiecewiselinearrdp(&_x, &_y, *n, *eps, &_x2, &_y2, nsections, &_alglib_env_state);
    ae_x_set_vector(x2, &_x2, &_alglib_env_state);
    ae_x_set_vector(y2, &_y2, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_polynomialfit(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* m, ae_int_t* info, x_barycentricinterpolant** p, x_polynomialfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    polynomialfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *p = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    _polynomialfitreport_init(&_rep, &_alglib_env_state);
    polynomialfit(&_x, &_y, *n, *m, info, &(*p)->obj, &_rep, &_alglib_env_state);
    x_set_polynomialfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_polynomialfit(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* m, ae_int_t* info, x_barycentricinterpolant** p, x_polynomialfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    polynomialfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *p = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    _polynomialfitreport_init(&_rep, &_alglib_env_state);
    _pexec_polynomialfit(&_x, &_y, *n, *m, info, &(*p)->obj, &_rep, &_alglib_env_state);
    x_set_polynomialfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_polynomialfitwc(const char **errormsg, x_vector* x, x_vector* y, x_vector* w, ae_int_t* n, x_vector* xc, x_vector* yc, x_vector* dc, ae_int_t* k, ae_int_t* m, ae_int_t* info, x_barycentricinterpolant** p, x_polynomialfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _w;
    ae_vector _xc;
    ae_vector _yc;
    ae_vector _dc;
    polynomialfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_vector_attach_to_x(&_xc, xc, &_alglib_env_state);
    ae_vector_attach_to_x(&_yc, yc, &_alglib_env_state);
    ae_vector_attach_to_x(&_dc, dc, &_alglib_env_state);
    *p = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    _polynomialfitreport_init(&_rep, &_alglib_env_state);
    polynomialfitwc(&_x, &_y, &_w, *n, &_xc, &_yc, &_dc, *k, *m, info, &(*p)->obj, &_rep, &_alglib_env_state);
    x_set_polynomialfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_polynomialfitwc(const char **errormsg, x_vector* x, x_vector* y, x_vector* w, ae_int_t* n, x_vector* xc, x_vector* yc, x_vector* dc, ae_int_t* k, ae_int_t* m, ae_int_t* info, x_barycentricinterpolant** p, x_polynomialfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _w;
    ae_vector _xc;
    ae_vector _yc;
    ae_vector _dc;
    polynomialfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_vector_attach_to_x(&_xc, xc, &_alglib_env_state);
    ae_vector_attach_to_x(&_yc, yc, &_alglib_env_state);
    ae_vector_attach_to_x(&_dc, dc, &_alglib_env_state);
    *p = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    _polynomialfitreport_init(&_rep, &_alglib_env_state);
    _pexec_polynomialfitwc(&_x, &_y, &_w, *n, &_xc, &_yc, &_dc, *k, *m, info, &(*p)->obj, &_rep, &_alglib_env_state);
    x_set_polynomialfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_logisticcalc4(const char **errormsg, double* result, double* x, double* a, double* b, double* c, double* d)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = logisticcalc4(*x, *a, *b, *c, *d, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_logisticcalc5(const char **errormsg, double* result, double* x, double* a, double* b, double* c, double* d, double* g)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = logisticcalc5(*x, *a, *b, *c, *d, *g, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_logisticfit4(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, double* a, double* b, double* c, double* d, x_lsfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    lsfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    _lsfitreport_init(&_rep, &_alglib_env_state);
    logisticfit4(&_x, &_y, *n, a, b, c, d, &_rep, &_alglib_env_state);
    x_set_lsfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_logisticfit4ec(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, double* cnstrleft, double* cnstrright, double* a, double* b, double* c, double* d, x_lsfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    lsfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    _lsfitreport_init(&_rep, &_alglib_env_state);
    logisticfit4ec(&_x, &_y, *n, *cnstrleft, *cnstrright, a, b, c, d, &_rep, &_alglib_env_state);
    x_set_lsfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_logisticfit5(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, double* a, double* b, double* c, double* d, double* g, x_lsfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    lsfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    _lsfitreport_init(&_rep, &_alglib_env_state);
    logisticfit5(&_x, &_y, *n, a, b, c, d, g, &_rep, &_alglib_env_state);
    x_set_lsfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_logisticfit5ec(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, double* cnstrleft, double* cnstrright, double* a, double* b, double* c, double* d, double* g, x_lsfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    lsfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    _lsfitreport_init(&_rep, &_alglib_env_state);
    logisticfit5ec(&_x, &_y, *n, *cnstrleft, *cnstrright, a, b, c, d, g, &_rep, &_alglib_env_state);
    x_set_lsfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_logisticfit45x(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, double* cnstrleft, double* cnstrright, bool8* is4pl, double* lambdav, double* epsx, ae_int_t* rscnt, double* a, double* b, double* c, double* d, double* g, x_lsfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    lsfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    _lsfitreport_init(&_rep, &_alglib_env_state);
    logisticfit45x(&_x, &_y, *n, *cnstrleft, *cnstrright, *is4pl, *lambdav, *epsx, *rscnt, a, b, c, d, g, &_rep, &_alglib_env_state);
    x_set_lsfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_barycentricfitfloaterhormannwc(const char **errormsg, x_vector* x, x_vector* y, x_vector* w, ae_int_t* n, x_vector* xc, x_vector* yc, x_vector* dc, ae_int_t* k, ae_int_t* m, ae_int_t* info, x_barycentricinterpolant** b, x_barycentricfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _w;
    ae_vector _xc;
    ae_vector _yc;
    ae_vector _dc;
    barycentricfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_vector_attach_to_x(&_xc, xc, &_alglib_env_state);
    ae_vector_attach_to_x(&_yc, yc, &_alglib_env_state);
    ae_vector_attach_to_x(&_dc, dc, &_alglib_env_state);
    *b = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    _barycentricfitreport_init(&_rep, &_alglib_env_state);
    barycentricfitfloaterhormannwc(&_x, &_y, &_w, *n, &_xc, &_yc, &_dc, *k, *m, info, &(*b)->obj, &_rep, &_alglib_env_state);
    x_set_barycentricfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_barycentricfitfloaterhormannwc(const char **errormsg, x_vector* x, x_vector* y, x_vector* w, ae_int_t* n, x_vector* xc, x_vector* yc, x_vector* dc, ae_int_t* k, ae_int_t* m, ae_int_t* info, x_barycentricinterpolant** b, x_barycentricfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _w;
    ae_vector _xc;
    ae_vector _yc;
    ae_vector _dc;
    barycentricfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_vector_attach_to_x(&_xc, xc, &_alglib_env_state);
    ae_vector_attach_to_x(&_yc, yc, &_alglib_env_state);
    ae_vector_attach_to_x(&_dc, dc, &_alglib_env_state);
    *b = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    _barycentricfitreport_init(&_rep, &_alglib_env_state);
    _pexec_barycentricfitfloaterhormannwc(&_x, &_y, &_w, *n, &_xc, &_yc, &_dc, *k, *m, info, &(*b)->obj, &_rep, &_alglib_env_state);
    x_set_barycentricfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_barycentricfitfloaterhormann(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* m, ae_int_t* info, x_barycentricinterpolant** b, x_barycentricfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    barycentricfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *b = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    _barycentricfitreport_init(&_rep, &_alglib_env_state);
    barycentricfitfloaterhormann(&_x, &_y, *n, *m, info, &(*b)->obj, &_rep, &_alglib_env_state);
    x_set_barycentricfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_barycentricfitfloaterhormann(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* m, ae_int_t* info, x_barycentricinterpolant** b, x_barycentricfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    barycentricfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *b = x_obj_alloc_barycentricinterpolant(&_alglib_env_state);
    _barycentricfitreport_init(&_rep, &_alglib_env_state);
    _pexec_barycentricfitfloaterhormann(&_x, &_y, *n, *m, info, &(*b)->obj, &_rep, &_alglib_env_state);
    x_set_barycentricfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dfitpenalized(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* m, double* rho, ae_int_t* info, x_spline1dinterpolant** s, x_spline1dfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    spline1dfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *s = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    _spline1dfitreport_init(&_rep, &_alglib_env_state);
    spline1dfitpenalized(&_x, &_y, *n, *m, *rho, info, &(*s)->obj, &_rep, &_alglib_env_state);
    x_set_spline1dfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spline1dfitpenalized(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* m, double* rho, ae_int_t* info, x_spline1dinterpolant** s, x_spline1dfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    spline1dfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *s = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    _spline1dfitreport_init(&_rep, &_alglib_env_state);
    _pexec_spline1dfitpenalized(&_x, &_y, *n, *m, *rho, info, &(*s)->obj, &_rep, &_alglib_env_state);
    x_set_spline1dfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dfitpenalizedw(const char **errormsg, x_vector* x, x_vector* y, x_vector* w, ae_int_t* n, ae_int_t* m, double* rho, ae_int_t* info, x_spline1dinterpolant** s, x_spline1dfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _w;
    spline1dfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    *s = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    _spline1dfitreport_init(&_rep, &_alglib_env_state);
    spline1dfitpenalizedw(&_x, &_y, &_w, *n, *m, *rho, info, &(*s)->obj, &_rep, &_alglib_env_state);
    x_set_spline1dfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spline1dfitpenalizedw(const char **errormsg, x_vector* x, x_vector* y, x_vector* w, ae_int_t* n, ae_int_t* m, double* rho, ae_int_t* info, x_spline1dinterpolant** s, x_spline1dfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _w;
    spline1dfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    *s = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    _spline1dfitreport_init(&_rep, &_alglib_env_state);
    _pexec_spline1dfitpenalizedw(&_x, &_y, &_w, *n, *m, *rho, info, &(*s)->obj, &_rep, &_alglib_env_state);
    x_set_spline1dfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dfitcubicwc(const char **errormsg, x_vector* x, x_vector* y, x_vector* w, ae_int_t* n, x_vector* xc, x_vector* yc, x_vector* dc, ae_int_t* k, ae_int_t* m, ae_int_t* info, x_spline1dinterpolant** s, x_spline1dfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _w;
    ae_vector _xc;
    ae_vector _yc;
    ae_vector _dc;
    spline1dfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_vector_attach_to_x(&_xc, xc, &_alglib_env_state);
    ae_vector_attach_to_x(&_yc, yc, &_alglib_env_state);
    ae_vector_attach_to_x(&_dc, dc, &_alglib_env_state);
    *s = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    _spline1dfitreport_init(&_rep, &_alglib_env_state);
    spline1dfitcubicwc(&_x, &_y, &_w, *n, &_xc, &_yc, &_dc, *k, *m, info, &(*s)->obj, &_rep, &_alglib_env_state);
    x_set_spline1dfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spline1dfitcubicwc(const char **errormsg, x_vector* x, x_vector* y, x_vector* w, ae_int_t* n, x_vector* xc, x_vector* yc, x_vector* dc, ae_int_t* k, ae_int_t* m, ae_int_t* info, x_spline1dinterpolant** s, x_spline1dfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _w;
    ae_vector _xc;
    ae_vector _yc;
    ae_vector _dc;
    spline1dfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_vector_attach_to_x(&_xc, xc, &_alglib_env_state);
    ae_vector_attach_to_x(&_yc, yc, &_alglib_env_state);
    ae_vector_attach_to_x(&_dc, dc, &_alglib_env_state);
    *s = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    _spline1dfitreport_init(&_rep, &_alglib_env_state);
    _pexec_spline1dfitcubicwc(&_x, &_y, &_w, *n, &_xc, &_yc, &_dc, *k, *m, info, &(*s)->obj, &_rep, &_alglib_env_state);
    x_set_spline1dfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dfithermitewc(const char **errormsg, x_vector* x, x_vector* y, x_vector* w, ae_int_t* n, x_vector* xc, x_vector* yc, x_vector* dc, ae_int_t* k, ae_int_t* m, ae_int_t* info, x_spline1dinterpolant** s, x_spline1dfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _w;
    ae_vector _xc;
    ae_vector _yc;
    ae_vector _dc;
    spline1dfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_vector_attach_to_x(&_xc, xc, &_alglib_env_state);
    ae_vector_attach_to_x(&_yc, yc, &_alglib_env_state);
    ae_vector_attach_to_x(&_dc, dc, &_alglib_env_state);
    *s = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    _spline1dfitreport_init(&_rep, &_alglib_env_state);
    spline1dfithermitewc(&_x, &_y, &_w, *n, &_xc, &_yc, &_dc, *k, *m, info, &(*s)->obj, &_rep, &_alglib_env_state);
    x_set_spline1dfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spline1dfithermitewc(const char **errormsg, x_vector* x, x_vector* y, x_vector* w, ae_int_t* n, x_vector* xc, x_vector* yc, x_vector* dc, ae_int_t* k, ae_int_t* m, ae_int_t* info, x_spline1dinterpolant** s, x_spline1dfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _w;
    ae_vector _xc;
    ae_vector _yc;
    ae_vector _dc;
    spline1dfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_vector_attach_to_x(&_xc, xc, &_alglib_env_state);
    ae_vector_attach_to_x(&_yc, yc, &_alglib_env_state);
    ae_vector_attach_to_x(&_dc, dc, &_alglib_env_state);
    *s = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    _spline1dfitreport_init(&_rep, &_alglib_env_state);
    _pexec_spline1dfithermitewc(&_x, &_y, &_w, *n, &_xc, &_yc, &_dc, *k, *m, info, &(*s)->obj, &_rep, &_alglib_env_state);
    x_set_spline1dfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dfitcubic(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* m, ae_int_t* info, x_spline1dinterpolant** s, x_spline1dfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    spline1dfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *s = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    _spline1dfitreport_init(&_rep, &_alglib_env_state);
    spline1dfitcubic(&_x, &_y, *n, *m, info, &(*s)->obj, &_rep, &_alglib_env_state);
    x_set_spline1dfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spline1dfitcubic(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* m, ae_int_t* info, x_spline1dinterpolant** s, x_spline1dfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    spline1dfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *s = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    _spline1dfitreport_init(&_rep, &_alglib_env_state);
    _pexec_spline1dfitcubic(&_x, &_y, *n, *m, info, &(*s)->obj, &_rep, &_alglib_env_state);
    x_set_spline1dfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline1dfithermite(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* m, ae_int_t* info, x_spline1dinterpolant** s, x_spline1dfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    spline1dfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *s = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    _spline1dfitreport_init(&_rep, &_alglib_env_state);
    spline1dfithermite(&_x, &_y, *n, *m, info, &(*s)->obj, &_rep, &_alglib_env_state);
    x_set_spline1dfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_spline1dfithermite(const char **errormsg, x_vector* x, x_vector* y, ae_int_t* n, ae_int_t* m, ae_int_t* info, x_spline1dinterpolant** s, x_spline1dfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    spline1dfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    *s = x_obj_alloc_spline1dinterpolant(&_alglib_env_state);
    _spline1dfitreport_init(&_rep, &_alglib_env_state);
    _pexec_spline1dfithermite(&_x, &_y, *n, *m, info, &(*s)->obj, &_rep, &_alglib_env_state);
    x_set_spline1dfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitlinearw(const char **errormsg, x_vector* y, x_vector* w, x_matrix* fmatrix, ae_int_t* n, ae_int_t* m, ae_int_t* info, x_vector* c, x_lsfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _y;
    ae_vector _w;
    ae_matrix _fmatrix;
    ae_vector _c;
    lsfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_matrix_attach_to_x(&_fmatrix, fmatrix, &_alglib_env_state);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    _lsfitreport_init(&_rep, &_alglib_env_state);
    lsfitlinearw(&_y, &_w, &_fmatrix, *n, *m, info, &_c, &_rep, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    x_set_lsfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_lsfitlinearw(const char **errormsg, x_vector* y, x_vector* w, x_matrix* fmatrix, ae_int_t* n, ae_int_t* m, ae_int_t* info, x_vector* c, x_lsfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _y;
    ae_vector _w;
    ae_matrix _fmatrix;
    ae_vector _c;
    lsfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_matrix_attach_to_x(&_fmatrix, fmatrix, &_alglib_env_state);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    _lsfitreport_init(&_rep, &_alglib_env_state);
    _pexec_lsfitlinearw(&_y, &_w, &_fmatrix, *n, *m, info, &_c, &_rep, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    x_set_lsfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitlinearwc(const char **errormsg, x_vector* y, x_vector* w, x_matrix* fmatrix, x_matrix* cmatrix, ae_int_t* n, ae_int_t* m, ae_int_t* k, ae_int_t* info, x_vector* c, x_lsfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _y;
    ae_vector _w;
    ae_matrix _fmatrix;
    ae_matrix _cmatrix;
    ae_vector _c;
    lsfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_matrix_attach_to_x(&_fmatrix, fmatrix, &_alglib_env_state);
    ae_matrix_attach_to_x(&_cmatrix, cmatrix, &_alglib_env_state);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    _lsfitreport_init(&_rep, &_alglib_env_state);
    lsfitlinearwc(&_y, &_w, &_fmatrix, &_cmatrix, *n, *m, *k, info, &_c, &_rep, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    x_set_lsfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_lsfitlinearwc(const char **errormsg, x_vector* y, x_vector* w, x_matrix* fmatrix, x_matrix* cmatrix, ae_int_t* n, ae_int_t* m, ae_int_t* k, ae_int_t* info, x_vector* c, x_lsfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _y;
    ae_vector _w;
    ae_matrix _fmatrix;
    ae_matrix _cmatrix;
    ae_vector _c;
    lsfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_matrix_attach_to_x(&_fmatrix, fmatrix, &_alglib_env_state);
    ae_matrix_attach_to_x(&_cmatrix, cmatrix, &_alglib_env_state);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    _lsfitreport_init(&_rep, &_alglib_env_state);
    _pexec_lsfitlinearwc(&_y, &_w, &_fmatrix, &_cmatrix, *n, *m, *k, info, &_c, &_rep, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    x_set_lsfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitlinear(const char **errormsg, x_vector* y, x_matrix* fmatrix, ae_int_t* n, ae_int_t* m, ae_int_t* info, x_vector* c, x_lsfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _y;
    ae_matrix _fmatrix;
    ae_vector _c;
    lsfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_matrix_attach_to_x(&_fmatrix, fmatrix, &_alglib_env_state);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    _lsfitreport_init(&_rep, &_alglib_env_state);
    lsfitlinear(&_y, &_fmatrix, *n, *m, info, &_c, &_rep, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    x_set_lsfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_lsfitlinear(const char **errormsg, x_vector* y, x_matrix* fmatrix, ae_int_t* n, ae_int_t* m, ae_int_t* info, x_vector* c, x_lsfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _y;
    ae_matrix _fmatrix;
    ae_vector _c;
    lsfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_matrix_attach_to_x(&_fmatrix, fmatrix, &_alglib_env_state);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    _lsfitreport_init(&_rep, &_alglib_env_state);
    _pexec_lsfitlinear(&_y, &_fmatrix, *n, *m, info, &_c, &_rep, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    x_set_lsfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitlinearc(const char **errormsg, x_vector* y, x_matrix* fmatrix, x_matrix* cmatrix, ae_int_t* n, ae_int_t* m, ae_int_t* k, ae_int_t* info, x_vector* c, x_lsfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _y;
    ae_matrix _fmatrix;
    ae_matrix _cmatrix;
    ae_vector _c;
    lsfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_matrix_attach_to_x(&_fmatrix, fmatrix, &_alglib_env_state);
    ae_matrix_attach_to_x(&_cmatrix, cmatrix, &_alglib_env_state);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    _lsfitreport_init(&_rep, &_alglib_env_state);
    lsfitlinearc(&_y, &_fmatrix, &_cmatrix, *n, *m, *k, info, &_c, &_rep, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    x_set_lsfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smp_lsfitlinearc(const char **errormsg, x_vector* y, x_matrix* fmatrix, x_matrix* cmatrix, ae_int_t* n, ae_int_t* m, ae_int_t* k, ae_int_t* info, x_vector* c, x_lsfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _y;
    ae_matrix _fmatrix;
    ae_matrix _cmatrix;
    ae_vector _c;
    lsfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_matrix_attach_to_x(&_fmatrix, fmatrix, &_alglib_env_state);
    ae_matrix_attach_to_x(&_cmatrix, cmatrix, &_alglib_env_state);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    _lsfitreport_init(&_rep, &_alglib_env_state);
    _pexec_lsfitlinearc(&_y, &_fmatrix, &_cmatrix, *n, *m, *k, info, &_c, &_rep, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    x_set_lsfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitcreatewf(const char **errormsg, x_matrix* x, x_vector* y, x_vector* w, x_vector* c, ae_int_t* n, ae_int_t* m, ae_int_t* k, double* diffstep, x_lsfitstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_vector _y;
    ae_vector _w;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_vector_attach_to_x(&_c, c, &_alglib_env_state);
    *state = x_obj_alloc_lsfitstate(&_alglib_env_state);
    lsfitcreatewf(&_x, &_y, &_w, &_c, *n, *m, *k, *diffstep, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitcreatef(const char **errormsg, x_matrix* x, x_vector* y, x_vector* c, ae_int_t* n, ae_int_t* m, ae_int_t* k, double* diffstep, x_lsfitstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_vector _y;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_c, c, &_alglib_env_state);
    *state = x_obj_alloc_lsfitstate(&_alglib_env_state);
    lsfitcreatef(&_x, &_y, &_c, *n, *m, *k, *diffstep, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitcreatewfg(const char **errormsg, x_matrix* x, x_vector* y, x_vector* w, x_vector* c, ae_int_t* n, ae_int_t* m, ae_int_t* k, bool8* cheapfg, x_lsfitstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_vector _y;
    ae_vector _w;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_vector_attach_to_x(&_c, c, &_alglib_env_state);
    *state = x_obj_alloc_lsfitstate(&_alglib_env_state);
    lsfitcreatewfg(&_x, &_y, &_w, &_c, *n, *m, *k, *cheapfg, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitcreatefg(const char **errormsg, x_matrix* x, x_vector* y, x_vector* c, ae_int_t* n, ae_int_t* m, ae_int_t* k, bool8* cheapfg, x_lsfitstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_vector _y;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_c, c, &_alglib_env_state);
    *state = x_obj_alloc_lsfitstate(&_alglib_env_state);
    lsfitcreatefg(&_x, &_y, &_c, *n, *m, *k, *cheapfg, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitcreatewfgh(const char **errormsg, x_matrix* x, x_vector* y, x_vector* w, x_vector* c, ae_int_t* n, ae_int_t* m, ae_int_t* k, x_lsfitstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_vector _y;
    ae_vector _w;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_w, w, &_alglib_env_state);
    ae_vector_attach_to_x(&_c, c, &_alglib_env_state);
    *state = x_obj_alloc_lsfitstate(&_alglib_env_state);
    lsfitcreatewfgh(&_x, &_y, &_w, &_c, *n, *m, *k, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitcreatefgh(const char **errormsg, x_matrix* x, x_vector* y, x_vector* c, ae_int_t* n, ae_int_t* m, ae_int_t* k, x_lsfitstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_vector _y;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_c, c, &_alglib_env_state);
    *state = x_obj_alloc_lsfitstate(&_alglib_env_state);
    lsfitcreatefgh(&_x, &_y, &_c, *n, *m, *k, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitsetcond(const char **errormsg, x_lsfitstate** state, double* epsf, double* epsx, ae_int_t* maxits)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    lsfitsetcond(&(*state)->obj, *epsf, *epsx, *maxits, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitsetstpmax(const char **errormsg, x_lsfitstate** state, double* stpmax)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    lsfitsetstpmax(&(*state)->obj, *stpmax, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitsetxrep(const char **errormsg, x_lsfitstate** state, bool8* needxrep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    lsfitsetxrep(&(*state)->obj, *needxrep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitsetscale(const char **errormsg, x_lsfitstate** state, x_vector* s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _s;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_s, s, &_alglib_env_state);
    lsfitsetscale(&(*state)->obj, &_s, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitsetbc(const char **errormsg, x_lsfitstate** state, x_vector* bndl, x_vector* bndu)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _bndl;
    ae_vector _bndu;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_bndl, bndl, &_alglib_env_state);
    ae_vector_attach_to_x(&_bndu, bndu, &_alglib_env_state);
    lsfitsetbc(&(*state)->obj, &_bndl, &_bndu, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfititeration(const char **errormsg, bool8* result, x_lsfitstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = lsfititeration(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitresults(const char **errormsg, x_lsfitstate** state, ae_int_t* info, x_vector* c, x_lsfitreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _c;
    lsfitreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    _lsfitreport_init(&_rep, &_alglib_env_state);
    lsfitresults(&(*state)->obj, info, &_c, &_rep, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    x_set_lsfitreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lsfitsetgradientcheck(const char **errormsg, x_lsfitstate** state, double* teststep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    lsfitsetgradientcheck(&(*state)->obj, *teststep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED pspline2interpolant obj;
} x_pspline2interpolant;
x_pspline2interpolant* x_obj_alloc_pspline2interpolant(ae_state *_state)
{
    x_pspline2interpolant *result;
    result = ae_malloc(sizeof(x_pspline2interpolant), _state);
    _pspline2interpolant_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_pspline2interpolant* x_obj_copy_pspline2interpolant(x_pspline2interpolant *src)
{
    x_pspline2interpolant *result;
    result = ae_malloc(sizeof(x_pspline2interpolant), NULL);
    _pspline2interpolant_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_pspline2interpolant(x_pspline2interpolant *obj)
{
    if( obj==NULL )
        return;
    _pspline2interpolant_clear(&obj->obj);
    ae_free(obj);
    return;
}
typedef ALIGNED struct
{
    ALIGNED pspline3interpolant obj;
} x_pspline3interpolant;
x_pspline3interpolant* x_obj_alloc_pspline3interpolant(ae_state *_state)
{
    x_pspline3interpolant *result;
    result = ae_malloc(sizeof(x_pspline3interpolant), _state);
    _pspline3interpolant_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_pspline3interpolant* x_obj_copy_pspline3interpolant(x_pspline3interpolant *src)
{
    x_pspline3interpolant *result;
    result = ae_malloc(sizeof(x_pspline3interpolant), NULL);
    _pspline3interpolant_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_pspline3interpolant(x_pspline3interpolant *obj)
{
    if( obj==NULL )
        return;
    _pspline3interpolant_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT ae_int32_t alglib_pspline2build(const char **errormsg, x_matrix* xy, ae_int_t* n, ae_int_t* st, ae_int_t* pt, x_pspline2interpolant** p)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *p = x_obj_alloc_pspline2interpolant(&_alglib_env_state);
    pspline2build(&_xy, *n, *st, *pt, &(*p)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline3build(const char **errormsg, x_matrix* xy, ae_int_t* n, ae_int_t* st, ae_int_t* pt, x_pspline3interpolant** p)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *p = x_obj_alloc_pspline3interpolant(&_alglib_env_state);
    pspline3build(&_xy, *n, *st, *pt, &(*p)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline2buildperiodic(const char **errormsg, x_matrix* xy, ae_int_t* n, ae_int_t* st, ae_int_t* pt, x_pspline2interpolant** p)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *p = x_obj_alloc_pspline2interpolant(&_alglib_env_state);
    pspline2buildperiodic(&_xy, *n, *st, *pt, &(*p)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline3buildperiodic(const char **errormsg, x_matrix* xy, ae_int_t* n, ae_int_t* st, ae_int_t* pt, x_pspline3interpolant** p)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    *p = x_obj_alloc_pspline3interpolant(&_alglib_env_state);
    pspline3buildperiodic(&_xy, *n, *st, *pt, &(*p)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline2parametervalues(const char **errormsg, x_pspline2interpolant** p, ae_int_t* n, x_vector* t)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _t;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_t, 0, DT_REAL, &_alglib_env_state);
    pspline2parametervalues(&(*p)->obj, n, &_t, &_alglib_env_state);
    ae_x_set_vector(t, &_t, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline3parametervalues(const char **errormsg, x_pspline3interpolant** p, ae_int_t* n, x_vector* t)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _t;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_t, 0, DT_REAL, &_alglib_env_state);
    pspline3parametervalues(&(*p)->obj, n, &_t, &_alglib_env_state);
    ae_x_set_vector(t, &_t, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline2calc(const char **errormsg, x_pspline2interpolant** p, double* t, double* x, double* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    pspline2calc(&(*p)->obj, *t, x, y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline3calc(const char **errormsg, x_pspline3interpolant** p, double* t, double* x, double* y, double* z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    pspline3calc(&(*p)->obj, *t, x, y, z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline2tangent(const char **errormsg, x_pspline2interpolant** p, double* t, double* x, double* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    pspline2tangent(&(*p)->obj, *t, x, y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline3tangent(const char **errormsg, x_pspline3interpolant** p, double* t, double* x, double* y, double* z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    pspline3tangent(&(*p)->obj, *t, x, y, z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline2diff(const char **errormsg, x_pspline2interpolant** p, double* t, double* x, double* dx, double* y, double* dy)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    pspline2diff(&(*p)->obj, *t, x, dx, y, dy, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline3diff(const char **errormsg, x_pspline3interpolant** p, double* t, double* x, double* dx, double* y, double* dy, double* z, double* dz)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    pspline3diff(&(*p)->obj, *t, x, dx, y, dy, z, dz, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline2diff2(const char **errormsg, x_pspline2interpolant** p, double* t, double* x, double* dx, double* d2x, double* y, double* dy, double* d2y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    pspline2diff2(&(*p)->obj, *t, x, dx, d2x, y, dy, d2y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline3diff2(const char **errormsg, x_pspline3interpolant** p, double* t, double* x, double* dx, double* d2x, double* y, double* dy, double* d2y, double* z, double* dz, double* d2z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    pspline3diff2(&(*p)->obj, *t, x, dx, d2x, y, dy, d2y, z, dz, d2z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline2arclength(const char **errormsg, double* result, x_pspline2interpolant** p, double* a, double* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = pspline2arclength(&(*p)->obj, *a, *b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pspline3arclength(const char **errormsg, double* result, x_pspline3interpolant** p, double* a, double* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = pspline3arclength(&(*p)->obj, *a, *b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_parametricrdpfixed(const char **errormsg, x_matrix* x, ae_int_t* n, ae_int_t* d, ae_int_t* stopm, double* stopeps, x_matrix* x2, x_vector* idx2, ae_int_t* nsections)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _x;
    ae_matrix _x2;
    ae_vector _idx2;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_x, x, &_alglib_env_state);
    ae_matrix_init(&_x2, 0, 0, DT_REAL, &_alglib_env_state);
    ae_vector_init(&_idx2, 0, DT_INT, &_alglib_env_state);
    parametricrdpfixed(&_x, *n, *d, *stopm, *stopeps, &_x2, &_idx2, nsections, &_alglib_env_state);
    ae_x_set_matrix(x2, &_x2, &_alglib_env_state);
    ae_x_set_vector(idx2, &_idx2, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED linlsqrstate obj;
} x_linlsqrstate;
x_linlsqrstate* x_obj_alloc_linlsqrstate(ae_state *_state)
{
    x_linlsqrstate *result;
    result = ae_malloc(sizeof(x_linlsqrstate), _state);
    _linlsqrstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_linlsqrstate* x_obj_copy_linlsqrstate(x_linlsqrstate *src)
{
    x_linlsqrstate *result;
    result = ae_malloc(sizeof(x_linlsqrstate), NULL);
    _linlsqrstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_linlsqrstate(x_linlsqrstate *obj)
{
    if( obj==NULL )
        return;
    _linlsqrstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t iterationscount;
    ALIGNED ae_int_t nmv;
    ALIGNED ae_int_t terminationtype;
} x_linlsqrreport;
void x_set_linlsqrreport(x_linlsqrreport *dst, linlsqrreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nmv = src->nmv;
    dst->terminationtype = src->terminationtype;
}
void linlsqrreport_init_from_x(linlsqrreport *dst, x_linlsqrreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nmv = src->nmv;
    dst->terminationtype = src->terminationtype;
}
DLLEXPORT ae_int32_t alglib_linlsqrcreate(const char **errormsg, ae_int_t* m, ae_int_t* n, x_linlsqrstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *state = x_obj_alloc_linlsqrstate(&_alglib_env_state);
    linlsqrcreate(*m, *n, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_linlsqrsetprecunit(const char **errormsg, x_linlsqrstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    linlsqrsetprecunit(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_linlsqrsetprecdiag(const char **errormsg, x_linlsqrstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    linlsqrsetprecdiag(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_linlsqrsetlambdai(const char **errormsg, x_linlsqrstate** state, double* lambdai)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    linlsqrsetlambdai(&(*state)->obj, *lambdai, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_linlsqrsolvesparse(const char **errormsg, x_linlsqrstate** state, x_sparsematrix** a, x_vector* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    linlsqrsolvesparse(&(*state)->obj, &(*a)->obj, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_linlsqrsetcond(const char **errormsg, x_linlsqrstate** state, double* epsa, double* epsb, ae_int_t* maxits)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    linlsqrsetcond(&(*state)->obj, *epsa, *epsb, *maxits, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_linlsqrresults(const char **errormsg, x_linlsqrstate** state, x_vector* x, x_linlsqrreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    linlsqrreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    _linlsqrreport_init(&_rep, &_alglib_env_state);
    linlsqrresults(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_linlsqrreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_linlsqrsetxrep(const char **errormsg, x_linlsqrstate** state, bool8* needxrep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    linlsqrsetxrep(&(*state)->obj, *needxrep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED rbfmodel obj;
} x_rbfmodel;
x_rbfmodel* x_obj_alloc_rbfmodel(ae_state *_state)
{
    x_rbfmodel *result;
    result = ae_malloc(sizeof(x_rbfmodel), _state);
    _rbfmodel_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_rbfmodel* x_obj_copy_rbfmodel(x_rbfmodel *src)
{
    x_rbfmodel *result;
    result = ae_malloc(sizeof(x_rbfmodel), NULL);
    _rbfmodel_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_rbfmodel(x_rbfmodel *obj)
{
    if( obj==NULL )
        return;
    _rbfmodel_clear(&obj->obj);
    ae_free(obj);
    return;
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t arows;
    ALIGNED ae_int_t acols;
    ALIGNED ae_int_t annz;
    ALIGNED ae_int_t iterationscount;
    ALIGNED ae_int_t nmv;
    ALIGNED ae_int_t terminationtype;
} x_rbfreport;
void x_set_rbfreport(x_rbfreport *dst, rbfreport *src, ae_state *_state)
{
    dst->arows = src->arows;
    dst->acols = src->acols;
    dst->annz = src->annz;
    dst->iterationscount = src->iterationscount;
    dst->nmv = src->nmv;
    dst->terminationtype = src->terminationtype;
}
void rbfreport_init_from_x(rbfreport *dst, x_rbfreport *src, ae_state *_state)
{
    dst->arows = src->arows;
    dst->acols = src->acols;
    dst->annz = src->annz;
    dst->iterationscount = src->iterationscount;
    dst->nmv = src->nmv;
    dst->terminationtype = src->terminationtype;
}
DLLEXPORT ae_int32_t alglib_rbfserialize(const char **errormsg, x_rbfmodel **obj, char **s_out)
{
    ae_state state;
    ae_serializer serializer;
    jmp_buf _break_jump;
    ae_frame _frame_block;
    
    ae_state_init(&state);
    ae_serializer_init(&serializer);
    if( setjmp(_break_jump) )
    {
        if( state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&state, &_break_jump);
    ae_frame_make(&state, &_frame_block);
    
    ae_serializer_alloc_start(&serializer);
    rbfalloc(&serializer, &((*obj)->obj), &state);
    x_malloc((void**)(s_out), ae_serializer_get_alloc_size(&serializer)+1);
    ae_serializer_sstart_str(&serializer, *s_out);
    rbfserialize(&serializer, &((*obj)->obj), &state);
    ae_serializer_stop(&serializer);
    
    ae_serializer_clear(&serializer);
    ae_state_clear(&state);
    return X_OK;
}    
    
DLLEXPORT ae_int32_t alglib_rbfunserialize(const char **errormsg, char **s_in, x_rbfmodel **obj)
{
    ae_state state;
    ae_serializer serializer;
    jmp_buf _break_jump;
    ae_frame _frame_block;
    
    ae_state_init(&state);
    ae_serializer_init(&serializer);
    if( setjmp(_break_jump) )
    {
        if( state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&state, &_break_jump);
    ae_frame_make(&state, &_frame_block);
    
    *obj = x_obj_alloc_rbfmodel(&state);
    ae_serializer_ustart_str(&serializer, *s_in);
    rbfunserialize(&serializer, &((*obj)->obj), &state);
    ae_serializer_stop(&serializer);
    
    ae_serializer_clear(&serializer);
    ae_state_clear(&state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rbfcreate(const char **errormsg, ae_int_t* nx, ae_int_t* ny, x_rbfmodel** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *s = x_obj_alloc_rbfmodel(&_alglib_env_state);
    rbfcreate(*nx, *ny, &(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rbfsetpoints(const char **errormsg, x_rbfmodel** s, x_matrix* xy, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xy;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_xy, xy, &_alglib_env_state);
    rbfsetpoints(&(*s)->obj, &_xy, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rbfsetalgoqnn(const char **errormsg, x_rbfmodel** s, double* q, double* z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    rbfsetalgoqnn(&(*s)->obj, *q, *z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rbfsetalgomultilayer(const char **errormsg, x_rbfmodel** s, double* rbase, ae_int_t* nlayers, double* lambdav)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    rbfsetalgomultilayer(&(*s)->obj, *rbase, *nlayers, *lambdav, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rbfsetlinterm(const char **errormsg, x_rbfmodel** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    rbfsetlinterm(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rbfsetconstterm(const char **errormsg, x_rbfmodel** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    rbfsetconstterm(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rbfsetzeroterm(const char **errormsg, x_rbfmodel** s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    rbfsetzeroterm(&(*s)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rbfbuildmodel(const char **errormsg, x_rbfmodel** s, x_rbfreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    rbfreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    _rbfreport_init(&_rep, &_alglib_env_state);
    rbfbuildmodel(&(*s)->obj, &_rep, &_alglib_env_state);
    x_set_rbfreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rbfcalc2(const char **errormsg, double* result, x_rbfmodel** s, double* x0, double* x1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = rbfcalc2(&(*s)->obj, *x0, *x1, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rbfcalc3(const char **errormsg, double* result, x_rbfmodel** s, double* x0, double* x1, double* x2)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = rbfcalc3(&(*s)->obj, *x0, *x1, *x2, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rbfcalc(const char **errormsg, x_rbfmodel** s, x_vector* x, x_vector* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_init(&_y, 0, DT_REAL, &_alglib_env_state);
    rbfcalc(&(*s)->obj, &_x, &_y, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rbfcalcbuf(const char **errormsg, x_rbfmodel** s, x_vector* x, x_vector* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    rbfcalcbuf(&(*s)->obj, &_x, &_y, &_alglib_env_state);
    ae_x_set_vector(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rbfgridcalc2(const char **errormsg, x_rbfmodel** s, x_vector* x0, ae_int_t* n0, x_vector* x1, ae_int_t* n1, x_matrix* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x0;
    ae_vector _x1;
    ae_matrix _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x0, x0, &_alglib_env_state);
    ae_vector_attach_to_x(&_x1, x1, &_alglib_env_state);
    ae_matrix_init(&_y, 0, 0, DT_REAL, &_alglib_env_state);
    rbfgridcalc2(&(*s)->obj, &_x0, *n0, &_x1, *n1, &_y, &_alglib_env_state);
    ae_x_set_matrix(y, &_y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rbfunpack(const char **errormsg, x_rbfmodel** s, ae_int_t* nx, ae_int_t* ny, x_matrix* xwr, ae_int_t* nc, x_matrix* v)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _xwr;
    ae_matrix _v;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_xwr, 0, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_v, 0, 0, DT_REAL, &_alglib_env_state);
    rbfunpack(&(*s)->obj, nx, ny, &_xwr, nc, &_v, &_alglib_env_state);
    ae_x_set_matrix(xwr, &_xwr, &_alglib_env_state);
    ae_x_set_matrix(v, &_v, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED spline2dinterpolant obj;
} x_spline2dinterpolant;
x_spline2dinterpolant* x_obj_alloc_spline2dinterpolant(ae_state *_state)
{
    x_spline2dinterpolant *result;
    result = ae_malloc(sizeof(x_spline2dinterpolant), _state);
    _spline2dinterpolant_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_spline2dinterpolant* x_obj_copy_spline2dinterpolant(x_spline2dinterpolant *src)
{
    x_spline2dinterpolant *result;
    result = ae_malloc(sizeof(x_spline2dinterpolant), NULL);
    _spline2dinterpolant_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_spline2dinterpolant(x_spline2dinterpolant *obj)
{
    if( obj==NULL )
        return;
    _spline2dinterpolant_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT ae_int32_t alglib_spline2dcalc(const char **errormsg, double* result, x_spline2dinterpolant** c, double* x, double* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = spline2dcalc(&(*c)->obj, *x, *y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline2ddiff(const char **errormsg, x_spline2dinterpolant** c, double* x, double* y, double* f, double* fx, double* fy, double* fxy)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    spline2ddiff(&(*c)->obj, *x, *y, f, fx, fy, fxy, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline2dlintransxy(const char **errormsg, x_spline2dinterpolant** c, double* ax, double* bx, double* ay, double* by)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    spline2dlintransxy(&(*c)->obj, *ax, *bx, *ay, *by, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline2dlintransf(const char **errormsg, x_spline2dinterpolant** c, double* a, double* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    spline2dlintransf(&(*c)->obj, *a, *b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline2dcopy(const char **errormsg, x_spline2dinterpolant** c, x_spline2dinterpolant** cc)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *cc = x_obj_alloc_spline2dinterpolant(&_alglib_env_state);
    spline2dcopy(&(*c)->obj, &(*cc)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline2dresamplebicubic(const char **errormsg, x_matrix* a, ae_int_t* oldheight, ae_int_t* oldwidth, x_matrix* b, ae_int_t* newheight, ae_int_t* newwidth)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_init(&_b, 0, 0, DT_REAL, &_alglib_env_state);
    spline2dresamplebicubic(&_a, *oldheight, *oldwidth, &_b, *newheight, *newwidth, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline2dresamplebilinear(const char **errormsg, x_matrix* a, ae_int_t* oldheight, ae_int_t* oldwidth, x_matrix* b, ae_int_t* newheight, ae_int_t* newwidth)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_init(&_b, 0, 0, DT_REAL, &_alglib_env_state);
    spline2dresamplebilinear(&_a, *oldheight, *oldwidth, &_b, *newheight, *newwidth, &_alglib_env_state);
    ae_x_set_matrix(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline2dbuildbilinearv(const char **errormsg, x_vector* x, ae_int_t* n, x_vector* y, ae_int_t* m, x_vector* f, ae_int_t* d, x_spline2dinterpolant** c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _f;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_f, f, &_alglib_env_state);
    *c = x_obj_alloc_spline2dinterpolant(&_alglib_env_state);
    spline2dbuildbilinearv(&_x, *n, &_y, *m, &_f, *d, &(*c)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline2dbuildbicubicv(const char **errormsg, x_vector* x, ae_int_t* n, x_vector* y, ae_int_t* m, x_vector* f, ae_int_t* d, x_spline2dinterpolant** c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _f;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_f, f, &_alglib_env_state);
    *c = x_obj_alloc_spline2dinterpolant(&_alglib_env_state);
    spline2dbuildbicubicv(&_x, *n, &_y, *m, &_f, *d, &(*c)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline2dcalcvbuf(const char **errormsg, x_spline2dinterpolant** c, double* x, double* y, x_vector* f)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _f;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_f, f, &_alglib_env_state);
    spline2dcalcvbuf(&(*c)->obj, *x, *y, &_f, &_alglib_env_state);
    ae_x_set_vector(f, &_f, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline2dcalcv(const char **errormsg, x_spline2dinterpolant** c, double* x, double* y, x_vector* f)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _f;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_f, 0, DT_REAL, &_alglib_env_state);
    spline2dcalcv(&(*c)->obj, *x, *y, &_f, &_alglib_env_state);
    ae_x_set_vector(f, &_f, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline2dunpackv(const char **errormsg, x_spline2dinterpolant** c, ae_int_t* m, ae_int_t* n, ae_int_t* d, x_matrix* tbl)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _tbl;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_tbl, 0, 0, DT_REAL, &_alglib_env_state);
    spline2dunpackv(&(*c)->obj, m, n, d, &_tbl, &_alglib_env_state);
    ae_x_set_matrix(tbl, &_tbl, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline2dbuildbilinear(const char **errormsg, x_vector* x, x_vector* y, x_matrix* f, ae_int_t* m, ae_int_t* n, x_spline2dinterpolant** c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_matrix _f;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_matrix_attach_to_x(&_f, f, &_alglib_env_state);
    *c = x_obj_alloc_spline2dinterpolant(&_alglib_env_state);
    spline2dbuildbilinear(&_x, &_y, &_f, *m, *n, &(*c)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline2dbuildbicubic(const char **errormsg, x_vector* x, x_vector* y, x_matrix* f, ae_int_t* m, ae_int_t* n, x_spline2dinterpolant** c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_matrix _f;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_matrix_attach_to_x(&_f, f, &_alglib_env_state);
    *c = x_obj_alloc_spline2dinterpolant(&_alglib_env_state);
    spline2dbuildbicubic(&_x, &_y, &_f, *m, *n, &(*c)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline2dunpack(const char **errormsg, x_spline2dinterpolant** c, ae_int_t* m, ae_int_t* n, x_matrix* tbl)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _tbl;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_tbl, 0, 0, DT_REAL, &_alglib_env_state);
    spline2dunpack(&(*c)->obj, m, n, &_tbl, &_alglib_env_state);
    ae_x_set_matrix(tbl, &_tbl, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED spline3dinterpolant obj;
} x_spline3dinterpolant;
x_spline3dinterpolant* x_obj_alloc_spline3dinterpolant(ae_state *_state)
{
    x_spline3dinterpolant *result;
    result = ae_malloc(sizeof(x_spline3dinterpolant), _state);
    _spline3dinterpolant_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_spline3dinterpolant* x_obj_copy_spline3dinterpolant(x_spline3dinterpolant *src)
{
    x_spline3dinterpolant *result;
    result = ae_malloc(sizeof(x_spline3dinterpolant), NULL);
    _spline3dinterpolant_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_spline3dinterpolant(x_spline3dinterpolant *obj)
{
    if( obj==NULL )
        return;
    _spline3dinterpolant_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT ae_int32_t alglib_spline3dcalc(const char **errormsg, double* result, x_spline3dinterpolant** c, double* x, double* y, double* z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = spline3dcalc(&(*c)->obj, *x, *y, *z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline3dlintransxyz(const char **errormsg, x_spline3dinterpolant** c, double* ax, double* bx, double* ay, double* by, double* az, double* bz)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    spline3dlintransxyz(&(*c)->obj, *ax, *bx, *ay, *by, *az, *bz, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline3dlintransf(const char **errormsg, x_spline3dinterpolant** c, double* a, double* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    spline3dlintransf(&(*c)->obj, *a, *b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline3dresampletrilinear(const char **errormsg, x_vector* a, ae_int_t* oldzcount, ae_int_t* oldycount, ae_int_t* oldxcount, ae_int_t* newzcount, ae_int_t* newycount, ae_int_t* newxcount, x_vector* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_b, 0, DT_REAL, &_alglib_env_state);
    spline3dresampletrilinear(&_a, *oldzcount, *oldycount, *oldxcount, *newzcount, *newycount, *newxcount, &_b, &_alglib_env_state);
    ae_x_set_vector(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline3dbuildtrilinearv(const char **errormsg, x_vector* x, ae_int_t* n, x_vector* y, ae_int_t* m, x_vector* z, ae_int_t* l, x_vector* f, ae_int_t* d, x_spline3dinterpolant** c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_vector _z;
    ae_vector _f;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ae_vector_attach_to_x(&_z, z, &_alglib_env_state);
    ae_vector_attach_to_x(&_f, f, &_alglib_env_state);
    *c = x_obj_alloc_spline3dinterpolant(&_alglib_env_state);
    spline3dbuildtrilinearv(&_x, *n, &_y, *m, &_z, *l, &_f, *d, &(*c)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline3dcalcvbuf(const char **errormsg, x_spline3dinterpolant** c, double* x, double* y, double* z, x_vector* f)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _f;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_f, f, &_alglib_env_state);
    spline3dcalcvbuf(&(*c)->obj, *x, *y, *z, &_f, &_alglib_env_state);
    ae_x_set_vector(f, &_f, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline3dcalcv(const char **errormsg, x_spline3dinterpolant** c, double* x, double* y, double* z, x_vector* f)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _f;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_f, 0, DT_REAL, &_alglib_env_state);
    spline3dcalcv(&(*c)->obj, *x, *y, *z, &_f, &_alglib_env_state);
    ae_x_set_vector(f, &_f, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spline3dunpackv(const char **errormsg, x_spline3dinterpolant** c, ae_int_t* n, ae_int_t* m, ae_int_t* l, ae_int_t* d, ae_int_t* stype, x_matrix* tbl)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _tbl;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_init(&_tbl, 0, 0, DT_REAL, &_alglib_env_state);
    spline3dunpackv(&(*c)->obj, n, m, l, d, stype, &_tbl, &_alglib_env_state);
    ae_x_set_matrix(tbl, &_tbl, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixludet(const char **errormsg, double* result, x_matrix* a, x_vector* pivots, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _pivots;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_pivots, pivots, &_alglib_env_state);
    *result = rmatrixludet(&_a, &_pivots, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixdet(const char **errormsg, double* result, x_matrix* a, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = rmatrixdet(&_a, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixludet(const char **errormsg, ae_complex* result, x_matrix* a, x_vector* pivots, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_vector _pivots;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_attach_to_x(&_pivots, pivots, &_alglib_env_state);
    *result = cmatrixludet(&_a, &_pivots, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_cmatrixdet(const char **errormsg, ae_complex* result, x_matrix* a, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = cmatrixdet(&_a, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixcholeskydet(const char **errormsg, double* result, x_matrix* a, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = spdmatrixcholeskydet(&_a, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spdmatrixdet(const char **errormsg, double* result, x_matrix* a, ae_int_t* n, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    *result = spdmatrixdet(&_a, *n, *isupper, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smatrixgevd(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* n, bool8* isuppera, x_matrix* b, bool8* isupperb, ae_int_t* zneeded, ae_int_t* problemtype, x_vector* d, x_matrix* z)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_vector _d;
    ae_matrix _z;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    ae_vector_init(&_d, 0, DT_REAL, &_alglib_env_state);
    ae_matrix_init(&_z, 0, 0, DT_REAL, &_alglib_env_state);
    *result = smatrixgevd(&_a, *n, *isuppera, &_b, *isupperb, *zneeded, *problemtype, &_d, &_z, &_alglib_env_state);
    ae_x_set_vector(d, &_d, &_alglib_env_state);
    ae_x_set_matrix(z, &_z, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_smatrixgevdreduce(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* n, bool8* isuppera, x_matrix* b, bool8* isupperb, ae_int_t* problemtype, x_matrix* r, bool8* isupperr)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _b;
    ae_matrix _r;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_attach_to_x(&_b, b, &_alglib_env_state);
    ae_matrix_init(&_r, 0, 0, DT_REAL, &_alglib_env_state);
    *result = smatrixgevdreduce(&_a, *n, *isuppera, &_b, *isupperb, *problemtype, &_r, isupperr, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_matrix(r, &_r, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixinvupdatesimple(const char **errormsg, x_matrix* inva, ae_int_t* n, ae_int_t* updrow, ae_int_t* updcolumn, double* updval)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _inva;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_inva, inva, &_alglib_env_state);
    rmatrixinvupdatesimple(&_inva, *n, *updrow, *updcolumn, *updval, &_alglib_env_state);
    ae_x_set_matrix(inva, &_inva, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixinvupdaterow(const char **errormsg, x_matrix* inva, ae_int_t* n, ae_int_t* updrow, x_vector* v)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _inva;
    ae_vector _v;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_inva, inva, &_alglib_env_state);
    ae_vector_attach_to_x(&_v, v, &_alglib_env_state);
    rmatrixinvupdaterow(&_inva, *n, *updrow, &_v, &_alglib_env_state);
    ae_x_set_matrix(inva, &_inva, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixinvupdatecolumn(const char **errormsg, x_matrix* inva, ae_int_t* n, ae_int_t* updcolumn, x_vector* u)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _inva;
    ae_vector _u;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_inva, inva, &_alglib_env_state);
    ae_vector_attach_to_x(&_u, u, &_alglib_env_state);
    rmatrixinvupdatecolumn(&_inva, *n, *updcolumn, &_u, &_alglib_env_state);
    ae_x_set_matrix(inva, &_inva, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixinvupdateuv(const char **errormsg, x_matrix* inva, ae_int_t* n, x_vector* u, x_vector* v)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _inva;
    ae_vector _u;
    ae_vector _v;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_inva, inva, &_alglib_env_state);
    ae_vector_attach_to_x(&_u, u, &_alglib_env_state);
    ae_vector_attach_to_x(&_v, v, &_alglib_env_state);
    rmatrixinvupdateuv(&_inva, *n, &_u, &_v, &_alglib_env_state);
    ae_x_set_matrix(inva, &_inva, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_rmatrixschur(const char **errormsg, bool8* result, x_matrix* a, ae_int_t* n, x_matrix* s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _a;
    ae_matrix _s;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_a, a, &_alglib_env_state);
    ae_matrix_init(&_s, 0, 0, DT_REAL, &_alglib_env_state);
    *result = rmatrixschur(&_a, *n, &_s, &_alglib_env_state);
    ae_x_set_matrix(a, &_a, &_alglib_env_state);
    ae_x_set_matrix(s, &_s, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED minasastate obj;
} x_minasastate;
x_minasastate* x_obj_alloc_minasastate(ae_state *_state)
{
    x_minasastate *result;
    result = ae_malloc(sizeof(x_minasastate), _state);
    _minasastate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_minasastate* x_obj_copy_minasastate(x_minasastate *src)
{
    x_minasastate *result;
    result = ae_malloc(sizeof(x_minasastate), NULL);
    _minasastate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_minasastate(x_minasastate *obj)
{
    if( obj==NULL )
        return;
    _minasastate_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT void x_minasastate_get_needfg(x_minasastate *obj, bool8 *result)
{
    *result = obj->obj.needfg;
}
DLLEXPORT void x_minasastate_set_needfg(x_minasastate *obj, bool8 *result)
{
    obj->obj.needfg = *result;
}
DLLEXPORT void x_minasastate_get_xupdated(x_minasastate *obj, bool8 *result)
{
    *result = obj->obj.xupdated;
}
DLLEXPORT void x_minasastate_set_xupdated(x_minasastate *obj, bool8 *result)
{
    obj->obj.xupdated = *result;
}
DLLEXPORT void x_minasastate_get_f(x_minasastate *obj, double *result)
{
    *result = obj->obj.f;
}
DLLEXPORT void x_minasastate_set_f(x_minasastate *obj, double *result)
{
    obj->obj.f = *result;
}
DLLEXPORT void x_minasastate_get_g(x_minasastate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.g);
}
DLLEXPORT void x_minasastate_get_x(x_minasastate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.x);
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t iterationscount;
    ALIGNED ae_int_t nfev;
    ALIGNED ae_int_t terminationtype;
    ALIGNED ae_int_t activeconstraints;
} x_minasareport;
void x_set_minasareport(x_minasareport *dst, minasareport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nfev = src->nfev;
    dst->terminationtype = src->terminationtype;
    dst->activeconstraints = src->activeconstraints;
}
void minasareport_init_from_x(minasareport *dst, x_minasareport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nfev = src->nfev;
    dst->terminationtype = src->terminationtype;
    dst->activeconstraints = src->activeconstraints;
}
DLLEXPORT ae_int32_t alglib_minlbfgssetdefaultpreconditioner(const char **errormsg, x_minlbfgsstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minlbfgssetdefaultpreconditioner(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minlbfgssetcholeskypreconditioner(const char **errormsg, x_minlbfgsstate** state, x_matrix* p, bool8* isupper)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _p;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_p, p, &_alglib_env_state);
    minlbfgssetcholeskypreconditioner(&(*state)->obj, &_p, *isupper, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicsetbarrierwidth(const char **errormsg, x_minbleicstate** state, double* mu)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minbleicsetbarrierwidth(&(*state)->obj, *mu, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minbleicsetbarrierdecay(const char **errormsg, x_minbleicstate** state, double* mudecay)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minbleicsetbarrierdecay(&(*state)->obj, *mudecay, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minasacreate(const char **errormsg, ae_int_t* n, x_vector* x, x_vector* bndl, x_vector* bndu, x_minasastate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _bndl;
    ae_vector _bndu;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_bndl, bndl, &_alglib_env_state);
    ae_vector_attach_to_x(&_bndu, bndu, &_alglib_env_state);
    *state = x_obj_alloc_minasastate(&_alglib_env_state);
    minasacreate(*n, &_x, &_bndl, &_bndu, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minasasetcond(const char **errormsg, x_minasastate** state, double* epsg, double* epsf, double* epsx, ae_int_t* maxits)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minasasetcond(&(*state)->obj, *epsg, *epsf, *epsx, *maxits, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minasasetxrep(const char **errormsg, x_minasastate** state, bool8* needxrep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minasasetxrep(&(*state)->obj, *needxrep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minasasetalgorithm(const char **errormsg, x_minasastate** state, ae_int_t* algotype)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minasasetalgorithm(&(*state)->obj, *algotype, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minasasetstpmax(const char **errormsg, x_minasastate** state, double* stpmax)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minasasetstpmax(&(*state)->obj, *stpmax, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minasaiteration(const char **errormsg, bool8* result, x_minasastate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = minasaiteration(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minasaresults(const char **errormsg, x_minasastate** state, x_vector* x, x_minasareport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    minasareport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    _minasareport_init(&_rep, &_alglib_env_state);
    minasaresults(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_minasareport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minasaresultsbuf(const char **errormsg, x_minasastate** state, x_vector* x, x_minasareport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    minasareport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    minasareport_init_from_x(&_rep, rep, &_alglib_env_state);
    minasaresultsbuf(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_minasareport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minasarestartfrom(const char **errormsg, x_minasastate** state, x_vector* x, x_vector* bndl, x_vector* bndu)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _bndl;
    ae_vector _bndu;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_bndl, bndl, &_alglib_env_state);
    ae_vector_attach_to_x(&_bndu, bndu, &_alglib_env_state);
    minasarestartfrom(&(*state)->obj, &_x, &_bndl, &_bndu, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED minnlcstate obj;
} x_minnlcstate;
x_minnlcstate* x_obj_alloc_minnlcstate(ae_state *_state)
{
    x_minnlcstate *result;
    result = ae_malloc(sizeof(x_minnlcstate), _state);
    _minnlcstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_minnlcstate* x_obj_copy_minnlcstate(x_minnlcstate *src)
{
    x_minnlcstate *result;
    result = ae_malloc(sizeof(x_minnlcstate), NULL);
    _minnlcstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_minnlcstate(x_minnlcstate *obj)
{
    if( obj==NULL )
        return;
    _minnlcstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT void x_minnlcstate_get_needfi(x_minnlcstate *obj, bool8 *result)
{
    *result = obj->obj.needfi;
}
DLLEXPORT void x_minnlcstate_set_needfi(x_minnlcstate *obj, bool8 *result)
{
    obj->obj.needfi = *result;
}
DLLEXPORT void x_minnlcstate_get_needfij(x_minnlcstate *obj, bool8 *result)
{
    *result = obj->obj.needfij;
}
DLLEXPORT void x_minnlcstate_set_needfij(x_minnlcstate *obj, bool8 *result)
{
    obj->obj.needfij = *result;
}
DLLEXPORT void x_minnlcstate_get_xupdated(x_minnlcstate *obj, bool8 *result)
{
    *result = obj->obj.xupdated;
}
DLLEXPORT void x_minnlcstate_set_xupdated(x_minnlcstate *obj, bool8 *result)
{
    obj->obj.xupdated = *result;
}
DLLEXPORT void x_minnlcstate_get_f(x_minnlcstate *obj, double *result)
{
    *result = obj->obj.f;
}
DLLEXPORT void x_minnlcstate_set_f(x_minnlcstate *obj, double *result)
{
    obj->obj.f = *result;
}
DLLEXPORT void x_minnlcstate_get_fi(x_minnlcstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.fi);
}
DLLEXPORT void x_minnlcstate_get_j(x_minnlcstate *obj, x_matrix *result)
{
    ae_x_attach_to_matrix(result, &obj->obj.j);
}
DLLEXPORT void x_minnlcstate_get_x(x_minnlcstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.x);
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t iterationscount;
    ALIGNED ae_int_t nfev;
    ALIGNED ae_int_t varidx;
    ALIGNED ae_int_t funcidx;
    ALIGNED ae_int_t terminationtype;
    ALIGNED ae_int_t dbgphase0its;
} x_minnlcreport;
void x_set_minnlcreport(x_minnlcreport *dst, minnlcreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nfev = src->nfev;
    dst->varidx = src->varidx;
    dst->funcidx = src->funcidx;
    dst->terminationtype = src->terminationtype;
    dst->dbgphase0its = src->dbgphase0its;
}
void minnlcreport_init_from_x(minnlcreport *dst, x_minnlcreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nfev = src->nfev;
    dst->varidx = src->varidx;
    dst->funcidx = src->funcidx;
    dst->terminationtype = src->terminationtype;
    dst->dbgphase0its = src->dbgphase0its;
}
DLLEXPORT ae_int32_t alglib_minnlccreate(const char **errormsg, ae_int_t* n, x_vector* x, x_minnlcstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_minnlcstate(&_alglib_env_state);
    minnlccreate(*n, &_x, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlccreatef(const char **errormsg, ae_int_t* n, x_vector* x, double* diffstep, x_minnlcstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_minnlcstate(&_alglib_env_state);
    minnlccreatef(*n, &_x, *diffstep, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlcsetbc(const char **errormsg, x_minnlcstate** state, x_vector* bndl, x_vector* bndu)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _bndl;
    ae_vector _bndu;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_bndl, bndl, &_alglib_env_state);
    ae_vector_attach_to_x(&_bndu, bndu, &_alglib_env_state);
    minnlcsetbc(&(*state)->obj, &_bndl, &_bndu, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlcsetlc(const char **errormsg, x_minnlcstate** state, x_matrix* c, x_vector* ct, ae_int_t* k)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _c;
    ae_vector _ct;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    ae_vector_attach_to_x(&_ct, ct, &_alglib_env_state);
    minnlcsetlc(&(*state)->obj, &_c, &_ct, *k, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlcsetnlc(const char **errormsg, x_minnlcstate** state, ae_int_t* nlec, ae_int_t* nlic)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minnlcsetnlc(&(*state)->obj, *nlec, *nlic, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlcsetcond(const char **errormsg, x_minnlcstate** state, double* epsg, double* epsf, double* epsx, ae_int_t* maxits)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minnlcsetcond(&(*state)->obj, *epsg, *epsf, *epsx, *maxits, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlcsetscale(const char **errormsg, x_minnlcstate** state, x_vector* s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _s;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_s, s, &_alglib_env_state);
    minnlcsetscale(&(*state)->obj, &_s, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlcsetprecinexact(const char **errormsg, x_minnlcstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minnlcsetprecinexact(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlcsetprecexactlowrank(const char **errormsg, x_minnlcstate** state, ae_int_t* updatefreq)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minnlcsetprecexactlowrank(&(*state)->obj, *updatefreq, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlcsetprecnone(const char **errormsg, x_minnlcstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minnlcsetprecnone(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlcsetalgoaul(const char **errormsg, x_minnlcstate** state, double* rho, ae_int_t* itscnt)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minnlcsetalgoaul(&(*state)->obj, *rho, *itscnt, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlcsetxrep(const char **errormsg, x_minnlcstate** state, bool8* needxrep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minnlcsetxrep(&(*state)->obj, *needxrep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlciteration(const char **errormsg, bool8* result, x_minnlcstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = minnlciteration(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlcresults(const char **errormsg, x_minnlcstate** state, x_vector* x, x_minnlcreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    minnlcreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    _minnlcreport_init(&_rep, &_alglib_env_state);
    minnlcresults(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_minnlcreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlcresultsbuf(const char **errormsg, x_minnlcstate** state, x_vector* x, x_minnlcreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    minnlcreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    minnlcreport_init_from_x(&_rep, rep, &_alglib_env_state);
    minnlcresultsbuf(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_minnlcreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlcrestartfrom(const char **errormsg, x_minnlcstate** state, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    minnlcrestartfrom(&(*state)->obj, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnlcsetgradientcheck(const char **errormsg, x_minnlcstate** state, double* teststep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minnlcsetgradientcheck(&(*state)->obj, *teststep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED minnsstate obj;
} x_minnsstate;
x_minnsstate* x_obj_alloc_minnsstate(ae_state *_state)
{
    x_minnsstate *result;
    result = ae_malloc(sizeof(x_minnsstate), _state);
    _minnsstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_minnsstate* x_obj_copy_minnsstate(x_minnsstate *src)
{
    x_minnsstate *result;
    result = ae_malloc(sizeof(x_minnsstate), NULL);
    _minnsstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_minnsstate(x_minnsstate *obj)
{
    if( obj==NULL )
        return;
    _minnsstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT void x_minnsstate_get_needfi(x_minnsstate *obj, bool8 *result)
{
    *result = obj->obj.needfi;
}
DLLEXPORT void x_minnsstate_set_needfi(x_minnsstate *obj, bool8 *result)
{
    obj->obj.needfi = *result;
}
DLLEXPORT void x_minnsstate_get_needfij(x_minnsstate *obj, bool8 *result)
{
    *result = obj->obj.needfij;
}
DLLEXPORT void x_minnsstate_set_needfij(x_minnsstate *obj, bool8 *result)
{
    obj->obj.needfij = *result;
}
DLLEXPORT void x_minnsstate_get_xupdated(x_minnsstate *obj, bool8 *result)
{
    *result = obj->obj.xupdated;
}
DLLEXPORT void x_minnsstate_set_xupdated(x_minnsstate *obj, bool8 *result)
{
    obj->obj.xupdated = *result;
}
DLLEXPORT void x_minnsstate_get_f(x_minnsstate *obj, double *result)
{
    *result = obj->obj.f;
}
DLLEXPORT void x_minnsstate_set_f(x_minnsstate *obj, double *result)
{
    obj->obj.f = *result;
}
DLLEXPORT void x_minnsstate_get_fi(x_minnsstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.fi);
}
DLLEXPORT void x_minnsstate_get_j(x_minnsstate *obj, x_matrix *result)
{
    ae_x_attach_to_matrix(result, &obj->obj.j);
}
DLLEXPORT void x_minnsstate_get_x(x_minnsstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.x);
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t iterationscount;
    ALIGNED ae_int_t nfev;
    ALIGNED double cerr;
    ALIGNED double lcerr;
    ALIGNED double nlcerr;
    ALIGNED ae_int_t terminationtype;
    ALIGNED ae_int_t varidx;
    ALIGNED ae_int_t funcidx;
} x_minnsreport;
void x_set_minnsreport(x_minnsreport *dst, minnsreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nfev = src->nfev;
    dst->cerr = src->cerr;
    dst->lcerr = src->lcerr;
    dst->nlcerr = src->nlcerr;
    dst->terminationtype = src->terminationtype;
    dst->varidx = src->varidx;
    dst->funcidx = src->funcidx;
}
void minnsreport_init_from_x(minnsreport *dst, x_minnsreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nfev = src->nfev;
    dst->cerr = src->cerr;
    dst->lcerr = src->lcerr;
    dst->nlcerr = src->nlcerr;
    dst->terminationtype = src->terminationtype;
    dst->varidx = src->varidx;
    dst->funcidx = src->funcidx;
}
DLLEXPORT ae_int32_t alglib_minnscreate(const char **errormsg, ae_int_t* n, x_vector* x, x_minnsstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_minnsstate(&_alglib_env_state);
    minnscreate(*n, &_x, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnscreatef(const char **errormsg, ae_int_t* n, x_vector* x, double* diffstep, x_minnsstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_minnsstate(&_alglib_env_state);
    minnscreatef(*n, &_x, *diffstep, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnssetbc(const char **errormsg, x_minnsstate** state, x_vector* bndl, x_vector* bndu)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _bndl;
    ae_vector _bndu;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_bndl, bndl, &_alglib_env_state);
    ae_vector_attach_to_x(&_bndu, bndu, &_alglib_env_state);
    minnssetbc(&(*state)->obj, &_bndl, &_bndu, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnssetlc(const char **errormsg, x_minnsstate** state, x_matrix* c, x_vector* ct, ae_int_t* k)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_matrix _c;
    ae_vector _ct;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_matrix_attach_to_x(&_c, c, &_alglib_env_state);
    ae_vector_attach_to_x(&_ct, ct, &_alglib_env_state);
    minnssetlc(&(*state)->obj, &_c, &_ct, *k, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnssetnlc(const char **errormsg, x_minnsstate** state, ae_int_t* nlec, ae_int_t* nlic)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minnssetnlc(&(*state)->obj, *nlec, *nlic, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnssetcond(const char **errormsg, x_minnsstate** state, double* epsx, ae_int_t* maxits)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minnssetcond(&(*state)->obj, *epsx, *maxits, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnssetscale(const char **errormsg, x_minnsstate** state, x_vector* s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _s;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_s, s, &_alglib_env_state);
    minnssetscale(&(*state)->obj, &_s, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnssetalgoags(const char **errormsg, x_minnsstate** state, double* radius, double* penalty)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minnssetalgoags(&(*state)->obj, *radius, *penalty, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnssetxrep(const char **errormsg, x_minnsstate** state, bool8* needxrep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minnssetxrep(&(*state)->obj, *needxrep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnsrequesttermination(const char **errormsg, x_minnsstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    minnsrequesttermination(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnsiteration(const char **errormsg, bool8* result, x_minnsstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = minnsiteration(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnsresults(const char **errormsg, x_minnsstate** state, x_vector* x, x_minnsreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    minnsreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    _minnsreport_init(&_rep, &_alglib_env_state);
    minnsresults(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_minnsreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnsresultsbuf(const char **errormsg, x_minnsstate** state, x_vector* x, x_minnsreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    minnsreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    minnsreport_init_from_x(&_rep, rep, &_alglib_env_state);
    minnsresultsbuf(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_minnsreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_minnsrestartfrom(const char **errormsg, x_minnsstate** state, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    minnsrestartfrom(&(*state)->obj, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED lincgstate obj;
} x_lincgstate;
x_lincgstate* x_obj_alloc_lincgstate(ae_state *_state)
{
    x_lincgstate *result;
    result = ae_malloc(sizeof(x_lincgstate), _state);
    _lincgstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_lincgstate* x_obj_copy_lincgstate(x_lincgstate *src)
{
    x_lincgstate *result;
    result = ae_malloc(sizeof(x_lincgstate), NULL);
    _lincgstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_lincgstate(x_lincgstate *obj)
{
    if( obj==NULL )
        return;
    _lincgstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t iterationscount;
    ALIGNED ae_int_t nmv;
    ALIGNED ae_int_t terminationtype;
    ALIGNED double r2;
} x_lincgreport;
void x_set_lincgreport(x_lincgreport *dst, lincgreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nmv = src->nmv;
    dst->terminationtype = src->terminationtype;
    dst->r2 = src->r2;
}
void lincgreport_init_from_x(lincgreport *dst, x_lincgreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nmv = src->nmv;
    dst->terminationtype = src->terminationtype;
    dst->r2 = src->r2;
}
DLLEXPORT ae_int32_t alglib_lincgcreate(const char **errormsg, ae_int_t* n, x_lincgstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *state = x_obj_alloc_lincgstate(&_alglib_env_state);
    lincgcreate(*n, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lincgsetstartingpoint(const char **errormsg, x_lincgstate** state, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    lincgsetstartingpoint(&(*state)->obj, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lincgsetprecunit(const char **errormsg, x_lincgstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    lincgsetprecunit(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lincgsetprecdiag(const char **errormsg, x_lincgstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    lincgsetprecdiag(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lincgsetcond(const char **errormsg, x_lincgstate** state, double* epsf, ae_int_t* maxits)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    lincgsetcond(&(*state)->obj, *epsf, *maxits, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lincgsolvesparse(const char **errormsg, x_lincgstate** state, x_sparsematrix** a, bool8* isupper, x_vector* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_b, b, &_alglib_env_state);
    lincgsolvesparse(&(*state)->obj, &(*a)->obj, *isupper, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lincgresults(const char **errormsg, x_lincgstate** state, x_vector* x, x_lincgreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    lincgreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    _lincgreport_init(&_rep, &_alglib_env_state);
    lincgresults(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_lincgreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lincgsetrestartfreq(const char **errormsg, x_lincgstate** state, ae_int_t* srf)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    lincgsetrestartfreq(&(*state)->obj, *srf, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lincgsetrupdatefreq(const char **errormsg, x_lincgstate** state, ae_int_t* freq)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    lincgsetrupdatefreq(&(*state)->obj, *freq, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_lincgsetxrep(const char **errormsg, x_lincgstate** state, bool8* needxrep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    lincgsetxrep(&(*state)->obj, *needxrep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED nleqstate obj;
} x_nleqstate;
x_nleqstate* x_obj_alloc_nleqstate(ae_state *_state)
{
    x_nleqstate *result;
    result = ae_malloc(sizeof(x_nleqstate), _state);
    _nleqstate_init(&result->obj, NULL);
    return result;
}
DLLEXPORT x_nleqstate* x_obj_copy_nleqstate(x_nleqstate *src)
{
    x_nleqstate *result;
    result = ae_malloc(sizeof(x_nleqstate), NULL);
    _nleqstate_init_copy(&result->obj, &src->obj, NULL);
    return result;
}
DLLEXPORT void x_obj_free_nleqstate(x_nleqstate *obj)
{
    if( obj==NULL )
        return;
    _nleqstate_clear(&obj->obj);
    ae_free(obj);
    return;
}
DLLEXPORT void x_nleqstate_get_needf(x_nleqstate *obj, bool8 *result)
{
    *result = obj->obj.needf;
}
DLLEXPORT void x_nleqstate_set_needf(x_nleqstate *obj, bool8 *result)
{
    obj->obj.needf = *result;
}
DLLEXPORT void x_nleqstate_get_needfij(x_nleqstate *obj, bool8 *result)
{
    *result = obj->obj.needfij;
}
DLLEXPORT void x_nleqstate_set_needfij(x_nleqstate *obj, bool8 *result)
{
    obj->obj.needfij = *result;
}
DLLEXPORT void x_nleqstate_get_xupdated(x_nleqstate *obj, bool8 *result)
{
    *result = obj->obj.xupdated;
}
DLLEXPORT void x_nleqstate_set_xupdated(x_nleqstate *obj, bool8 *result)
{
    obj->obj.xupdated = *result;
}
DLLEXPORT void x_nleqstate_get_f(x_nleqstate *obj, double *result)
{
    *result = obj->obj.f;
}
DLLEXPORT void x_nleqstate_set_f(x_nleqstate *obj, double *result)
{
    obj->obj.f = *result;
}
DLLEXPORT void x_nleqstate_get_fi(x_nleqstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.fi);
}
DLLEXPORT void x_nleqstate_get_j(x_nleqstate *obj, x_matrix *result)
{
    ae_x_attach_to_matrix(result, &obj->obj.j);
}
DLLEXPORT void x_nleqstate_get_x(x_nleqstate *obj, x_vector *result)
{
    ae_x_attach_to_vector(result, &obj->obj.x);
}
typedef ALIGNED struct
{
    ALIGNED ae_int_t iterationscount;
    ALIGNED ae_int_t nfunc;
    ALIGNED ae_int_t njac;
    ALIGNED ae_int_t terminationtype;
} x_nleqreport;
void x_set_nleqreport(x_nleqreport *dst, nleqreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nfunc = src->nfunc;
    dst->njac = src->njac;
    dst->terminationtype = src->terminationtype;
}
void nleqreport_init_from_x(nleqreport *dst, x_nleqreport *src, ae_state *_state)
{
    dst->iterationscount = src->iterationscount;
    dst->nfunc = src->nfunc;
    dst->njac = src->njac;
    dst->terminationtype = src->terminationtype;
}
DLLEXPORT ae_int32_t alglib_nleqcreatelm(const char **errormsg, ae_int_t* n, ae_int_t* m, x_vector* x, x_nleqstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    *state = x_obj_alloc_nleqstate(&_alglib_env_state);
    nleqcreatelm(*n, *m, &_x, &(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_nleqsetcond(const char **errormsg, x_nleqstate** state, double* epsf, ae_int_t* maxits)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    nleqsetcond(&(*state)->obj, *epsf, *maxits, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_nleqsetxrep(const char **errormsg, x_nleqstate** state, bool8* needxrep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    nleqsetxrep(&(*state)->obj, *needxrep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_nleqsetstpmax(const char **errormsg, x_nleqstate** state, double* stpmax)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    nleqsetstpmax(&(*state)->obj, *stpmax, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_nleqiteration(const char **errormsg, bool8* result, x_nleqstate** state)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = nleqiteration(&(*state)->obj, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_nleqresults(const char **errormsg, x_nleqstate** state, x_vector* x, x_nleqreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    nleqreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_x, 0, DT_REAL, &_alglib_env_state);
    _nleqreport_init(&_rep, &_alglib_env_state);
    nleqresults(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_nleqreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_nleqresultsbuf(const char **errormsg, x_nleqstate** state, x_vector* x, x_nleqreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    nleqreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    nleqreport_init_from_x(&_rep, rep, &_alglib_env_state);
    nleqresultsbuf(&(*state)->obj, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_nleqreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_nleqrestartfrom(const char **errormsg, x_nleqstate** state, x_vector* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    nleqrestartfrom(&(*state)->obj, &_x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
typedef ALIGNED struct
{
    ALIGNED double maxerr;
} x_polynomialsolverreport;
void x_set_polynomialsolverreport(x_polynomialsolverreport *dst, polynomialsolverreport *src, ae_state *_state)
{
    dst->maxerr = src->maxerr;
}
void polynomialsolverreport_init_from_x(polynomialsolverreport *dst, x_polynomialsolverreport *src, ae_state *_state)
{
    dst->maxerr = src->maxerr;
}
DLLEXPORT ae_int32_t alglib_polynomialsolve(const char **errormsg, x_vector* a, ae_int_t* n, x_vector* x, x_polynomialsolverreport* rep)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_vector _x;
    polynomialsolverreport _rep;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_x, 0, DT_COMPLEX, &_alglib_env_state);
    _polynomialsolverreport_init(&_rep, &_alglib_env_state);
    polynomialsolve(&_a, *n, &_x, &_rep, &_alglib_env_state);
    ae_x_set_vector(x, &_x, &_alglib_env_state);
    x_set_polynomialsolverreport(rep, &_rep, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_airy(const char **errormsg, double* x, double* ai, double* aip, double* bi, double* bip)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    airy(*x, ai, aip, bi, bip, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_besselj0(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = besselj0(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_besselj1(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = besselj1(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_besseljn(const char **errormsg, double* result, ae_int_t* n, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = besseljn(*n, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_bessely0(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = bessely0(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_bessely1(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = bessely1(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_besselyn(const char **errormsg, double* result, ae_int_t* n, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = besselyn(*n, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_besseli0(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = besseli0(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_besseli1(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = besseli1(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_besselk0(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = besselk0(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_besselk1(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = besselk1(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_besselkn(const char **errormsg, double* result, ae_int_t* nn, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = besselkn(*nn, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_beta(const char **errormsg, double* result, double* a, double* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = beta(*a, *b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_incompletebeta(const char **errormsg, double* result, double* a, double* b, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = incompletebeta(*a, *b, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_invincompletebeta(const char **errormsg, double* result, double* a, double* b, double* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = invincompletebeta(*a, *b, *y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_binomialdistribution(const char **errormsg, double* result, ae_int_t* k, ae_int_t* n, double* p)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = binomialdistribution(*k, *n, *p, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_binomialcdistribution(const char **errormsg, double* result, ae_int_t* k, ae_int_t* n, double* p)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = binomialcdistribution(*k, *n, *p, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_invbinomialdistribution(const char **errormsg, double* result, ae_int_t* k, ae_int_t* n, double* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = invbinomialdistribution(*k, *n, *y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_chebyshevcalculate(const char **errormsg, double* result, ae_int_t* r, ae_int_t* n, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = chebyshevcalculate(*r, *n, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_chebyshevsum(const char **errormsg, double* result, x_vector* c, ae_int_t* r, ae_int_t* n, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_c, c, &_alglib_env_state);
    *result = chebyshevsum(&_c, *r, *n, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_chebyshevcoefficients(const char **errormsg, ae_int_t* n, x_vector* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    chebyshevcoefficients(*n, &_c, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_fromchebyshev(const char **errormsg, x_vector* a, ae_int_t* n, x_vector* b)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _a;
    ae_vector _b;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_a, a, &_alglib_env_state);
    ae_vector_init(&_b, 0, DT_REAL, &_alglib_env_state);
    fromchebyshev(&_a, *n, &_b, &_alglib_env_state);
    ae_x_set_vector(b, &_b, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_chisquaredistribution(const char **errormsg, double* result, double* v, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = chisquaredistribution(*v, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_chisquarecdistribution(const char **errormsg, double* result, double* v, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = chisquarecdistribution(*v, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_invchisquaredistribution(const char **errormsg, double* result, double* v, double* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = invchisquaredistribution(*v, *y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_dawsonintegral(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = dawsonintegral(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_ellipticintegralk(const char **errormsg, double* result, double* m)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = ellipticintegralk(*m, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_ellipticintegralkhighprecision(const char **errormsg, double* result, double* m1)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = ellipticintegralkhighprecision(*m1, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_incompleteellipticintegralk(const char **errormsg, double* result, double* phi, double* m)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = incompleteellipticintegralk(*phi, *m, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_ellipticintegrale(const char **errormsg, double* result, double* m)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = ellipticintegrale(*m, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_incompleteellipticintegrale(const char **errormsg, double* result, double* phi, double* m)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = incompleteellipticintegrale(*phi, *m, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_exponentialintegralei(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = exponentialintegralei(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_exponentialintegralen(const char **errormsg, double* result, double* x, ae_int_t* n)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = exponentialintegralen(*x, *n, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_fdistribution(const char **errormsg, double* result, ae_int_t* a, ae_int_t* b, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = fdistribution(*a, *b, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_fcdistribution(const char **errormsg, double* result, ae_int_t* a, ae_int_t* b, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = fcdistribution(*a, *b, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_invfdistribution(const char **errormsg, double* result, ae_int_t* a, ae_int_t* b, double* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = invfdistribution(*a, *b, *y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_fresnelintegral(const char **errormsg, double* x, double* c, double* s)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    fresnelintegral(*x, c, s, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hermitecalculate(const char **errormsg, double* result, ae_int_t* n, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = hermitecalculate(*n, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hermitesum(const char **errormsg, double* result, x_vector* c, ae_int_t* n, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_c, c, &_alglib_env_state);
    *result = hermitesum(&_c, *n, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hermitecoefficients(const char **errormsg, ae_int_t* n, x_vector* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    hermitecoefficients(*n, &_c, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_jacobianellipticfunctions(const char **errormsg, double* u, double* m, double* sn, double* cn, double* dn, double* ph)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    jacobianellipticfunctions(*u, *m, sn, cn, dn, ph, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_laguerrecalculate(const char **errormsg, double* result, ae_int_t* n, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = laguerrecalculate(*n, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_laguerresum(const char **errormsg, double* result, x_vector* c, ae_int_t* n, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_c, c, &_alglib_env_state);
    *result = laguerresum(&_c, *n, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_laguerrecoefficients(const char **errormsg, ae_int_t* n, x_vector* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    laguerrecoefficients(*n, &_c, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_legendrecalculate(const char **errormsg, double* result, ae_int_t* n, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = legendrecalculate(*n, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_legendresum(const char **errormsg, double* result, x_vector* c, ae_int_t* n, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_c, c, &_alglib_env_state);
    *result = legendresum(&_c, *n, *x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_legendrecoefficients(const char **errormsg, ae_int_t* n, x_vector* c)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _c;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_init(&_c, 0, DT_REAL, &_alglib_env_state);
    legendrecoefficients(*n, &_c, &_alglib_env_state);
    ae_x_set_vector(c, &_c, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_poissondistribution(const char **errormsg, double* result, ae_int_t* k, double* m)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = poissondistribution(*k, *m, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_poissoncdistribution(const char **errormsg, double* result, ae_int_t* k, double* m)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = poissoncdistribution(*k, *m, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_invpoissondistribution(const char **errormsg, double* result, ae_int_t* k, double* y)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = invpoissondistribution(*k, *y, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_psi(const char **errormsg, double* result, double* x)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = psi(*x, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_studenttdistribution(const char **errormsg, double* result, ae_int_t* k, double* t)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = studenttdistribution(*k, *t, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_invstudenttdistribution(const char **errormsg, double* result, ae_int_t* k, double* p)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    *result = invstudenttdistribution(*k, *p, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_sinecosineintegrals(const char **errormsg, double* x, double* si, double* ci)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    sinecosineintegrals(*x, si, ci, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_hyperbolicsinecosineintegrals(const char **errormsg, double* x, double* shi, double* chi)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    hyperbolicsinecosineintegrals(*x, shi, chi, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_pearsoncorrelationsignificance(const char **errormsg, double* r, ae_int_t* n, double* bothtails, double* lefttail, double* righttail)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    pearsoncorrelationsignificance(*r, *n, bothtails, lefttail, righttail, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_spearmanrankcorrelationsignificance(const char **errormsg, double* r, ae_int_t* n, double* bothtails, double* lefttail, double* righttail)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    spearmanrankcorrelationsignificance(*r, *n, bothtails, lefttail, righttail, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_jarqueberatest(const char **errormsg, x_vector* x, ae_int_t* n, double* p)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    jarqueberatest(&_x, *n, p, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_mannwhitneyutest(const char **errormsg, x_vector* x, ae_int_t* n, x_vector* y, ae_int_t* m, double* bothtails, double* lefttail, double* righttail)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    mannwhitneyutest(&_x, *n, &_y, *m, bothtails, lefttail, righttail, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_onesamplesigntest(const char **errormsg, x_vector* x, ae_int_t* n, double* median, double* bothtails, double* lefttail, double* righttail)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    onesamplesigntest(&_x, *n, *median, bothtails, lefttail, righttail, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_studentttest1(const char **errormsg, x_vector* x, ae_int_t* n, double* mean, double* bothtails, double* lefttail, double* righttail)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    studentttest1(&_x, *n, *mean, bothtails, lefttail, righttail, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_studentttest2(const char **errormsg, x_vector* x, ae_int_t* n, x_vector* y, ae_int_t* m, double* bothtails, double* lefttail, double* righttail)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    studentttest2(&_x, *n, &_y, *m, bothtails, lefttail, righttail, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_unequalvariancettest(const char **errormsg, x_vector* x, ae_int_t* n, x_vector* y, ae_int_t* m, double* bothtails, double* lefttail, double* righttail)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    unequalvariancettest(&_x, *n, &_y, *m, bothtails, lefttail, righttail, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_ftest(const char **errormsg, x_vector* x, ae_int_t* n, x_vector* y, ae_int_t* m, double* bothtails, double* lefttail, double* righttail)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_vector _y;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    ae_vector_attach_to_x(&_y, y, &_alglib_env_state);
    ftest(&_x, *n, &_y, *m, bothtails, lefttail, righttail, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_onesamplevariancetest(const char **errormsg, x_vector* x, ae_int_t* n, double* variance, double* bothtails, double* lefttail, double* righttail)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    onesamplevariancetest(&_x, *n, *variance, bothtails, lefttail, righttail, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
DLLEXPORT ae_int32_t alglib_wilcoxonsignedranktest(const char **errormsg, x_vector* x, ae_int_t* n, double* e, double* bothtails, double* lefttail, double* righttail)
{
    ae_state _alglib_env_state;
    ae_frame _frame_block;
    jmp_buf _break_jump;
    ae_vector _x;
    ae_state_init(&_alglib_env_state);
    if( setjmp(_break_jump) )
    {
        if( _alglib_env_state.last_error==ERR_OUT_OF_MEMORY )    { *errormsg = "ALGLIB: malloc error"; return X_MALLOC_ERROR; }
        if( _alglib_env_state.last_error==ERR_XARRAY_TOO_LARGE ) { *errormsg = "ALGLIB: array too large"; return X_ARRAY_TOO_LARGE; }
        if( _alglib_env_state.last_error==ERR_ASSERTION_FAILED ) { *errormsg = _alglib_env_state.error_msg; return X_ASSERTION_FAILED; }
        return -1;
    }
    ae_state_set_break_jump(&_alglib_env_state, &_break_jump);
    ae_frame_make(&_alglib_env_state, &_frame_block);
    ae_vector_attach_to_x(&_x, x, &_alglib_env_state);
    wilcoxonsignedranktest(&_x, *n, *e, bothtails, lefttail, righttail, &_alglib_env_state);
    ae_state_clear(&_alglib_env_state);
    return X_OK;
}
