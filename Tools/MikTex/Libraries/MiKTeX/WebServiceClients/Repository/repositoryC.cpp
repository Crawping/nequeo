/* repositoryC.cpp
   Generated by gSOAP 2.8.29 for Repository.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "repositoryH.h"

SOAP_SOURCE_STAMP("@(#) repositoryC.cpp ver 2.8.29 2016-03-02 19:48:13 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_mtrep7__RepositoryReleaseState:
		return soap_in_mtrep7__RepositoryReleaseState(soap, NULL, NULL, "mtrep7:RepositoryReleaseState");
	case SOAP_TYPE_mtrep7__RepositoryStatus:
		return soap_in_mtrep7__RepositoryStatus(soap, NULL, NULL, "mtrep7:RepositoryStatus");
	case SOAP_TYPE_mtrep7__PackageLevel:
		return soap_in_mtrep7__PackageLevel(soap, NULL, NULL, "mtrep7:PackageLevel");
	case SOAP_TYPE_mtrep7__RepositoryIntegrity:
		return soap_in_mtrep7__RepositoryIntegrity(soap, NULL, NULL, "mtrep7:RepositoryIntegrity");
	case SOAP_TYPE_mtrep6__RepositoryStatus:
		return soap_in_mtrep6__RepositoryStatus(soap, NULL, NULL, "mtrep6:RepositoryStatus");
	case SOAP_TYPE_mtrep6__PackageLevel:
		return soap_in_mtrep6__PackageLevel(soap, NULL, NULL, "mtrep6:PackageLevel");
	case SOAP_TYPE_mtrep6__RepositoryIntegrity:
		return soap_in_mtrep6__RepositoryIntegrity(soap, NULL, NULL, "mtrep6:RepositoryIntegrity");
	case SOAP_TYPE_mtrep6__RepositoryReleaseState:
		return soap_in_mtrep6__RepositoryReleaseState(soap, NULL, NULL, "mtrep6:RepositoryReleaseState");
	case SOAP_TYPE_mtrep5__RepositoryStatus:
		return soap_in_mtrep5__RepositoryStatus(soap, NULL, NULL, "mtrep5:RepositoryStatus");
	case SOAP_TYPE_mtrep5__PackageLevel:
		return soap_in_mtrep5__PackageLevel(soap, NULL, NULL, "mtrep5:PackageLevel");
	case SOAP_TYPE_mtrep5__RepositoryIntegrity:
		return soap_in_mtrep5__RepositoryIntegrity(soap, NULL, NULL, "mtrep5:RepositoryIntegrity");
	case SOAP_TYPE_mtrep4__RepositoryStatus:
		return soap_in_mtrep4__RepositoryStatus(soap, NULL, NULL, "mtrep4:RepositoryStatus");
	case SOAP_TYPE_mtrep4__PackageLevel:
		return soap_in_mtrep4__PackageLevel(soap, NULL, NULL, "mtrep4:PackageLevel");
	case SOAP_TYPE_mtrep4__RepositoryIntegrity:
		return soap_in_mtrep4__RepositoryIntegrity(soap, NULL, NULL, "mtrep4:RepositoryIntegrity");
	case SOAP_TYPE_mtrep3__RepositoryStatus:
		return soap_in_mtrep3__RepositoryStatus(soap, NULL, NULL, "mtrep3:RepositoryStatus");
	case SOAP_TYPE_mtrep3__PackageLevel:
		return soap_in_mtrep3__PackageLevel(soap, NULL, NULL, "mtrep3:PackageLevel");
	case SOAP_TYPE_mtrep3__RepositoryIntegrity:
		return soap_in_mtrep3__RepositoryIntegrity(soap, NULL, NULL, "mtrep3:RepositoryIntegrity");
	case SOAP_TYPE_mtrep__RepositoryStatus:
		return soap_in_mtrep__RepositoryStatus(soap, NULL, NULL, "mtrep:RepositoryStatus");
	case SOAP_TYPE_mtrep__PackageLevel:
		return soap_in_mtrep__PackageLevel(soap, NULL, NULL, "mtrep:PackageLevel");
	case SOAP_TYPE_mtrep__RepositoryIntegrity:
		return soap_in_mtrep__RepositoryIntegrity(soap, NULL, NULL, "mtrep:RepositoryIntegrity");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_mtrep7__RepositoryInfo:
		return soap_in_mtrep7__RepositoryInfo(soap, NULL, NULL, "mtrep7:RepositoryInfo");
	case SOAP_TYPE_mtrep7__RepositoryInfo2:
		return soap_in_mtrep7__RepositoryInfo2(soap, NULL, NULL, "mtrep7:RepositoryInfo2");
	case SOAP_TYPE_mtrep7__RepositoryInfo3:
		return soap_in_mtrep7__RepositoryInfo3(soap, NULL, NULL, "mtrep7:RepositoryInfo3");
	case SOAP_TYPE_mtrep7__ClientInfo:
		return soap_in_mtrep7__ClientInfo(soap, NULL, NULL, "mtrep7:ClientInfo");
	case SOAP_TYPE_mtrep6__RepositoryInfo:
		return soap_in_mtrep6__RepositoryInfo(soap, NULL, NULL, "mtrep6:RepositoryInfo");
	case SOAP_TYPE_mtrep6__RepositoryInfo2:
		return soap_in_mtrep6__RepositoryInfo2(soap, NULL, NULL, "mtrep6:RepositoryInfo2");
	case SOAP_TYPE_mtrep6__RepositoryInfo3:
		return soap_in_mtrep6__RepositoryInfo3(soap, NULL, NULL, "mtrep6:RepositoryInfo3");
	case SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3:
		return soap_in_mtrep6__ArrayOfRepositoryInfo3(soap, NULL, NULL, "mtrep6:ArrayOfRepositoryInfo3");
	case SOAP_TYPE_mtrep6__ClientInfo:
		return soap_in_mtrep6__ClientInfo(soap, NULL, NULL, "mtrep6:ClientInfo");
	case SOAP_TYPE_mtrep5__RepositoryInfo:
		return soap_in_mtrep5__RepositoryInfo(soap, NULL, NULL, "mtrep5:RepositoryInfo");
	case SOAP_TYPE_mtrep5__RepositoryInfo2:
		return soap_in_mtrep5__RepositoryInfo2(soap, NULL, NULL, "mtrep5:RepositoryInfo2");
	case SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2:
		return soap_in_mtrep5__ArrayOfRepositoryInfo2(soap, NULL, NULL, "mtrep5:ArrayOfRepositoryInfo2");
	case SOAP_TYPE_mtrep5__ClientInfo:
		return soap_in_mtrep5__ClientInfo(soap, NULL, NULL, "mtrep5:ClientInfo");
	case SOAP_TYPE_mtrep4__RepositoryInfo:
		return soap_in_mtrep4__RepositoryInfo(soap, NULL, NULL, "mtrep4:RepositoryInfo");
	case SOAP_TYPE_mtrep4__ClientInfo:
		return soap_in_mtrep4__ClientInfo(soap, NULL, NULL, "mtrep4:ClientInfo");
	case SOAP_TYPE_mtrep3__RepositoryInfo:
		return soap_in_mtrep3__RepositoryInfo(soap, NULL, NULL, "mtrep3:RepositoryInfo");
	case SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo:
		return soap_in_mtrep3__ArrayOfRepositoryInfo(soap, NULL, NULL, "mtrep3:ArrayOfRepositoryInfo");
	case SOAP_TYPE_mtrep3__ClientInfo:
		return soap_in_mtrep3__ClientInfo(soap, NULL, NULL, "mtrep3:ClientInfo");
	case SOAP_TYPE_mtrep__ArrayOfRepositoryInfo:
		return soap_in_mtrep__ArrayOfRepositoryInfo(soap, NULL, NULL, "mtrep:ArrayOfRepositoryInfo");
	case SOAP_TYPE_mtrep__RepositoryInfo:
		return soap_in_mtrep__RepositoryInfo(soap, NULL, NULL, "mtrep:RepositoryInfo");
	case SOAP_TYPE_PointerTo_mtrep7__TryGetRepositoryInfo3:
		return soap_in_PointerTo_mtrep7__TryGetRepositoryInfo3(soap, NULL, NULL, "mtrep7:TryGetRepositoryInfo3");
	case SOAP_TYPE_PointerTo_mtrep7__VerifyRepository2:
		return soap_in_PointerTo_mtrep7__VerifyRepository2(soap, NULL, NULL, "mtrep7:VerifyRepository2");
	case SOAP_TYPE_PointerTo_mtrep6__PickRepository4:
		return soap_in_PointerTo_mtrep6__PickRepository4(soap, NULL, NULL, "mtrep6:PickRepository4");
	case SOAP_TYPE_PointerTo_mtrep6__GetRepositories4:
		return soap_in_PointerTo_mtrep6__GetRepositories4(soap, NULL, NULL, "mtrep6:GetRepositories4");
	case SOAP_TYPE_PointerTo_mtrep5__PickRepository3:
		return soap_in_PointerTo_mtrep5__PickRepository3(soap, NULL, NULL, "mtrep5:PickRepository3");
	case SOAP_TYPE_PointerTo_mtrep5__GetRepositories3:
		return soap_in_PointerTo_mtrep5__GetRepositories3(soap, NULL, NULL, "mtrep5:GetRepositories3");
	case SOAP_TYPE_PointerTo_mtrep4__VerifyRepository:
		return soap_in_PointerTo_mtrep4__VerifyRepository(soap, NULL, NULL, "mtrep4:VerifyRepository");
	case SOAP_TYPE_PointerTo_mtrep3__TryGetRepositoryInfo2:
		return soap_in_PointerTo_mtrep3__TryGetRepositoryInfo2(soap, NULL, NULL, "mtrep3:TryGetRepositoryInfo2");
	case SOAP_TYPE_PointerTo_mtrep3__PickRepository2:
		return soap_in_PointerTo_mtrep3__PickRepository2(soap, NULL, NULL, "mtrep3:PickRepository2");
	case SOAP_TYPE_PointerTo_mtrep3__GetRepositories2:
		return soap_in_PointerTo_mtrep3__GetRepositories2(soap, NULL, NULL, "mtrep3:GetRepositories2");
	case SOAP_TYPE_PointerTo_mtrep2__GetListCreationTime:
		return soap_in_PointerTo_mtrep2__GetListCreationTime(soap, NULL, NULL, "mtrep2:GetListCreationTime");
	case SOAP_TYPE_PointerTo_mtrep__GetRepositories:
		return soap_in_PointerTo_mtrep__GetRepositories(soap, NULL, NULL, "mtrep:GetRepositories");
	case SOAP_TYPE_PointerTo_mtrep__GetAllRepositories:
		return soap_in_PointerTo_mtrep__GetAllRepositories(soap, NULL, NULL, "mtrep:GetAllRepositories");
	case SOAP_TYPE_PointerTo_mtrep__PickRepository:
		return soap_in_PointerTo_mtrep__PickRepository(soap, NULL, NULL, "mtrep:PickRepository");
	case SOAP_TYPE_PointerTo_mtrep__TryGetRepositoryInfo:
		return soap_in_PointerTo_mtrep__TryGetRepositoryInfo(soap, NULL, NULL, "mtrep:TryGetRepositoryInfo");
	case SOAP_TYPE_PointerTomtrep7__RepositoryInfo3:
		return soap_in_PointerTomtrep7__RepositoryInfo3(soap, NULL, NULL, "mtrep7:RepositoryInfo3");
	case SOAP_TYPE_PointerTomtrep7__ClientInfo:
		return soap_in_PointerTomtrep7__ClientInfo(soap, NULL, NULL, "mtrep7:ClientInfo");
	case SOAP_TYPE_PointerTomtrep6__ArrayOfRepositoryInfo3:
		return soap_in_PointerTomtrep6__ArrayOfRepositoryInfo3(soap, NULL, NULL, "mtrep6:ArrayOfRepositoryInfo3");
	case SOAP_TYPE_PointerTomtrep6__ClientInfo:
		return soap_in_PointerTomtrep6__ClientInfo(soap, NULL, NULL, "mtrep6:ClientInfo");
	case SOAP_TYPE_PointerTomtrep6__RepositoryInfo3:
		return soap_in_PointerTomtrep6__RepositoryInfo3(soap, NULL, NULL, "mtrep6:RepositoryInfo3");
	case SOAP_TYPE_PointerTomtrep5__ArrayOfRepositoryInfo2:
		return soap_in_PointerTomtrep5__ArrayOfRepositoryInfo2(soap, NULL, NULL, "mtrep5:ArrayOfRepositoryInfo2");
	case SOAP_TYPE_PointerTomtrep5__ClientInfo:
		return soap_in_PointerTomtrep5__ClientInfo(soap, NULL, NULL, "mtrep5:ClientInfo");
	case SOAP_TYPE_PointerTomtrep5__RepositoryInfo2:
		return soap_in_PointerTomtrep5__RepositoryInfo2(soap, NULL, NULL, "mtrep5:RepositoryInfo2");
	case SOAP_TYPE_PointerTomtrep4__RepositoryInfo:
		return soap_in_PointerTomtrep4__RepositoryInfo(soap, NULL, NULL, "mtrep4:RepositoryInfo");
	case SOAP_TYPE_PointerTomtrep4__ClientInfo:
		return soap_in_PointerTomtrep4__ClientInfo(soap, NULL, NULL, "mtrep4:ClientInfo");
	case SOAP_TYPE_PointerTomtrep3__ArrayOfRepositoryInfo:
		return soap_in_PointerTomtrep3__ArrayOfRepositoryInfo(soap, NULL, NULL, "mtrep3:ArrayOfRepositoryInfo");
	case SOAP_TYPE_PointerTomtrep3__ClientInfo:
		return soap_in_PointerTomtrep3__ClientInfo(soap, NULL, NULL, "mtrep3:ClientInfo");
	case SOAP_TYPE_PointerTomtrep3__RepositoryInfo:
		return soap_in_PointerTomtrep3__RepositoryInfo(soap, NULL, NULL, "mtrep3:RepositoryInfo");
	case SOAP_TYPE_PointerTomtrep__ArrayOfRepositoryInfo:
		return soap_in_PointerTomtrep__ArrayOfRepositoryInfo(soap, NULL, NULL, "mtrep:ArrayOfRepositoryInfo");
	case SOAP_TYPE_PointerTomtrep__RepositoryInfo:
		return soap_in_PointerTomtrep__RepositoryInfo(soap, NULL, NULL, "mtrep:RepositoryInfo");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep7:RepositoryInfo"))
		{	*type = SOAP_TYPE_mtrep7__RepositoryInfo;
			return soap_in_mtrep7__RepositoryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep7:RepositoryInfo2"))
		{	*type = SOAP_TYPE_mtrep7__RepositoryInfo2;
			return soap_in_mtrep7__RepositoryInfo2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep7:RepositoryInfo3"))
		{	*type = SOAP_TYPE_mtrep7__RepositoryInfo3;
			return soap_in_mtrep7__RepositoryInfo3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep7:ClientInfo"))
		{	*type = SOAP_TYPE_mtrep7__ClientInfo;
			return soap_in_mtrep7__ClientInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep6:RepositoryInfo"))
		{	*type = SOAP_TYPE_mtrep6__RepositoryInfo;
			return soap_in_mtrep6__RepositoryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep6:RepositoryInfo2"))
		{	*type = SOAP_TYPE_mtrep6__RepositoryInfo2;
			return soap_in_mtrep6__RepositoryInfo2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep6:RepositoryInfo3"))
		{	*type = SOAP_TYPE_mtrep6__RepositoryInfo3;
			return soap_in_mtrep6__RepositoryInfo3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep6:ArrayOfRepositoryInfo3"))
		{	*type = SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3;
			return soap_in_mtrep6__ArrayOfRepositoryInfo3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep6:ClientInfo"))
		{	*type = SOAP_TYPE_mtrep6__ClientInfo;
			return soap_in_mtrep6__ClientInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep5:RepositoryInfo"))
		{	*type = SOAP_TYPE_mtrep5__RepositoryInfo;
			return soap_in_mtrep5__RepositoryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep5:RepositoryInfo2"))
		{	*type = SOAP_TYPE_mtrep5__RepositoryInfo2;
			return soap_in_mtrep5__RepositoryInfo2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep5:ArrayOfRepositoryInfo2"))
		{	*type = SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2;
			return soap_in_mtrep5__ArrayOfRepositoryInfo2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep5:ClientInfo"))
		{	*type = SOAP_TYPE_mtrep5__ClientInfo;
			return soap_in_mtrep5__ClientInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep4:RepositoryInfo"))
		{	*type = SOAP_TYPE_mtrep4__RepositoryInfo;
			return soap_in_mtrep4__RepositoryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep4:ClientInfo"))
		{	*type = SOAP_TYPE_mtrep4__ClientInfo;
			return soap_in_mtrep4__ClientInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep3:RepositoryInfo"))
		{	*type = SOAP_TYPE_mtrep3__RepositoryInfo;
			return soap_in_mtrep3__RepositoryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep3:ArrayOfRepositoryInfo"))
		{	*type = SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo;
			return soap_in_mtrep3__ArrayOfRepositoryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep3:ClientInfo"))
		{	*type = SOAP_TYPE_mtrep3__ClientInfo;
			return soap_in_mtrep3__ClientInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep:ArrayOfRepositoryInfo"))
		{	*type = SOAP_TYPE_mtrep__ArrayOfRepositoryInfo;
			return soap_in_mtrep__ArrayOfRepositoryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep:RepositoryInfo"))
		{	*type = SOAP_TYPE_mtrep__RepositoryInfo;
			return soap_in_mtrep__RepositoryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep7:RepositoryReleaseState"))
		{	*type = SOAP_TYPE_mtrep7__RepositoryReleaseState;
			return soap_in_mtrep7__RepositoryReleaseState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep7:RepositoryStatus"))
		{	*type = SOAP_TYPE_mtrep7__RepositoryStatus;
			return soap_in_mtrep7__RepositoryStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep7:PackageLevel"))
		{	*type = SOAP_TYPE_mtrep7__PackageLevel;
			return soap_in_mtrep7__PackageLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep7:RepositoryIntegrity"))
		{	*type = SOAP_TYPE_mtrep7__RepositoryIntegrity;
			return soap_in_mtrep7__RepositoryIntegrity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep6:RepositoryStatus"))
		{	*type = SOAP_TYPE_mtrep6__RepositoryStatus;
			return soap_in_mtrep6__RepositoryStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep6:PackageLevel"))
		{	*type = SOAP_TYPE_mtrep6__PackageLevel;
			return soap_in_mtrep6__PackageLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep6:RepositoryIntegrity"))
		{	*type = SOAP_TYPE_mtrep6__RepositoryIntegrity;
			return soap_in_mtrep6__RepositoryIntegrity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep6:RepositoryReleaseState"))
		{	*type = SOAP_TYPE_mtrep6__RepositoryReleaseState;
			return soap_in_mtrep6__RepositoryReleaseState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep5:RepositoryStatus"))
		{	*type = SOAP_TYPE_mtrep5__RepositoryStatus;
			return soap_in_mtrep5__RepositoryStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep5:PackageLevel"))
		{	*type = SOAP_TYPE_mtrep5__PackageLevel;
			return soap_in_mtrep5__PackageLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep5:RepositoryIntegrity"))
		{	*type = SOAP_TYPE_mtrep5__RepositoryIntegrity;
			return soap_in_mtrep5__RepositoryIntegrity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep4:RepositoryStatus"))
		{	*type = SOAP_TYPE_mtrep4__RepositoryStatus;
			return soap_in_mtrep4__RepositoryStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep4:PackageLevel"))
		{	*type = SOAP_TYPE_mtrep4__PackageLevel;
			return soap_in_mtrep4__PackageLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep4:RepositoryIntegrity"))
		{	*type = SOAP_TYPE_mtrep4__RepositoryIntegrity;
			return soap_in_mtrep4__RepositoryIntegrity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep3:RepositoryStatus"))
		{	*type = SOAP_TYPE_mtrep3__RepositoryStatus;
			return soap_in_mtrep3__RepositoryStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep3:PackageLevel"))
		{	*type = SOAP_TYPE_mtrep3__PackageLevel;
			return soap_in_mtrep3__PackageLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep3:RepositoryIntegrity"))
		{	*type = SOAP_TYPE_mtrep3__RepositoryIntegrity;
			return soap_in_mtrep3__RepositoryIntegrity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep:RepositoryStatus"))
		{	*type = SOAP_TYPE_mtrep__RepositoryStatus;
			return soap_in_mtrep__RepositoryStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep:PackageLevel"))
		{	*type = SOAP_TYPE_mtrep__PackageLevel;
			return soap_in_mtrep__PackageLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep:RepositoryIntegrity"))
		{	*type = SOAP_TYPE_mtrep__RepositoryIntegrity;
			return soap_in_mtrep__RepositoryIntegrity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "mtrep7:TryGetRepositoryInfo3Response"))
		{	*type = SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response;
			return soap_in__mtrep7__TryGetRepositoryInfo3Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep7:TryGetRepositoryInfo3"))
		{	*type = SOAP_TYPE__mtrep7__TryGetRepositoryInfo3;
			return soap_in__mtrep7__TryGetRepositoryInfo3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep7:VerifyRepository2Response"))
		{	*type = SOAP_TYPE__mtrep7__VerifyRepository2Response;
			return soap_in__mtrep7__VerifyRepository2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep7:VerifyRepository2"))
		{	*type = SOAP_TYPE__mtrep7__VerifyRepository2;
			return soap_in__mtrep7__VerifyRepository2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep6:PickRepository4Response"))
		{	*type = SOAP_TYPE__mtrep6__PickRepository4Response;
			return soap_in__mtrep6__PickRepository4Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep6:PickRepository4"))
		{	*type = SOAP_TYPE__mtrep6__PickRepository4;
			return soap_in__mtrep6__PickRepository4(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep6:GetRepositories4Response"))
		{	*type = SOAP_TYPE__mtrep6__GetRepositories4Response;
			return soap_in__mtrep6__GetRepositories4Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep6:GetRepositories4"))
		{	*type = SOAP_TYPE__mtrep6__GetRepositories4;
			return soap_in__mtrep6__GetRepositories4(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep5:PickRepository3Response"))
		{	*type = SOAP_TYPE__mtrep5__PickRepository3Response;
			return soap_in__mtrep5__PickRepository3Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep5:PickRepository3"))
		{	*type = SOAP_TYPE__mtrep5__PickRepository3;
			return soap_in__mtrep5__PickRepository3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep5:GetRepositories3Response"))
		{	*type = SOAP_TYPE__mtrep5__GetRepositories3Response;
			return soap_in__mtrep5__GetRepositories3Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep5:GetRepositories3"))
		{	*type = SOAP_TYPE__mtrep5__GetRepositories3;
			return soap_in__mtrep5__GetRepositories3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep4:VerifyRepositoryResponse"))
		{	*type = SOAP_TYPE__mtrep4__VerifyRepositoryResponse;
			return soap_in__mtrep4__VerifyRepositoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep4:VerifyRepository"))
		{	*type = SOAP_TYPE__mtrep4__VerifyRepository;
			return soap_in__mtrep4__VerifyRepository(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep3:TryGetRepositoryInfo2Response"))
		{	*type = SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response;
			return soap_in__mtrep3__TryGetRepositoryInfo2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep3:TryGetRepositoryInfo2"))
		{	*type = SOAP_TYPE__mtrep3__TryGetRepositoryInfo2;
			return soap_in__mtrep3__TryGetRepositoryInfo2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep3:PickRepository2Response"))
		{	*type = SOAP_TYPE__mtrep3__PickRepository2Response;
			return soap_in__mtrep3__PickRepository2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep3:PickRepository2"))
		{	*type = SOAP_TYPE__mtrep3__PickRepository2;
			return soap_in__mtrep3__PickRepository2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep3:GetRepositories2Response"))
		{	*type = SOAP_TYPE__mtrep3__GetRepositories2Response;
			return soap_in__mtrep3__GetRepositories2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep3:GetRepositories2"))
		{	*type = SOAP_TYPE__mtrep3__GetRepositories2;
			return soap_in__mtrep3__GetRepositories2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep2:GetListCreationTimeResponse"))
		{	*type = SOAP_TYPE__mtrep2__GetListCreationTimeResponse;
			return soap_in__mtrep2__GetListCreationTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep2:GetListCreationTime"))
		{	*type = SOAP_TYPE__mtrep2__GetListCreationTime;
			return soap_in__mtrep2__GetListCreationTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep:GetRepositoriesResponse"))
		{	*type = SOAP_TYPE__mtrep__GetRepositoriesResponse;
			return soap_in__mtrep__GetRepositoriesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep:GetRepositories"))
		{	*type = SOAP_TYPE__mtrep__GetRepositories;
			return soap_in__mtrep__GetRepositories(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep:GetAllRepositoriesResponse"))
		{	*type = SOAP_TYPE__mtrep__GetAllRepositoriesResponse;
			return soap_in__mtrep__GetAllRepositoriesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep:GetAllRepositories"))
		{	*type = SOAP_TYPE__mtrep__GetAllRepositories;
			return soap_in__mtrep__GetAllRepositories(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep:PickRepositoryResponse"))
		{	*type = SOAP_TYPE__mtrep__PickRepositoryResponse;
			return soap_in__mtrep__PickRepositoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep:PickRepository"))
		{	*type = SOAP_TYPE__mtrep__PickRepository;
			return soap_in__mtrep__PickRepository(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep:TryGetRepositoryInfoResponse"))
		{	*type = SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse;
			return soap_in__mtrep__TryGetRepositoryInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mtrep:TryGetRepositoryInfo"))
		{	*type = SOAP_TYPE__mtrep__TryGetRepositoryInfo;
			return soap_in__mtrep__TryGetRepositoryInfo(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_mtrep7__RepositoryReleaseState:
		return soap_out_mtrep7__RepositoryReleaseState(soap, tag, id, (const enum mtrep7__RepositoryReleaseState *)ptr, "mtrep7:RepositoryReleaseState");
	case SOAP_TYPE_mtrep7__RepositoryStatus:
		return soap_out_mtrep7__RepositoryStatus(soap, tag, id, (const enum mtrep7__RepositoryStatus *)ptr, "mtrep7:RepositoryStatus");
	case SOAP_TYPE_mtrep7__PackageLevel:
		return soap_out_mtrep7__PackageLevel(soap, tag, id, (const enum mtrep7__PackageLevel *)ptr, "mtrep7:PackageLevel");
	case SOAP_TYPE_mtrep7__RepositoryIntegrity:
		return soap_out_mtrep7__RepositoryIntegrity(soap, tag, id, (const enum mtrep7__RepositoryIntegrity *)ptr, "mtrep7:RepositoryIntegrity");
	case SOAP_TYPE_mtrep6__RepositoryStatus:
		return soap_out_mtrep6__RepositoryStatus(soap, tag, id, (const enum mtrep6__RepositoryStatus *)ptr, "mtrep6:RepositoryStatus");
	case SOAP_TYPE_mtrep6__PackageLevel:
		return soap_out_mtrep6__PackageLevel(soap, tag, id, (const enum mtrep6__PackageLevel *)ptr, "mtrep6:PackageLevel");
	case SOAP_TYPE_mtrep6__RepositoryIntegrity:
		return soap_out_mtrep6__RepositoryIntegrity(soap, tag, id, (const enum mtrep6__RepositoryIntegrity *)ptr, "mtrep6:RepositoryIntegrity");
	case SOAP_TYPE_mtrep6__RepositoryReleaseState:
		return soap_out_mtrep6__RepositoryReleaseState(soap, tag, id, (const enum mtrep6__RepositoryReleaseState *)ptr, "mtrep6:RepositoryReleaseState");
	case SOAP_TYPE_mtrep5__RepositoryStatus:
		return soap_out_mtrep5__RepositoryStatus(soap, tag, id, (const enum mtrep5__RepositoryStatus *)ptr, "mtrep5:RepositoryStatus");
	case SOAP_TYPE_mtrep5__PackageLevel:
		return soap_out_mtrep5__PackageLevel(soap, tag, id, (const enum mtrep5__PackageLevel *)ptr, "mtrep5:PackageLevel");
	case SOAP_TYPE_mtrep5__RepositoryIntegrity:
		return soap_out_mtrep5__RepositoryIntegrity(soap, tag, id, (const enum mtrep5__RepositoryIntegrity *)ptr, "mtrep5:RepositoryIntegrity");
	case SOAP_TYPE_mtrep4__RepositoryStatus:
		return soap_out_mtrep4__RepositoryStatus(soap, tag, id, (const enum mtrep4__RepositoryStatus *)ptr, "mtrep4:RepositoryStatus");
	case SOAP_TYPE_mtrep4__PackageLevel:
		return soap_out_mtrep4__PackageLevel(soap, tag, id, (const enum mtrep4__PackageLevel *)ptr, "mtrep4:PackageLevel");
	case SOAP_TYPE_mtrep4__RepositoryIntegrity:
		return soap_out_mtrep4__RepositoryIntegrity(soap, tag, id, (const enum mtrep4__RepositoryIntegrity *)ptr, "mtrep4:RepositoryIntegrity");
	case SOAP_TYPE_mtrep3__RepositoryStatus:
		return soap_out_mtrep3__RepositoryStatus(soap, tag, id, (const enum mtrep3__RepositoryStatus *)ptr, "mtrep3:RepositoryStatus");
	case SOAP_TYPE_mtrep3__PackageLevel:
		return soap_out_mtrep3__PackageLevel(soap, tag, id, (const enum mtrep3__PackageLevel *)ptr, "mtrep3:PackageLevel");
	case SOAP_TYPE_mtrep3__RepositoryIntegrity:
		return soap_out_mtrep3__RepositoryIntegrity(soap, tag, id, (const enum mtrep3__RepositoryIntegrity *)ptr, "mtrep3:RepositoryIntegrity");
	case SOAP_TYPE_mtrep__RepositoryStatus:
		return soap_out_mtrep__RepositoryStatus(soap, tag, id, (const enum mtrep__RepositoryStatus *)ptr, "mtrep:RepositoryStatus");
	case SOAP_TYPE_mtrep__PackageLevel:
		return soap_out_mtrep__PackageLevel(soap, tag, id, (const enum mtrep__PackageLevel *)ptr, "mtrep:PackageLevel");
	case SOAP_TYPE_mtrep__RepositoryIntegrity:
		return soap_out_mtrep__RepositoryIntegrity(soap, tag, id, (const enum mtrep__RepositoryIntegrity *)ptr, "mtrep:RepositoryIntegrity");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response:
		return ((_mtrep7__TryGetRepositoryInfo3Response *)ptr)->soap_out(soap, "mtrep7:TryGetRepositoryInfo3Response", id, NULL);
	case SOAP_TYPE__mtrep7__TryGetRepositoryInfo3:
		return ((_mtrep7__TryGetRepositoryInfo3 *)ptr)->soap_out(soap, "mtrep7:TryGetRepositoryInfo3", id, NULL);
	case SOAP_TYPE__mtrep7__VerifyRepository2Response:
		return ((_mtrep7__VerifyRepository2Response *)ptr)->soap_out(soap, "mtrep7:VerifyRepository2Response", id, NULL);
	case SOAP_TYPE__mtrep7__VerifyRepository2:
		return ((_mtrep7__VerifyRepository2 *)ptr)->soap_out(soap, "mtrep7:VerifyRepository2", id, NULL);
	case SOAP_TYPE_mtrep7__RepositoryInfo:
		return ((mtrep7__RepositoryInfo *)ptr)->soap_out(soap, tag, id, "mtrep7:RepositoryInfo");
	case SOAP_TYPE_mtrep7__RepositoryInfo2:
		return ((mtrep7__RepositoryInfo2 *)ptr)->soap_out(soap, tag, id, "mtrep7:RepositoryInfo2");
	case SOAP_TYPE_mtrep7__RepositoryInfo3:
		return ((mtrep7__RepositoryInfo3 *)ptr)->soap_out(soap, tag, id, "mtrep7:RepositoryInfo3");
	case SOAP_TYPE_mtrep7__ClientInfo:
		return ((mtrep7__ClientInfo *)ptr)->soap_out(soap, tag, id, "mtrep7:ClientInfo");
	case SOAP_TYPE__mtrep6__PickRepository4Response:
		return ((_mtrep6__PickRepository4Response *)ptr)->soap_out(soap, "mtrep6:PickRepository4Response", id, NULL);
	case SOAP_TYPE__mtrep6__PickRepository4:
		return ((_mtrep6__PickRepository4 *)ptr)->soap_out(soap, "mtrep6:PickRepository4", id, NULL);
	case SOAP_TYPE__mtrep6__GetRepositories4Response:
		return ((_mtrep6__GetRepositories4Response *)ptr)->soap_out(soap, "mtrep6:GetRepositories4Response", id, NULL);
	case SOAP_TYPE__mtrep6__GetRepositories4:
		return ((_mtrep6__GetRepositories4 *)ptr)->soap_out(soap, "mtrep6:GetRepositories4", id, NULL);
	case SOAP_TYPE_mtrep6__RepositoryInfo:
		return ((mtrep6__RepositoryInfo *)ptr)->soap_out(soap, tag, id, "mtrep6:RepositoryInfo");
	case SOAP_TYPE_mtrep6__RepositoryInfo2:
		return ((mtrep6__RepositoryInfo2 *)ptr)->soap_out(soap, tag, id, "mtrep6:RepositoryInfo2");
	case SOAP_TYPE_mtrep6__RepositoryInfo3:
		return ((mtrep6__RepositoryInfo3 *)ptr)->soap_out(soap, tag, id, "mtrep6:RepositoryInfo3");
	case SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3:
		return ((mtrep6__ArrayOfRepositoryInfo3 *)ptr)->soap_out(soap, tag, id, "mtrep6:ArrayOfRepositoryInfo3");
	case SOAP_TYPE_mtrep6__ClientInfo:
		return ((mtrep6__ClientInfo *)ptr)->soap_out(soap, tag, id, "mtrep6:ClientInfo");
	case SOAP_TYPE__mtrep5__PickRepository3Response:
		return ((_mtrep5__PickRepository3Response *)ptr)->soap_out(soap, "mtrep5:PickRepository3Response", id, NULL);
	case SOAP_TYPE__mtrep5__PickRepository3:
		return ((_mtrep5__PickRepository3 *)ptr)->soap_out(soap, "mtrep5:PickRepository3", id, NULL);
	case SOAP_TYPE__mtrep5__GetRepositories3Response:
		return ((_mtrep5__GetRepositories3Response *)ptr)->soap_out(soap, "mtrep5:GetRepositories3Response", id, NULL);
	case SOAP_TYPE__mtrep5__GetRepositories3:
		return ((_mtrep5__GetRepositories3 *)ptr)->soap_out(soap, "mtrep5:GetRepositories3", id, NULL);
	case SOAP_TYPE_mtrep5__RepositoryInfo:
		return ((mtrep5__RepositoryInfo *)ptr)->soap_out(soap, tag, id, "mtrep5:RepositoryInfo");
	case SOAP_TYPE_mtrep5__RepositoryInfo2:
		return ((mtrep5__RepositoryInfo2 *)ptr)->soap_out(soap, tag, id, "mtrep5:RepositoryInfo2");
	case SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2:
		return ((mtrep5__ArrayOfRepositoryInfo2 *)ptr)->soap_out(soap, tag, id, "mtrep5:ArrayOfRepositoryInfo2");
	case SOAP_TYPE_mtrep5__ClientInfo:
		return ((mtrep5__ClientInfo *)ptr)->soap_out(soap, tag, id, "mtrep5:ClientInfo");
	case SOAP_TYPE__mtrep4__VerifyRepositoryResponse:
		return ((_mtrep4__VerifyRepositoryResponse *)ptr)->soap_out(soap, "mtrep4:VerifyRepositoryResponse", id, NULL);
	case SOAP_TYPE__mtrep4__VerifyRepository:
		return ((_mtrep4__VerifyRepository *)ptr)->soap_out(soap, "mtrep4:VerifyRepository", id, NULL);
	case SOAP_TYPE_mtrep4__RepositoryInfo:
		return ((mtrep4__RepositoryInfo *)ptr)->soap_out(soap, tag, id, "mtrep4:RepositoryInfo");
	case SOAP_TYPE_mtrep4__ClientInfo:
		return ((mtrep4__ClientInfo *)ptr)->soap_out(soap, tag, id, "mtrep4:ClientInfo");
	case SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response:
		return ((_mtrep3__TryGetRepositoryInfo2Response *)ptr)->soap_out(soap, "mtrep3:TryGetRepositoryInfo2Response", id, NULL);
	case SOAP_TYPE__mtrep3__TryGetRepositoryInfo2:
		return ((_mtrep3__TryGetRepositoryInfo2 *)ptr)->soap_out(soap, "mtrep3:TryGetRepositoryInfo2", id, NULL);
	case SOAP_TYPE__mtrep3__PickRepository2Response:
		return ((_mtrep3__PickRepository2Response *)ptr)->soap_out(soap, "mtrep3:PickRepository2Response", id, NULL);
	case SOAP_TYPE__mtrep3__PickRepository2:
		return ((_mtrep3__PickRepository2 *)ptr)->soap_out(soap, "mtrep3:PickRepository2", id, NULL);
	case SOAP_TYPE__mtrep3__GetRepositories2Response:
		return ((_mtrep3__GetRepositories2Response *)ptr)->soap_out(soap, "mtrep3:GetRepositories2Response", id, NULL);
	case SOAP_TYPE__mtrep3__GetRepositories2:
		return ((_mtrep3__GetRepositories2 *)ptr)->soap_out(soap, "mtrep3:GetRepositories2", id, NULL);
	case SOAP_TYPE_mtrep3__RepositoryInfo:
		return ((mtrep3__RepositoryInfo *)ptr)->soap_out(soap, tag, id, "mtrep3:RepositoryInfo");
	case SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo:
		return ((mtrep3__ArrayOfRepositoryInfo *)ptr)->soap_out(soap, tag, id, "mtrep3:ArrayOfRepositoryInfo");
	case SOAP_TYPE_mtrep3__ClientInfo:
		return ((mtrep3__ClientInfo *)ptr)->soap_out(soap, tag, id, "mtrep3:ClientInfo");
	case SOAP_TYPE__mtrep2__GetListCreationTimeResponse:
		return ((_mtrep2__GetListCreationTimeResponse *)ptr)->soap_out(soap, "mtrep2:GetListCreationTimeResponse", id, NULL);
	case SOAP_TYPE__mtrep2__GetListCreationTime:
		return ((_mtrep2__GetListCreationTime *)ptr)->soap_out(soap, "mtrep2:GetListCreationTime", id, NULL);
	case SOAP_TYPE__mtrep__GetRepositoriesResponse:
		return ((_mtrep__GetRepositoriesResponse *)ptr)->soap_out(soap, "mtrep:GetRepositoriesResponse", id, NULL);
	case SOAP_TYPE__mtrep__GetRepositories:
		return ((_mtrep__GetRepositories *)ptr)->soap_out(soap, "mtrep:GetRepositories", id, NULL);
	case SOAP_TYPE__mtrep__GetAllRepositoriesResponse:
		return ((_mtrep__GetAllRepositoriesResponse *)ptr)->soap_out(soap, "mtrep:GetAllRepositoriesResponse", id, NULL);
	case SOAP_TYPE__mtrep__GetAllRepositories:
		return ((_mtrep__GetAllRepositories *)ptr)->soap_out(soap, "mtrep:GetAllRepositories", id, NULL);
	case SOAP_TYPE__mtrep__PickRepositoryResponse:
		return ((_mtrep__PickRepositoryResponse *)ptr)->soap_out(soap, "mtrep:PickRepositoryResponse", id, NULL);
	case SOAP_TYPE__mtrep__PickRepository:
		return ((_mtrep__PickRepository *)ptr)->soap_out(soap, "mtrep:PickRepository", id, NULL);
	case SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse:
		return ((_mtrep__TryGetRepositoryInfoResponse *)ptr)->soap_out(soap, "mtrep:TryGetRepositoryInfoResponse", id, NULL);
	case SOAP_TYPE__mtrep__TryGetRepositoryInfo:
		return ((_mtrep__TryGetRepositoryInfo *)ptr)->soap_out(soap, "mtrep:TryGetRepositoryInfo", id, NULL);
	case SOAP_TYPE_mtrep__ArrayOfRepositoryInfo:
		return ((mtrep__ArrayOfRepositoryInfo *)ptr)->soap_out(soap, tag, id, "mtrep:ArrayOfRepositoryInfo");
	case SOAP_TYPE_mtrep__RepositoryInfo:
		return ((mtrep__RepositoryInfo *)ptr)->soap_out(soap, tag, id, "mtrep:RepositoryInfo");
	case SOAP_TYPE_PointerTo_mtrep7__TryGetRepositoryInfo3:
		return soap_out_PointerTo_mtrep7__TryGetRepositoryInfo3(soap, tag, id, (_mtrep7__TryGetRepositoryInfo3 *const*)ptr, "mtrep7:TryGetRepositoryInfo3");
	case SOAP_TYPE_PointerTo_mtrep7__VerifyRepository2:
		return soap_out_PointerTo_mtrep7__VerifyRepository2(soap, tag, id, (_mtrep7__VerifyRepository2 *const*)ptr, "mtrep7:VerifyRepository2");
	case SOAP_TYPE_PointerTo_mtrep6__PickRepository4:
		return soap_out_PointerTo_mtrep6__PickRepository4(soap, tag, id, (_mtrep6__PickRepository4 *const*)ptr, "mtrep6:PickRepository4");
	case SOAP_TYPE_PointerTo_mtrep6__GetRepositories4:
		return soap_out_PointerTo_mtrep6__GetRepositories4(soap, tag, id, (_mtrep6__GetRepositories4 *const*)ptr, "mtrep6:GetRepositories4");
	case SOAP_TYPE_PointerTo_mtrep5__PickRepository3:
		return soap_out_PointerTo_mtrep5__PickRepository3(soap, tag, id, (_mtrep5__PickRepository3 *const*)ptr, "mtrep5:PickRepository3");
	case SOAP_TYPE_PointerTo_mtrep5__GetRepositories3:
		return soap_out_PointerTo_mtrep5__GetRepositories3(soap, tag, id, (_mtrep5__GetRepositories3 *const*)ptr, "mtrep5:GetRepositories3");
	case SOAP_TYPE_PointerTo_mtrep4__VerifyRepository:
		return soap_out_PointerTo_mtrep4__VerifyRepository(soap, tag, id, (_mtrep4__VerifyRepository *const*)ptr, "mtrep4:VerifyRepository");
	case SOAP_TYPE_PointerTo_mtrep3__TryGetRepositoryInfo2:
		return soap_out_PointerTo_mtrep3__TryGetRepositoryInfo2(soap, tag, id, (_mtrep3__TryGetRepositoryInfo2 *const*)ptr, "mtrep3:TryGetRepositoryInfo2");
	case SOAP_TYPE_PointerTo_mtrep3__PickRepository2:
		return soap_out_PointerTo_mtrep3__PickRepository2(soap, tag, id, (_mtrep3__PickRepository2 *const*)ptr, "mtrep3:PickRepository2");
	case SOAP_TYPE_PointerTo_mtrep3__GetRepositories2:
		return soap_out_PointerTo_mtrep3__GetRepositories2(soap, tag, id, (_mtrep3__GetRepositories2 *const*)ptr, "mtrep3:GetRepositories2");
	case SOAP_TYPE_PointerTo_mtrep2__GetListCreationTime:
		return soap_out_PointerTo_mtrep2__GetListCreationTime(soap, tag, id, (_mtrep2__GetListCreationTime *const*)ptr, "mtrep2:GetListCreationTime");
	case SOAP_TYPE_PointerTo_mtrep__GetRepositories:
		return soap_out_PointerTo_mtrep__GetRepositories(soap, tag, id, (_mtrep__GetRepositories *const*)ptr, "mtrep:GetRepositories");
	case SOAP_TYPE_PointerTo_mtrep__GetAllRepositories:
		return soap_out_PointerTo_mtrep__GetAllRepositories(soap, tag, id, (_mtrep__GetAllRepositories *const*)ptr, "mtrep:GetAllRepositories");
	case SOAP_TYPE_PointerTo_mtrep__PickRepository:
		return soap_out_PointerTo_mtrep__PickRepository(soap, tag, id, (_mtrep__PickRepository *const*)ptr, "mtrep:PickRepository");
	case SOAP_TYPE_PointerTo_mtrep__TryGetRepositoryInfo:
		return soap_out_PointerTo_mtrep__TryGetRepositoryInfo(soap, tag, id, (_mtrep__TryGetRepositoryInfo *const*)ptr, "mtrep:TryGetRepositoryInfo");
	case SOAP_TYPE_PointerTomtrep7__RepositoryInfo3:
		return soap_out_PointerTomtrep7__RepositoryInfo3(soap, tag, id, (mtrep7__RepositoryInfo3 *const*)ptr, "mtrep7:RepositoryInfo3");
	case SOAP_TYPE_PointerTomtrep7__ClientInfo:
		return soap_out_PointerTomtrep7__ClientInfo(soap, tag, id, (mtrep7__ClientInfo *const*)ptr, "mtrep7:ClientInfo");
	case SOAP_TYPE_PointerTomtrep6__ArrayOfRepositoryInfo3:
		return soap_out_PointerTomtrep6__ArrayOfRepositoryInfo3(soap, tag, id, (mtrep6__ArrayOfRepositoryInfo3 *const*)ptr, "mtrep6:ArrayOfRepositoryInfo3");
	case SOAP_TYPE_PointerTomtrep6__ClientInfo:
		return soap_out_PointerTomtrep6__ClientInfo(soap, tag, id, (mtrep6__ClientInfo *const*)ptr, "mtrep6:ClientInfo");
	case SOAP_TYPE_PointerTomtrep6__RepositoryInfo3:
		return soap_out_PointerTomtrep6__RepositoryInfo3(soap, tag, id, (mtrep6__RepositoryInfo3 *const*)ptr, "mtrep6:RepositoryInfo3");
	case SOAP_TYPE_PointerTomtrep5__ArrayOfRepositoryInfo2:
		return soap_out_PointerTomtrep5__ArrayOfRepositoryInfo2(soap, tag, id, (mtrep5__ArrayOfRepositoryInfo2 *const*)ptr, "mtrep5:ArrayOfRepositoryInfo2");
	case SOAP_TYPE_PointerTomtrep5__ClientInfo:
		return soap_out_PointerTomtrep5__ClientInfo(soap, tag, id, (mtrep5__ClientInfo *const*)ptr, "mtrep5:ClientInfo");
	case SOAP_TYPE_PointerTomtrep5__RepositoryInfo2:
		return soap_out_PointerTomtrep5__RepositoryInfo2(soap, tag, id, (mtrep5__RepositoryInfo2 *const*)ptr, "mtrep5:RepositoryInfo2");
	case SOAP_TYPE_PointerTomtrep4__RepositoryInfo:
		return soap_out_PointerTomtrep4__RepositoryInfo(soap, tag, id, (mtrep4__RepositoryInfo *const*)ptr, "mtrep4:RepositoryInfo");
	case SOAP_TYPE_PointerTomtrep4__ClientInfo:
		return soap_out_PointerTomtrep4__ClientInfo(soap, tag, id, (mtrep4__ClientInfo *const*)ptr, "mtrep4:ClientInfo");
	case SOAP_TYPE_PointerTomtrep3__ArrayOfRepositoryInfo:
		return soap_out_PointerTomtrep3__ArrayOfRepositoryInfo(soap, tag, id, (mtrep3__ArrayOfRepositoryInfo *const*)ptr, "mtrep3:ArrayOfRepositoryInfo");
	case SOAP_TYPE_PointerTomtrep3__ClientInfo:
		return soap_out_PointerTomtrep3__ClientInfo(soap, tag, id, (mtrep3__ClientInfo *const*)ptr, "mtrep3:ClientInfo");
	case SOAP_TYPE_PointerTomtrep3__RepositoryInfo:
		return soap_out_PointerTomtrep3__RepositoryInfo(soap, tag, id, (mtrep3__RepositoryInfo *const*)ptr, "mtrep3:RepositoryInfo");
	case SOAP_TYPE_PointerTomtrep__ArrayOfRepositoryInfo:
		return soap_out_PointerTomtrep__ArrayOfRepositoryInfo(soap, tag, id, (mtrep__ArrayOfRepositoryInfo *const*)ptr, "mtrep:ArrayOfRepositoryInfo");
	case SOAP_TYPE_PointerTomtrep__RepositoryInfo:
		return soap_out_PointerTomtrep__RepositoryInfo(soap, tag, id, (mtrep__RepositoryInfo *const*)ptr, "mtrep:RepositoryInfo");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response:
		((_mtrep7__TryGetRepositoryInfo3Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep7__TryGetRepositoryInfo3:
		((_mtrep7__TryGetRepositoryInfo3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep7__VerifyRepository2Response:
		((_mtrep7__VerifyRepository2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep7__VerifyRepository2:
		((_mtrep7__VerifyRepository2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep7__RepositoryInfo:
		((mtrep7__RepositoryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep7__RepositoryInfo2:
		((mtrep7__RepositoryInfo2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep7__RepositoryInfo3:
		((mtrep7__RepositoryInfo3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep7__ClientInfo:
		((mtrep7__ClientInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep6__PickRepository4Response:
		((_mtrep6__PickRepository4Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep6__PickRepository4:
		((_mtrep6__PickRepository4 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep6__GetRepositories4Response:
		((_mtrep6__GetRepositories4Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep6__GetRepositories4:
		((_mtrep6__GetRepositories4 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep6__RepositoryInfo:
		((mtrep6__RepositoryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep6__RepositoryInfo2:
		((mtrep6__RepositoryInfo2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep6__RepositoryInfo3:
		((mtrep6__RepositoryInfo3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3:
		((mtrep6__ArrayOfRepositoryInfo3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep6__ClientInfo:
		((mtrep6__ClientInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep5__PickRepository3Response:
		((_mtrep5__PickRepository3Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep5__PickRepository3:
		((_mtrep5__PickRepository3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep5__GetRepositories3Response:
		((_mtrep5__GetRepositories3Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep5__GetRepositories3:
		((_mtrep5__GetRepositories3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep5__RepositoryInfo:
		((mtrep5__RepositoryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep5__RepositoryInfo2:
		((mtrep5__RepositoryInfo2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2:
		((mtrep5__ArrayOfRepositoryInfo2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep5__ClientInfo:
		((mtrep5__ClientInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep4__VerifyRepositoryResponse:
		((_mtrep4__VerifyRepositoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep4__VerifyRepository:
		((_mtrep4__VerifyRepository *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep4__RepositoryInfo:
		((mtrep4__RepositoryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep4__ClientInfo:
		((mtrep4__ClientInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response:
		((_mtrep3__TryGetRepositoryInfo2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep3__TryGetRepositoryInfo2:
		((_mtrep3__TryGetRepositoryInfo2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep3__PickRepository2Response:
		((_mtrep3__PickRepository2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep3__PickRepository2:
		((_mtrep3__PickRepository2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep3__GetRepositories2Response:
		((_mtrep3__GetRepositories2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep3__GetRepositories2:
		((_mtrep3__GetRepositories2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep3__RepositoryInfo:
		((mtrep3__RepositoryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo:
		((mtrep3__ArrayOfRepositoryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep3__ClientInfo:
		((mtrep3__ClientInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep2__GetListCreationTimeResponse:
		((_mtrep2__GetListCreationTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep2__GetListCreationTime:
		((_mtrep2__GetListCreationTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep__GetRepositoriesResponse:
		((_mtrep__GetRepositoriesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep__GetRepositories:
		((_mtrep__GetRepositories *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep__GetAllRepositoriesResponse:
		((_mtrep__GetAllRepositoriesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep__GetAllRepositories:
		((_mtrep__GetAllRepositories *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep__PickRepositoryResponse:
		((_mtrep__PickRepositoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep__PickRepository:
		((_mtrep__PickRepository *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse:
		((_mtrep__TryGetRepositoryInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__mtrep__TryGetRepositoryInfo:
		((_mtrep__TryGetRepositoryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep__ArrayOfRepositoryInfo:
		((mtrep__ArrayOfRepositoryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mtrep__RepositoryInfo:
		((mtrep__RepositoryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo3_:
		soap_serialize___mtrep7__TryGetRepositoryInfo3_(soap, (const struct __mtrep7__TryGetRepositoryInfo3_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__VerifyRepository2_:
		soap_serialize___mtrep7__VerifyRepository2_(soap, (const struct __mtrep7__VerifyRepository2_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__PickRepository4_:
		soap_serialize___mtrep7__PickRepository4_(soap, (const struct __mtrep7__PickRepository4_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__GetRepositories4_:
		soap_serialize___mtrep7__GetRepositories4_(soap, (const struct __mtrep7__GetRepositories4_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__PickRepository3_:
		soap_serialize___mtrep7__PickRepository3_(soap, (const struct __mtrep7__PickRepository3_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__GetRepositories3_:
		soap_serialize___mtrep7__GetRepositories3_(soap, (const struct __mtrep7__GetRepositories3_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__VerifyRepository_:
		soap_serialize___mtrep7__VerifyRepository_(soap, (const struct __mtrep7__VerifyRepository_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo2_:
		soap_serialize___mtrep7__TryGetRepositoryInfo2_(soap, (const struct __mtrep7__TryGetRepositoryInfo2_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__PickRepository2_:
		soap_serialize___mtrep7__PickRepository2_(soap, (const struct __mtrep7__PickRepository2_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__GetRepositories2_:
		soap_serialize___mtrep7__GetRepositories2_(soap, (const struct __mtrep7__GetRepositories2_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__GetListCreationTime_:
		soap_serialize___mtrep7__GetListCreationTime_(soap, (const struct __mtrep7__GetListCreationTime_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__GetRepositories_:
		soap_serialize___mtrep7__GetRepositories_(soap, (const struct __mtrep7__GetRepositories_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__GetAllRepositories_:
		soap_serialize___mtrep7__GetAllRepositories_(soap, (const struct __mtrep7__GetAllRepositories_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__PickRepository_:
		soap_serialize___mtrep7__PickRepository_(soap, (const struct __mtrep7__PickRepository_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo_:
		soap_serialize___mtrep7__TryGetRepositoryInfo_(soap, (const struct __mtrep7__TryGetRepositoryInfo_ *)ptr);
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo3:
		soap_serialize___mtrep7__TryGetRepositoryInfo3(soap, (const struct __mtrep7__TryGetRepositoryInfo3 *)ptr);
		break;
	case SOAP_TYPE___mtrep7__VerifyRepository2:
		soap_serialize___mtrep7__VerifyRepository2(soap, (const struct __mtrep7__VerifyRepository2 *)ptr);
		break;
	case SOAP_TYPE___mtrep7__PickRepository4:
		soap_serialize___mtrep7__PickRepository4(soap, (const struct __mtrep7__PickRepository4 *)ptr);
		break;
	case SOAP_TYPE___mtrep7__GetRepositories4:
		soap_serialize___mtrep7__GetRepositories4(soap, (const struct __mtrep7__GetRepositories4 *)ptr);
		break;
	case SOAP_TYPE___mtrep7__PickRepository3:
		soap_serialize___mtrep7__PickRepository3(soap, (const struct __mtrep7__PickRepository3 *)ptr);
		break;
	case SOAP_TYPE___mtrep7__GetRepositories3:
		soap_serialize___mtrep7__GetRepositories3(soap, (const struct __mtrep7__GetRepositories3 *)ptr);
		break;
	case SOAP_TYPE___mtrep7__VerifyRepository:
		soap_serialize___mtrep7__VerifyRepository(soap, (const struct __mtrep7__VerifyRepository *)ptr);
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo2:
		soap_serialize___mtrep7__TryGetRepositoryInfo2(soap, (const struct __mtrep7__TryGetRepositoryInfo2 *)ptr);
		break;
	case SOAP_TYPE___mtrep7__PickRepository2:
		soap_serialize___mtrep7__PickRepository2(soap, (const struct __mtrep7__PickRepository2 *)ptr);
		break;
	case SOAP_TYPE___mtrep7__GetRepositories2:
		soap_serialize___mtrep7__GetRepositories2(soap, (const struct __mtrep7__GetRepositories2 *)ptr);
		break;
	case SOAP_TYPE___mtrep7__GetListCreationTime:
		soap_serialize___mtrep7__GetListCreationTime(soap, (const struct __mtrep7__GetListCreationTime *)ptr);
		break;
	case SOAP_TYPE___mtrep7__GetRepositories:
		soap_serialize___mtrep7__GetRepositories(soap, (const struct __mtrep7__GetRepositories *)ptr);
		break;
	case SOAP_TYPE___mtrep7__GetAllRepositories:
		soap_serialize___mtrep7__GetAllRepositories(soap, (const struct __mtrep7__GetAllRepositories *)ptr);
		break;
	case SOAP_TYPE___mtrep7__PickRepository:
		soap_serialize___mtrep7__PickRepository(soap, (const struct __mtrep7__PickRepository *)ptr);
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo:
		soap_serialize___mtrep7__TryGetRepositoryInfo(soap, (const struct __mtrep7__TryGetRepositoryInfo *)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep7__TryGetRepositoryInfo3:
		soap_serialize_PointerTo_mtrep7__TryGetRepositoryInfo3(soap, (_mtrep7__TryGetRepositoryInfo3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep7__VerifyRepository2:
		soap_serialize_PointerTo_mtrep7__VerifyRepository2(soap, (_mtrep7__VerifyRepository2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep6__PickRepository4:
		soap_serialize_PointerTo_mtrep6__PickRepository4(soap, (_mtrep6__PickRepository4 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep6__GetRepositories4:
		soap_serialize_PointerTo_mtrep6__GetRepositories4(soap, (_mtrep6__GetRepositories4 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep5__PickRepository3:
		soap_serialize_PointerTo_mtrep5__PickRepository3(soap, (_mtrep5__PickRepository3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep5__GetRepositories3:
		soap_serialize_PointerTo_mtrep5__GetRepositories3(soap, (_mtrep5__GetRepositories3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep4__VerifyRepository:
		soap_serialize_PointerTo_mtrep4__VerifyRepository(soap, (_mtrep4__VerifyRepository *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep3__TryGetRepositoryInfo2:
		soap_serialize_PointerTo_mtrep3__TryGetRepositoryInfo2(soap, (_mtrep3__TryGetRepositoryInfo2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep3__PickRepository2:
		soap_serialize_PointerTo_mtrep3__PickRepository2(soap, (_mtrep3__PickRepository2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep3__GetRepositories2:
		soap_serialize_PointerTo_mtrep3__GetRepositories2(soap, (_mtrep3__GetRepositories2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep2__GetListCreationTime:
		soap_serialize_PointerTo_mtrep2__GetListCreationTime(soap, (_mtrep2__GetListCreationTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep__GetRepositories:
		soap_serialize_PointerTo_mtrep__GetRepositories(soap, (_mtrep__GetRepositories *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep__GetAllRepositories:
		soap_serialize_PointerTo_mtrep__GetAllRepositories(soap, (_mtrep__GetAllRepositories *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep__PickRepository:
		soap_serialize_PointerTo_mtrep__PickRepository(soap, (_mtrep__PickRepository *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_mtrep__TryGetRepositoryInfo:
		soap_serialize_PointerTo_mtrep__TryGetRepositoryInfo(soap, (_mtrep__TryGetRepositoryInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep7__RepositoryInfo3:
		soap_serialize_PointerTomtrep7__RepositoryInfo3(soap, (mtrep7__RepositoryInfo3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep7__ClientInfo:
		soap_serialize_PointerTomtrep7__ClientInfo(soap, (mtrep7__ClientInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep6__ArrayOfRepositoryInfo3:
		soap_serialize_PointerTomtrep6__ArrayOfRepositoryInfo3(soap, (mtrep6__ArrayOfRepositoryInfo3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep6__ClientInfo:
		soap_serialize_PointerTomtrep6__ClientInfo(soap, (mtrep6__ClientInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep6__RepositoryInfo3:
		soap_serialize_PointerTomtrep6__RepositoryInfo3(soap, (mtrep6__RepositoryInfo3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep5__ArrayOfRepositoryInfo2:
		soap_serialize_PointerTomtrep5__ArrayOfRepositoryInfo2(soap, (mtrep5__ArrayOfRepositoryInfo2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep5__ClientInfo:
		soap_serialize_PointerTomtrep5__ClientInfo(soap, (mtrep5__ClientInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep5__RepositoryInfo2:
		soap_serialize_PointerTomtrep5__RepositoryInfo2(soap, (mtrep5__RepositoryInfo2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep4__RepositoryInfo:
		soap_serialize_PointerTomtrep4__RepositoryInfo(soap, (mtrep4__RepositoryInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep4__ClientInfo:
		soap_serialize_PointerTomtrep4__ClientInfo(soap, (mtrep4__ClientInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep3__ArrayOfRepositoryInfo:
		soap_serialize_PointerTomtrep3__ArrayOfRepositoryInfo(soap, (mtrep3__ArrayOfRepositoryInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep3__ClientInfo:
		soap_serialize_PointerTomtrep3__ClientInfo(soap, (mtrep3__ClientInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep3__RepositoryInfo:
		soap_serialize_PointerTomtrep3__RepositoryInfo(soap, (mtrep3__RepositoryInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep__ArrayOfRepositoryInfo:
		soap_serialize_PointerTomtrep__ArrayOfRepositoryInfo(soap, (mtrep__ArrayOfRepositoryInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomtrep__RepositoryInfo:
		soap_serialize_PointerTomtrep__RepositoryInfo(soap, (mtrep__RepositoryInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 repository_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)repository_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep__RepositoryInfo:
		return (void*)repository_instantiate_mtrep__RepositoryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep__ArrayOfRepositoryInfo:
		return (void*)repository_instantiate_mtrep__ArrayOfRepositoryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep__TryGetRepositoryInfo:
		return (void*)repository_instantiate__mtrep__TryGetRepositoryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse:
		return (void*)repository_instantiate__mtrep__TryGetRepositoryInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep__PickRepository:
		return (void*)repository_instantiate__mtrep__PickRepository(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep__PickRepositoryResponse:
		return (void*)repository_instantiate__mtrep__PickRepositoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep__GetAllRepositories:
		return (void*)repository_instantiate__mtrep__GetAllRepositories(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep__GetAllRepositoriesResponse:
		return (void*)repository_instantiate__mtrep__GetAllRepositoriesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep__GetRepositories:
		return (void*)repository_instantiate__mtrep__GetRepositories(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep__GetRepositoriesResponse:
		return (void*)repository_instantiate__mtrep__GetRepositoriesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep2__GetListCreationTime:
		return (void*)repository_instantiate__mtrep2__GetListCreationTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep2__GetListCreationTimeResponse:
		return (void*)repository_instantiate__mtrep2__GetListCreationTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep3__ClientInfo:
		return (void*)repository_instantiate_mtrep3__ClientInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo:
		return (void*)repository_instantiate_mtrep3__ArrayOfRepositoryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep3__RepositoryInfo:
		return (void*)repository_instantiate_mtrep3__RepositoryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep3__GetRepositories2:
		return (void*)repository_instantiate__mtrep3__GetRepositories2(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep3__GetRepositories2Response:
		return (void*)repository_instantiate__mtrep3__GetRepositories2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep3__PickRepository2:
		return (void*)repository_instantiate__mtrep3__PickRepository2(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep3__PickRepository2Response:
		return (void*)repository_instantiate__mtrep3__PickRepository2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep3__TryGetRepositoryInfo2:
		return (void*)repository_instantiate__mtrep3__TryGetRepositoryInfo2(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response:
		return (void*)repository_instantiate__mtrep3__TryGetRepositoryInfo2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep4__ClientInfo:
		return (void*)repository_instantiate_mtrep4__ClientInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep4__RepositoryInfo:
		return (void*)repository_instantiate_mtrep4__RepositoryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep4__VerifyRepository:
		return (void*)repository_instantiate__mtrep4__VerifyRepository(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep4__VerifyRepositoryResponse:
		return (void*)repository_instantiate__mtrep4__VerifyRepositoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep5__ClientInfo:
		return (void*)repository_instantiate_mtrep5__ClientInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2:
		return (void*)repository_instantiate_mtrep5__ArrayOfRepositoryInfo2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep5__RepositoryInfo:
		return (void*)repository_instantiate_mtrep5__RepositoryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep5__GetRepositories3:
		return (void*)repository_instantiate__mtrep5__GetRepositories3(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep5__GetRepositories3Response:
		return (void*)repository_instantiate__mtrep5__GetRepositories3Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep5__PickRepository3:
		return (void*)repository_instantiate__mtrep5__PickRepository3(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep5__PickRepository3Response:
		return (void*)repository_instantiate__mtrep5__PickRepository3Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep6__ClientInfo:
		return (void*)repository_instantiate_mtrep6__ClientInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3:
		return (void*)repository_instantiate_mtrep6__ArrayOfRepositoryInfo3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep6__RepositoryInfo:
		return (void*)repository_instantiate_mtrep6__RepositoryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep6__GetRepositories4:
		return (void*)repository_instantiate__mtrep6__GetRepositories4(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep6__GetRepositories4Response:
		return (void*)repository_instantiate__mtrep6__GetRepositories4Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep6__PickRepository4:
		return (void*)repository_instantiate__mtrep6__PickRepository4(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep6__PickRepository4Response:
		return (void*)repository_instantiate__mtrep6__PickRepository4Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep7__ClientInfo:
		return (void*)repository_instantiate_mtrep7__ClientInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep7__RepositoryInfo:
		return (void*)repository_instantiate_mtrep7__RepositoryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep7__VerifyRepository2:
		return (void*)repository_instantiate__mtrep7__VerifyRepository2(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep7__VerifyRepository2Response:
		return (void*)repository_instantiate__mtrep7__VerifyRepository2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep7__TryGetRepositoryInfo3:
		return (void*)repository_instantiate__mtrep7__TryGetRepositoryInfo3(soap, -1, type, arrayType, n);
	case SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response:
		return (void*)repository_instantiate__mtrep7__TryGetRepositoryInfo3Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep5__RepositoryInfo2:
		return (void*)repository_instantiate_mtrep5__RepositoryInfo2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep6__RepositoryInfo2:
		return (void*)repository_instantiate_mtrep6__RepositoryInfo2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep7__RepositoryInfo2:
		return (void*)repository_instantiate_mtrep7__RepositoryInfo2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep6__RepositoryInfo3:
		return (void*)repository_instantiate_mtrep6__RepositoryInfo3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mtrep7__RepositoryInfo3:
		return (void*)repository_instantiate_mtrep7__RepositoryInfo3(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo:
		return (void*)repository_instantiate___mtrep7__TryGetRepositoryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__PickRepository:
		return (void*)repository_instantiate___mtrep7__PickRepository(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__GetAllRepositories:
		return (void*)repository_instantiate___mtrep7__GetAllRepositories(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__GetRepositories:
		return (void*)repository_instantiate___mtrep7__GetRepositories(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__GetListCreationTime:
		return (void*)repository_instantiate___mtrep7__GetListCreationTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__GetRepositories2:
		return (void*)repository_instantiate___mtrep7__GetRepositories2(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__PickRepository2:
		return (void*)repository_instantiate___mtrep7__PickRepository2(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo2:
		return (void*)repository_instantiate___mtrep7__TryGetRepositoryInfo2(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__VerifyRepository:
		return (void*)repository_instantiate___mtrep7__VerifyRepository(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__GetRepositories3:
		return (void*)repository_instantiate___mtrep7__GetRepositories3(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__PickRepository3:
		return (void*)repository_instantiate___mtrep7__PickRepository3(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__GetRepositories4:
		return (void*)repository_instantiate___mtrep7__GetRepositories4(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__PickRepository4:
		return (void*)repository_instantiate___mtrep7__PickRepository4(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__VerifyRepository2:
		return (void*)repository_instantiate___mtrep7__VerifyRepository2(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo3:
		return (void*)repository_instantiate___mtrep7__TryGetRepositoryInfo3(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo_:
		return (void*)repository_instantiate___mtrep7__TryGetRepositoryInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__PickRepository_:
		return (void*)repository_instantiate___mtrep7__PickRepository_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__GetAllRepositories_:
		return (void*)repository_instantiate___mtrep7__GetAllRepositories_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__GetRepositories_:
		return (void*)repository_instantiate___mtrep7__GetRepositories_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__GetListCreationTime_:
		return (void*)repository_instantiate___mtrep7__GetListCreationTime_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__GetRepositories2_:
		return (void*)repository_instantiate___mtrep7__GetRepositories2_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__PickRepository2_:
		return (void*)repository_instantiate___mtrep7__PickRepository2_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo2_:
		return (void*)repository_instantiate___mtrep7__TryGetRepositoryInfo2_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__VerifyRepository_:
		return (void*)repository_instantiate___mtrep7__VerifyRepository_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__GetRepositories3_:
		return (void*)repository_instantiate___mtrep7__GetRepositories3_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__PickRepository3_:
		return (void*)repository_instantiate___mtrep7__PickRepository3_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__GetRepositories4_:
		return (void*)repository_instantiate___mtrep7__GetRepositories4_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__PickRepository4_:
		return (void*)repository_instantiate___mtrep7__PickRepository4_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__VerifyRepository2_:
		return (void*)repository_instantiate___mtrep7__VerifyRepository2_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo3_:
		return (void*)repository_instantiate___mtrep7__TryGetRepositoryInfo3_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)repository_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)repository_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)repository_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)repository_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)repository_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3:
		return (void*)repository_instantiate_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2:
		return (void*)repository_instantiate_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo:
		return (void*)repository_instantiate_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTomtrep__RepositoryInfo:
		return (void*)repository_instantiate_std__vectorTemplateOfPointerTomtrep__RepositoryInfo(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 repository_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep__RepositoryInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep__RepositoryInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep__RepositoryInfo*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep__ArrayOfRepositoryInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep__ArrayOfRepositoryInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep__ArrayOfRepositoryInfo*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep__TryGetRepositoryInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep__TryGetRepositoryInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep__TryGetRepositoryInfo*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep__TryGetRepositoryInfoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep__TryGetRepositoryInfoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep__PickRepository:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep__PickRepository*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep__PickRepository*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep__PickRepositoryResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep__PickRepositoryResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep__PickRepositoryResponse*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep__GetAllRepositories:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep__GetAllRepositories*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep__GetAllRepositories*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep__GetAllRepositoriesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep__GetAllRepositoriesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep__GetAllRepositoriesResponse*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep__GetRepositories:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep__GetRepositories*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep__GetRepositories*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep__GetRepositoriesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep__GetRepositoriesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep__GetRepositoriesResponse*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep2__GetListCreationTime:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep2__GetListCreationTime*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep2__GetListCreationTime*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep2__GetListCreationTimeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep2__GetListCreationTimeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep2__GetListCreationTimeResponse*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep3__ClientInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep3__ClientInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep3__ClientInfo*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep3__ArrayOfRepositoryInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep3__ArrayOfRepositoryInfo*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep3__RepositoryInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep3__RepositoryInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep3__RepositoryInfo*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep3__GetRepositories2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep3__GetRepositories2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep3__GetRepositories2*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep3__GetRepositories2Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep3__GetRepositories2Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep3__GetRepositories2Response*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep3__PickRepository2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep3__PickRepository2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep3__PickRepository2*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep3__PickRepository2Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep3__PickRepository2Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep3__PickRepository2Response*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep3__TryGetRepositoryInfo2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep3__TryGetRepositoryInfo2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep3__TryGetRepositoryInfo2*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep3__TryGetRepositoryInfo2Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep3__TryGetRepositoryInfo2Response*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep4__ClientInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep4__ClientInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep4__ClientInfo*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep4__RepositoryInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep4__RepositoryInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep4__RepositoryInfo*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep4__VerifyRepository:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep4__VerifyRepository*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep4__VerifyRepository*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep4__VerifyRepositoryResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep4__VerifyRepositoryResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep4__VerifyRepositoryResponse*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep5__ClientInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep5__ClientInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep5__ClientInfo*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep5__ArrayOfRepositoryInfo2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep5__ArrayOfRepositoryInfo2*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep5__RepositoryInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep5__RepositoryInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep5__RepositoryInfo*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep5__GetRepositories3:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep5__GetRepositories3*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep5__GetRepositories3*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep5__GetRepositories3Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep5__GetRepositories3Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep5__GetRepositories3Response*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep5__PickRepository3:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep5__PickRepository3*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep5__PickRepository3*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep5__PickRepository3Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep5__PickRepository3Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep5__PickRepository3Response*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep6__ClientInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep6__ClientInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep6__ClientInfo*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep6__ArrayOfRepositoryInfo3*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep6__ArrayOfRepositoryInfo3*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep6__RepositoryInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep6__RepositoryInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep6__RepositoryInfo*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep6__GetRepositories4:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep6__GetRepositories4*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep6__GetRepositories4*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep6__GetRepositories4Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep6__GetRepositories4Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep6__GetRepositories4Response*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep6__PickRepository4:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep6__PickRepository4*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep6__PickRepository4*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep6__PickRepository4Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep6__PickRepository4Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep6__PickRepository4Response*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep7__ClientInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep7__ClientInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep7__ClientInfo*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep7__RepositoryInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep7__RepositoryInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep7__RepositoryInfo*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep7__VerifyRepository2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep7__VerifyRepository2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep7__VerifyRepository2*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep7__VerifyRepository2Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep7__VerifyRepository2Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep7__VerifyRepository2Response*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep7__TryGetRepositoryInfo3:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep7__TryGetRepositoryInfo3*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep7__TryGetRepositoryInfo3*>(p->ptr));
		break;
	case SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_mtrep7__TryGetRepositoryInfo3Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_mtrep7__TryGetRepositoryInfo3Response*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep5__RepositoryInfo2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep5__RepositoryInfo2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep5__RepositoryInfo2*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep6__RepositoryInfo2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep6__RepositoryInfo2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep6__RepositoryInfo2*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep7__RepositoryInfo2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep7__RepositoryInfo2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep7__RepositoryInfo2*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep6__RepositoryInfo3:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep6__RepositoryInfo3*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep6__RepositoryInfo3*>(p->ptr));
		break;
	case SOAP_TYPE_mtrep7__RepositoryInfo3:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mtrep7__RepositoryInfo3*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mtrep7__RepositoryInfo3*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__TryGetRepositoryInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__TryGetRepositoryInfo*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__PickRepository:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__PickRepository*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__PickRepository*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__GetAllRepositories:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__GetAllRepositories*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__GetAllRepositories*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__GetRepositories:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__GetRepositories*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__GetRepositories*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__GetListCreationTime:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__GetListCreationTime*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__GetListCreationTime*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__GetRepositories2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__GetRepositories2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__GetRepositories2*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__PickRepository2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__PickRepository2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__PickRepository2*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__TryGetRepositoryInfo2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__TryGetRepositoryInfo2*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__VerifyRepository:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__VerifyRepository*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__VerifyRepository*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__GetRepositories3:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__GetRepositories3*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__GetRepositories3*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__PickRepository3:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__PickRepository3*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__PickRepository3*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__GetRepositories4:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__GetRepositories4*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__GetRepositories4*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__PickRepository4:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__PickRepository4*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__PickRepository4*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__VerifyRepository2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__VerifyRepository2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__VerifyRepository2*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo3:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__TryGetRepositoryInfo3*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__TryGetRepositoryInfo3*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__TryGetRepositoryInfo_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__TryGetRepositoryInfo_*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__PickRepository_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__PickRepository_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__PickRepository_*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__GetAllRepositories_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__GetAllRepositories_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__GetAllRepositories_*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__GetRepositories_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__GetRepositories_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__GetRepositories_*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__GetListCreationTime_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__GetListCreationTime_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__GetListCreationTime_*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__GetRepositories2_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__GetRepositories2_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__GetRepositories2_*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__PickRepository2_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__PickRepository2_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__PickRepository2_*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo2_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__TryGetRepositoryInfo2_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__TryGetRepositoryInfo2_*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__VerifyRepository_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__VerifyRepository_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__VerifyRepository_*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__GetRepositories3_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__GetRepositories3_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__GetRepositories3_*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__PickRepository3_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__PickRepository3_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__PickRepository3_*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__GetRepositories4_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__GetRepositories4_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__GetRepositories4_*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__PickRepository4_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__PickRepository4_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__PickRepository4_*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__VerifyRepository2_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__VerifyRepository2_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__VerifyRepository2_*>(p->ptr));
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo3_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __mtrep7__TryGetRepositoryInfo3_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __mtrep7__TryGetRepositoryInfo3_*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<mtrep6__RepositoryInfo3 *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<mtrep6__RepositoryInfo3 *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<mtrep5__RepositoryInfo2 *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<mtrep5__RepositoryInfo2 *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<mtrep3__RepositoryInfo *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<mtrep3__RepositoryInfo *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTomtrep__RepositoryInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<mtrep__RepositoryInfo *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<mtrep__RepositoryInfo *> *>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 repository_fbase(int t, int b)
{
	do
	{	switch (t)
		{
		case SOAP_TYPE_mtrep5__RepositoryInfo2: t = SOAP_TYPE_mtrep5__RepositoryInfo; break;
		case SOAP_TYPE_mtrep6__RepositoryInfo2: t = SOAP_TYPE_mtrep6__RepositoryInfo; break;
		case SOAP_TYPE_mtrep7__RepositoryInfo2: t = SOAP_TYPE_mtrep7__RepositoryInfo; break;
		case SOAP_TYPE_mtrep6__RepositoryInfo3: t = SOAP_TYPE_mtrep6__RepositoryInfo2; break;
		case SOAP_TYPE_mtrep7__RepositoryInfo3: t = SOAP_TYPE_mtrep7__RepositoryInfo2; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 repository_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3:
		if (t == SOAP_TYPE_mtrep6__RepositoryInfo3)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<mtrep6__RepositoryInfo3 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<mtrep6__RepositoryInfo3 *> *)p)[index] = *(mtrep6__RepositoryInfo3 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2:
		if (t == SOAP_TYPE_mtrep5__RepositoryInfo2)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<mtrep5__RepositoryInfo2 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<mtrep5__RepositoryInfo2 *> *)p)[index] = *(mtrep5__RepositoryInfo2 **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo:
		if (t == SOAP_TYPE_mtrep3__RepositoryInfo)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<mtrep3__RepositoryInfo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<mtrep3__RepositoryInfo *> *)p)[index] = *(mtrep3__RepositoryInfo **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTomtrep__RepositoryInfo:
		if (t == SOAP_TYPE_mtrep__RepositoryInfo)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<mtrep__RepositoryInfo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<mtrep__RepositoryInfo *> *)p)[index] = *(mtrep__RepositoryInfo **)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_mtrep__RepositoryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep__RepositoryInfo type=%d location=%p object=%p\n", t, p, q));
		*(mtrep__RepositoryInfo*)p = *(mtrep__RepositoryInfo*)q;
		break;
	case SOAP_TYPE_mtrep__ArrayOfRepositoryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep__ArrayOfRepositoryInfo type=%d location=%p object=%p\n", t, p, q));
		*(mtrep__ArrayOfRepositoryInfo*)p = *(mtrep__ArrayOfRepositoryInfo*)q;
		break;
	case SOAP_TYPE__mtrep__TryGetRepositoryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep__TryGetRepositoryInfo type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep__TryGetRepositoryInfo*)p = *(_mtrep__TryGetRepositoryInfo*)q;
		break;
	case SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep__TryGetRepositoryInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep__TryGetRepositoryInfoResponse*)p = *(_mtrep__TryGetRepositoryInfoResponse*)q;
		break;
	case SOAP_TYPE__mtrep__PickRepository:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep__PickRepository type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep__PickRepository*)p = *(_mtrep__PickRepository*)q;
		break;
	case SOAP_TYPE__mtrep__PickRepositoryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep__PickRepositoryResponse type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep__PickRepositoryResponse*)p = *(_mtrep__PickRepositoryResponse*)q;
		break;
	case SOAP_TYPE__mtrep__GetAllRepositories:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep__GetAllRepositories type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep__GetAllRepositories*)p = *(_mtrep__GetAllRepositories*)q;
		break;
	case SOAP_TYPE__mtrep__GetAllRepositoriesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep__GetAllRepositoriesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep__GetAllRepositoriesResponse*)p = *(_mtrep__GetAllRepositoriesResponse*)q;
		break;
	case SOAP_TYPE__mtrep__GetRepositories:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep__GetRepositories type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep__GetRepositories*)p = *(_mtrep__GetRepositories*)q;
		break;
	case SOAP_TYPE__mtrep__GetRepositoriesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep__GetRepositoriesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep__GetRepositoriesResponse*)p = *(_mtrep__GetRepositoriesResponse*)q;
		break;
	case SOAP_TYPE__mtrep2__GetListCreationTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep2__GetListCreationTime type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep2__GetListCreationTime*)p = *(_mtrep2__GetListCreationTime*)q;
		break;
	case SOAP_TYPE__mtrep2__GetListCreationTimeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep2__GetListCreationTimeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep2__GetListCreationTimeResponse*)p = *(_mtrep2__GetListCreationTimeResponse*)q;
		break;
	case SOAP_TYPE_mtrep3__ClientInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep3__ClientInfo type=%d location=%p object=%p\n", t, p, q));
		*(mtrep3__ClientInfo*)p = *(mtrep3__ClientInfo*)q;
		break;
	case SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep3__ArrayOfRepositoryInfo type=%d location=%p object=%p\n", t, p, q));
		*(mtrep3__ArrayOfRepositoryInfo*)p = *(mtrep3__ArrayOfRepositoryInfo*)q;
		break;
	case SOAP_TYPE_mtrep3__RepositoryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep3__RepositoryInfo type=%d location=%p object=%p\n", t, p, q));
		*(mtrep3__RepositoryInfo*)p = *(mtrep3__RepositoryInfo*)q;
		break;
	case SOAP_TYPE__mtrep3__GetRepositories2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep3__GetRepositories2 type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep3__GetRepositories2*)p = *(_mtrep3__GetRepositories2*)q;
		break;
	case SOAP_TYPE__mtrep3__GetRepositories2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep3__GetRepositories2Response type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep3__GetRepositories2Response*)p = *(_mtrep3__GetRepositories2Response*)q;
		break;
	case SOAP_TYPE__mtrep3__PickRepository2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep3__PickRepository2 type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep3__PickRepository2*)p = *(_mtrep3__PickRepository2*)q;
		break;
	case SOAP_TYPE__mtrep3__PickRepository2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep3__PickRepository2Response type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep3__PickRepository2Response*)p = *(_mtrep3__PickRepository2Response*)q;
		break;
	case SOAP_TYPE__mtrep3__TryGetRepositoryInfo2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep3__TryGetRepositoryInfo2 type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep3__TryGetRepositoryInfo2*)p = *(_mtrep3__TryGetRepositoryInfo2*)q;
		break;
	case SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep3__TryGetRepositoryInfo2Response type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep3__TryGetRepositoryInfo2Response*)p = *(_mtrep3__TryGetRepositoryInfo2Response*)q;
		break;
	case SOAP_TYPE_mtrep4__ClientInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep4__ClientInfo type=%d location=%p object=%p\n", t, p, q));
		*(mtrep4__ClientInfo*)p = *(mtrep4__ClientInfo*)q;
		break;
	case SOAP_TYPE_mtrep4__RepositoryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep4__RepositoryInfo type=%d location=%p object=%p\n", t, p, q));
		*(mtrep4__RepositoryInfo*)p = *(mtrep4__RepositoryInfo*)q;
		break;
	case SOAP_TYPE__mtrep4__VerifyRepository:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep4__VerifyRepository type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep4__VerifyRepository*)p = *(_mtrep4__VerifyRepository*)q;
		break;
	case SOAP_TYPE__mtrep4__VerifyRepositoryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep4__VerifyRepositoryResponse type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep4__VerifyRepositoryResponse*)p = *(_mtrep4__VerifyRepositoryResponse*)q;
		break;
	case SOAP_TYPE_mtrep5__ClientInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep5__ClientInfo type=%d location=%p object=%p\n", t, p, q));
		*(mtrep5__ClientInfo*)p = *(mtrep5__ClientInfo*)q;
		break;
	case SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep5__ArrayOfRepositoryInfo2 type=%d location=%p object=%p\n", t, p, q));
		*(mtrep5__ArrayOfRepositoryInfo2*)p = *(mtrep5__ArrayOfRepositoryInfo2*)q;
		break;
	case SOAP_TYPE_mtrep5__RepositoryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep5__RepositoryInfo type=%d location=%p object=%p\n", t, p, q));
		*(mtrep5__RepositoryInfo*)p = *(mtrep5__RepositoryInfo*)q;
		break;
	case SOAP_TYPE__mtrep5__GetRepositories3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep5__GetRepositories3 type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep5__GetRepositories3*)p = *(_mtrep5__GetRepositories3*)q;
		break;
	case SOAP_TYPE__mtrep5__GetRepositories3Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep5__GetRepositories3Response type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep5__GetRepositories3Response*)p = *(_mtrep5__GetRepositories3Response*)q;
		break;
	case SOAP_TYPE__mtrep5__PickRepository3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep5__PickRepository3 type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep5__PickRepository3*)p = *(_mtrep5__PickRepository3*)q;
		break;
	case SOAP_TYPE__mtrep5__PickRepository3Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep5__PickRepository3Response type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep5__PickRepository3Response*)p = *(_mtrep5__PickRepository3Response*)q;
		break;
	case SOAP_TYPE_mtrep6__ClientInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep6__ClientInfo type=%d location=%p object=%p\n", t, p, q));
		*(mtrep6__ClientInfo*)p = *(mtrep6__ClientInfo*)q;
		break;
	case SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep6__ArrayOfRepositoryInfo3 type=%d location=%p object=%p\n", t, p, q));
		*(mtrep6__ArrayOfRepositoryInfo3*)p = *(mtrep6__ArrayOfRepositoryInfo3*)q;
		break;
	case SOAP_TYPE_mtrep6__RepositoryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep6__RepositoryInfo type=%d location=%p object=%p\n", t, p, q));
		*(mtrep6__RepositoryInfo*)p = *(mtrep6__RepositoryInfo*)q;
		break;
	case SOAP_TYPE__mtrep6__GetRepositories4:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep6__GetRepositories4 type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep6__GetRepositories4*)p = *(_mtrep6__GetRepositories4*)q;
		break;
	case SOAP_TYPE__mtrep6__GetRepositories4Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep6__GetRepositories4Response type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep6__GetRepositories4Response*)p = *(_mtrep6__GetRepositories4Response*)q;
		break;
	case SOAP_TYPE__mtrep6__PickRepository4:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep6__PickRepository4 type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep6__PickRepository4*)p = *(_mtrep6__PickRepository4*)q;
		break;
	case SOAP_TYPE__mtrep6__PickRepository4Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep6__PickRepository4Response type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep6__PickRepository4Response*)p = *(_mtrep6__PickRepository4Response*)q;
		break;
	case SOAP_TYPE_mtrep7__ClientInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep7__ClientInfo type=%d location=%p object=%p\n", t, p, q));
		*(mtrep7__ClientInfo*)p = *(mtrep7__ClientInfo*)q;
		break;
	case SOAP_TYPE_mtrep7__RepositoryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep7__RepositoryInfo type=%d location=%p object=%p\n", t, p, q));
		*(mtrep7__RepositoryInfo*)p = *(mtrep7__RepositoryInfo*)q;
		break;
	case SOAP_TYPE__mtrep7__VerifyRepository2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep7__VerifyRepository2 type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep7__VerifyRepository2*)p = *(_mtrep7__VerifyRepository2*)q;
		break;
	case SOAP_TYPE__mtrep7__VerifyRepository2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep7__VerifyRepository2Response type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep7__VerifyRepository2Response*)p = *(_mtrep7__VerifyRepository2Response*)q;
		break;
	case SOAP_TYPE__mtrep7__TryGetRepositoryInfo3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep7__TryGetRepositoryInfo3 type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep7__TryGetRepositoryInfo3*)p = *(_mtrep7__TryGetRepositoryInfo3*)q;
		break;
	case SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _mtrep7__TryGetRepositoryInfo3Response type=%d location=%p object=%p\n", t, p, q));
		*(_mtrep7__TryGetRepositoryInfo3Response*)p = *(_mtrep7__TryGetRepositoryInfo3Response*)q;
		break;
	case SOAP_TYPE_mtrep5__RepositoryInfo2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep5__RepositoryInfo2 type=%d location=%p object=%p\n", t, p, q));
		*(mtrep5__RepositoryInfo2*)p = *(mtrep5__RepositoryInfo2*)q;
		break;
	case SOAP_TYPE_mtrep6__RepositoryInfo2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep6__RepositoryInfo2 type=%d location=%p object=%p\n", t, p, q));
		*(mtrep6__RepositoryInfo2*)p = *(mtrep6__RepositoryInfo2*)q;
		break;
	case SOAP_TYPE_mtrep7__RepositoryInfo2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep7__RepositoryInfo2 type=%d location=%p object=%p\n", t, p, q));
		*(mtrep7__RepositoryInfo2*)p = *(mtrep7__RepositoryInfo2*)q;
		break;
	case SOAP_TYPE_mtrep6__RepositoryInfo3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep6__RepositoryInfo3 type=%d location=%p object=%p\n", t, p, q));
		*(mtrep6__RepositoryInfo3*)p = *(mtrep6__RepositoryInfo3*)q;
		break;
	case SOAP_TYPE_mtrep7__RepositoryInfo3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mtrep7__RepositoryInfo3 type=%d location=%p object=%p\n", t, p, q));
		*(mtrep7__RepositoryInfo3*)p = *(mtrep7__RepositoryInfo3*)q;
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__TryGetRepositoryInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__TryGetRepositoryInfo*)p = *(struct __mtrep7__TryGetRepositoryInfo*)q;
		break;
	case SOAP_TYPE___mtrep7__PickRepository:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__PickRepository type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__PickRepository*)p = *(struct __mtrep7__PickRepository*)q;
		break;
	case SOAP_TYPE___mtrep7__GetAllRepositories:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__GetAllRepositories type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__GetAllRepositories*)p = *(struct __mtrep7__GetAllRepositories*)q;
		break;
	case SOAP_TYPE___mtrep7__GetRepositories:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__GetRepositories type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__GetRepositories*)p = *(struct __mtrep7__GetRepositories*)q;
		break;
	case SOAP_TYPE___mtrep7__GetListCreationTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__GetListCreationTime type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__GetListCreationTime*)p = *(struct __mtrep7__GetListCreationTime*)q;
		break;
	case SOAP_TYPE___mtrep7__GetRepositories2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__GetRepositories2 type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__GetRepositories2*)p = *(struct __mtrep7__GetRepositories2*)q;
		break;
	case SOAP_TYPE___mtrep7__PickRepository2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__PickRepository2 type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__PickRepository2*)p = *(struct __mtrep7__PickRepository2*)q;
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__TryGetRepositoryInfo2 type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__TryGetRepositoryInfo2*)p = *(struct __mtrep7__TryGetRepositoryInfo2*)q;
		break;
	case SOAP_TYPE___mtrep7__VerifyRepository:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__VerifyRepository type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__VerifyRepository*)p = *(struct __mtrep7__VerifyRepository*)q;
		break;
	case SOAP_TYPE___mtrep7__GetRepositories3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__GetRepositories3 type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__GetRepositories3*)p = *(struct __mtrep7__GetRepositories3*)q;
		break;
	case SOAP_TYPE___mtrep7__PickRepository3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__PickRepository3 type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__PickRepository3*)p = *(struct __mtrep7__PickRepository3*)q;
		break;
	case SOAP_TYPE___mtrep7__GetRepositories4:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__GetRepositories4 type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__GetRepositories4*)p = *(struct __mtrep7__GetRepositories4*)q;
		break;
	case SOAP_TYPE___mtrep7__PickRepository4:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__PickRepository4 type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__PickRepository4*)p = *(struct __mtrep7__PickRepository4*)q;
		break;
	case SOAP_TYPE___mtrep7__VerifyRepository2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__VerifyRepository2 type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__VerifyRepository2*)p = *(struct __mtrep7__VerifyRepository2*)q;
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__TryGetRepositoryInfo3 type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__TryGetRepositoryInfo3*)p = *(struct __mtrep7__TryGetRepositoryInfo3*)q;
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__TryGetRepositoryInfo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__TryGetRepositoryInfo_*)p = *(struct __mtrep7__TryGetRepositoryInfo_*)q;
		break;
	case SOAP_TYPE___mtrep7__PickRepository_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__PickRepository_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__PickRepository_*)p = *(struct __mtrep7__PickRepository_*)q;
		break;
	case SOAP_TYPE___mtrep7__GetAllRepositories_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__GetAllRepositories_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__GetAllRepositories_*)p = *(struct __mtrep7__GetAllRepositories_*)q;
		break;
	case SOAP_TYPE___mtrep7__GetRepositories_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__GetRepositories_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__GetRepositories_*)p = *(struct __mtrep7__GetRepositories_*)q;
		break;
	case SOAP_TYPE___mtrep7__GetListCreationTime_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__GetListCreationTime_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__GetListCreationTime_*)p = *(struct __mtrep7__GetListCreationTime_*)q;
		break;
	case SOAP_TYPE___mtrep7__GetRepositories2_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__GetRepositories2_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__GetRepositories2_*)p = *(struct __mtrep7__GetRepositories2_*)q;
		break;
	case SOAP_TYPE___mtrep7__PickRepository2_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__PickRepository2_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__PickRepository2_*)p = *(struct __mtrep7__PickRepository2_*)q;
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo2_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__TryGetRepositoryInfo2_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__TryGetRepositoryInfo2_*)p = *(struct __mtrep7__TryGetRepositoryInfo2_*)q;
		break;
	case SOAP_TYPE___mtrep7__VerifyRepository_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__VerifyRepository_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__VerifyRepository_*)p = *(struct __mtrep7__VerifyRepository_*)q;
		break;
	case SOAP_TYPE___mtrep7__GetRepositories3_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__GetRepositories3_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__GetRepositories3_*)p = *(struct __mtrep7__GetRepositories3_*)q;
		break;
	case SOAP_TYPE___mtrep7__PickRepository3_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__PickRepository3_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__PickRepository3_*)p = *(struct __mtrep7__PickRepository3_*)q;
		break;
	case SOAP_TYPE___mtrep7__GetRepositories4_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__GetRepositories4_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__GetRepositories4_*)p = *(struct __mtrep7__GetRepositories4_*)q;
		break;
	case SOAP_TYPE___mtrep7__PickRepository4_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__PickRepository4_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__PickRepository4_*)p = *(struct __mtrep7__PickRepository4_*)q;
		break;
	case SOAP_TYPE___mtrep7__VerifyRepository2_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__VerifyRepository2_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__VerifyRepository2_*)p = *(struct __mtrep7__VerifyRepository2_*)q;
		break;
	case SOAP_TYPE___mtrep7__TryGetRepositoryInfo3_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __mtrep7__TryGetRepositoryInfo3_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __mtrep7__TryGetRepositoryInfo3_*)p = *(struct __mtrep7__TryGetRepositoryInfo3_*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag?tag:"byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag?tag:"int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag?tag:"double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag?tag:"boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep7__RepositoryReleaseState(struct soap *soap, enum mtrep7__RepositoryReleaseState *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep7__RepositoryReleaseState
	*a = SOAP_DEFAULT_mtrep7__RepositoryReleaseState;
#else
	*a = (enum mtrep7__RepositoryReleaseState)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep7__RepositoryReleaseState[] =
{	{ (LONG64)mtrep7__RepositoryReleaseState__Stable, "Stable" },
	{ (LONG64)mtrep7__RepositoryReleaseState__Next, "Next" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep7__RepositoryReleaseState2s(struct soap *soap, enum mtrep7__RepositoryReleaseState n)
{	const char *s = soap_code_str(soap_codes_mtrep7__RepositoryReleaseState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep7__RepositoryReleaseState(struct soap *soap, const char *tag, int id, const enum mtrep7__RepositoryReleaseState *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep7__RepositoryReleaseState), type) || soap_send(soap, soap_mtrep7__RepositoryReleaseState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep7__RepositoryReleaseState(struct soap *soap, const char *s, enum mtrep7__RepositoryReleaseState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep7__RepositoryReleaseState, s);
	if (map)
		*a = (enum mtrep7__RepositoryReleaseState)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep7__RepositoryReleaseState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep7__RepositoryReleaseState * SOAP_FMAC4 soap_in_mtrep7__RepositoryReleaseState(struct soap *soap, const char *tag, enum mtrep7__RepositoryReleaseState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep7__RepositoryReleaseState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep7__RepositoryReleaseState, sizeof(enum mtrep7__RepositoryReleaseState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep7__RepositoryReleaseState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep7__RepositoryReleaseState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep7__RepositoryReleaseState, SOAP_TYPE_mtrep7__RepositoryReleaseState, sizeof(enum mtrep7__RepositoryReleaseState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep7__RepositoryReleaseState(struct soap *soap, const enum mtrep7__RepositoryReleaseState *a, const char *tag, const char *type)
{
	if (soap_out_mtrep7__RepositoryReleaseState(soap, tag?tag:"mtrep7:RepositoryReleaseState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep7__RepositoryReleaseState * SOAP_FMAC4 soap_get_mtrep7__RepositoryReleaseState(struct soap *soap, enum mtrep7__RepositoryReleaseState *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep7__RepositoryReleaseState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep7__RepositoryStatus(struct soap *soap, enum mtrep7__RepositoryStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep7__RepositoryStatus
	*a = SOAP_DEFAULT_mtrep7__RepositoryStatus;
#else
	*a = (enum mtrep7__RepositoryStatus)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep7__RepositoryStatus[] =
{	{ (LONG64)mtrep7__RepositoryStatus__Online, "Online" },
	{ (LONG64)mtrep7__RepositoryStatus__Offline, "Offline" },
	{ (LONG64)mtrep7__RepositoryStatus__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep7__RepositoryStatus2s(struct soap *soap, enum mtrep7__RepositoryStatus n)
{	const char *s = soap_code_str(soap_codes_mtrep7__RepositoryStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep7__RepositoryStatus(struct soap *soap, const char *tag, int id, const enum mtrep7__RepositoryStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep7__RepositoryStatus), type) || soap_send(soap, soap_mtrep7__RepositoryStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep7__RepositoryStatus(struct soap *soap, const char *s, enum mtrep7__RepositoryStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep7__RepositoryStatus, s);
	if (map)
		*a = (enum mtrep7__RepositoryStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep7__RepositoryStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep7__RepositoryStatus * SOAP_FMAC4 soap_in_mtrep7__RepositoryStatus(struct soap *soap, const char *tag, enum mtrep7__RepositoryStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep7__RepositoryStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep7__RepositoryStatus, sizeof(enum mtrep7__RepositoryStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep7__RepositoryStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep7__RepositoryStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep7__RepositoryStatus, SOAP_TYPE_mtrep7__RepositoryStatus, sizeof(enum mtrep7__RepositoryStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep7__RepositoryStatus(struct soap *soap, const enum mtrep7__RepositoryStatus *a, const char *tag, const char *type)
{
	if (soap_out_mtrep7__RepositoryStatus(soap, tag?tag:"mtrep7:RepositoryStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep7__RepositoryStatus * SOAP_FMAC4 soap_get_mtrep7__RepositoryStatus(struct soap *soap, enum mtrep7__RepositoryStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep7__RepositoryStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep7__PackageLevel(struct soap *soap, enum mtrep7__PackageLevel *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep7__PackageLevel
	*a = SOAP_DEFAULT_mtrep7__PackageLevel;
#else
	*a = (enum mtrep7__PackageLevel)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep7__PackageLevel[] =
{	{ (LONG64)mtrep7__PackageLevel__Essential, "Essential" },
	{ (LONG64)mtrep7__PackageLevel__Basic, "Basic" },
	{ (LONG64)mtrep7__PackageLevel__Advanced, "Advanced" },
	{ (LONG64)mtrep7__PackageLevel__Complete, "Complete" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep7__PackageLevel2s(struct soap *soap, enum mtrep7__PackageLevel n)
{	const char *s = soap_code_str(soap_codes_mtrep7__PackageLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep7__PackageLevel(struct soap *soap, const char *tag, int id, const enum mtrep7__PackageLevel *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep7__PackageLevel), type) || soap_send(soap, soap_mtrep7__PackageLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep7__PackageLevel(struct soap *soap, const char *s, enum mtrep7__PackageLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep7__PackageLevel, s);
	if (map)
		*a = (enum mtrep7__PackageLevel)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep7__PackageLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep7__PackageLevel * SOAP_FMAC4 soap_in_mtrep7__PackageLevel(struct soap *soap, const char *tag, enum mtrep7__PackageLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep7__PackageLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep7__PackageLevel, sizeof(enum mtrep7__PackageLevel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep7__PackageLevel(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep7__PackageLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep7__PackageLevel, SOAP_TYPE_mtrep7__PackageLevel, sizeof(enum mtrep7__PackageLevel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep7__PackageLevel(struct soap *soap, const enum mtrep7__PackageLevel *a, const char *tag, const char *type)
{
	if (soap_out_mtrep7__PackageLevel(soap, tag?tag:"mtrep7:PackageLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep7__PackageLevel * SOAP_FMAC4 soap_get_mtrep7__PackageLevel(struct soap *soap, enum mtrep7__PackageLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep7__PackageLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep7__RepositoryIntegrity(struct soap *soap, enum mtrep7__RepositoryIntegrity *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep7__RepositoryIntegrity
	*a = SOAP_DEFAULT_mtrep7__RepositoryIntegrity;
#else
	*a = (enum mtrep7__RepositoryIntegrity)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep7__RepositoryIntegrity[] =
{	{ (LONG64)mtrep7__RepositoryIntegrity__Intact, "Intact" },
	{ (LONG64)mtrep7__RepositoryIntegrity__Corrupted, "Corrupted" },
	{ (LONG64)mtrep7__RepositoryIntegrity__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep7__RepositoryIntegrity2s(struct soap *soap, enum mtrep7__RepositoryIntegrity n)
{	const char *s = soap_code_str(soap_codes_mtrep7__RepositoryIntegrity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep7__RepositoryIntegrity(struct soap *soap, const char *tag, int id, const enum mtrep7__RepositoryIntegrity *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep7__RepositoryIntegrity), type) || soap_send(soap, soap_mtrep7__RepositoryIntegrity2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep7__RepositoryIntegrity(struct soap *soap, const char *s, enum mtrep7__RepositoryIntegrity *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep7__RepositoryIntegrity, s);
	if (map)
		*a = (enum mtrep7__RepositoryIntegrity)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep7__RepositoryIntegrity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep7__RepositoryIntegrity * SOAP_FMAC4 soap_in_mtrep7__RepositoryIntegrity(struct soap *soap, const char *tag, enum mtrep7__RepositoryIntegrity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep7__RepositoryIntegrity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep7__RepositoryIntegrity, sizeof(enum mtrep7__RepositoryIntegrity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep7__RepositoryIntegrity(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep7__RepositoryIntegrity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep7__RepositoryIntegrity, SOAP_TYPE_mtrep7__RepositoryIntegrity, sizeof(enum mtrep7__RepositoryIntegrity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep7__RepositoryIntegrity(struct soap *soap, const enum mtrep7__RepositoryIntegrity *a, const char *tag, const char *type)
{
	if (soap_out_mtrep7__RepositoryIntegrity(soap, tag?tag:"mtrep7:RepositoryIntegrity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep7__RepositoryIntegrity * SOAP_FMAC4 soap_get_mtrep7__RepositoryIntegrity(struct soap *soap, enum mtrep7__RepositoryIntegrity *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep7__RepositoryIntegrity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep6__RepositoryStatus(struct soap *soap, enum mtrep6__RepositoryStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep6__RepositoryStatus
	*a = SOAP_DEFAULT_mtrep6__RepositoryStatus;
#else
	*a = (enum mtrep6__RepositoryStatus)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep6__RepositoryStatus[] =
{	{ (LONG64)mtrep6__RepositoryStatus__Online, "Online" },
	{ (LONG64)mtrep6__RepositoryStatus__Offline, "Offline" },
	{ (LONG64)mtrep6__RepositoryStatus__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep6__RepositoryStatus2s(struct soap *soap, enum mtrep6__RepositoryStatus n)
{	const char *s = soap_code_str(soap_codes_mtrep6__RepositoryStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep6__RepositoryStatus(struct soap *soap, const char *tag, int id, const enum mtrep6__RepositoryStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep6__RepositoryStatus), type) || soap_send(soap, soap_mtrep6__RepositoryStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep6__RepositoryStatus(struct soap *soap, const char *s, enum mtrep6__RepositoryStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep6__RepositoryStatus, s);
	if (map)
		*a = (enum mtrep6__RepositoryStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep6__RepositoryStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep6__RepositoryStatus * SOAP_FMAC4 soap_in_mtrep6__RepositoryStatus(struct soap *soap, const char *tag, enum mtrep6__RepositoryStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep6__RepositoryStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep6__RepositoryStatus, sizeof(enum mtrep6__RepositoryStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep6__RepositoryStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep6__RepositoryStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep6__RepositoryStatus, SOAP_TYPE_mtrep6__RepositoryStatus, sizeof(enum mtrep6__RepositoryStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep6__RepositoryStatus(struct soap *soap, const enum mtrep6__RepositoryStatus *a, const char *tag, const char *type)
{
	if (soap_out_mtrep6__RepositoryStatus(soap, tag?tag:"mtrep6:RepositoryStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep6__RepositoryStatus * SOAP_FMAC4 soap_get_mtrep6__RepositoryStatus(struct soap *soap, enum mtrep6__RepositoryStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep6__RepositoryStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep6__PackageLevel(struct soap *soap, enum mtrep6__PackageLevel *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep6__PackageLevel
	*a = SOAP_DEFAULT_mtrep6__PackageLevel;
#else
	*a = (enum mtrep6__PackageLevel)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep6__PackageLevel[] =
{	{ (LONG64)mtrep6__PackageLevel__Essential, "Essential" },
	{ (LONG64)mtrep6__PackageLevel__Basic, "Basic" },
	{ (LONG64)mtrep6__PackageLevel__Advanced, "Advanced" },
	{ (LONG64)mtrep6__PackageLevel__Complete, "Complete" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep6__PackageLevel2s(struct soap *soap, enum mtrep6__PackageLevel n)
{	const char *s = soap_code_str(soap_codes_mtrep6__PackageLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep6__PackageLevel(struct soap *soap, const char *tag, int id, const enum mtrep6__PackageLevel *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep6__PackageLevel), type) || soap_send(soap, soap_mtrep6__PackageLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep6__PackageLevel(struct soap *soap, const char *s, enum mtrep6__PackageLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep6__PackageLevel, s);
	if (map)
		*a = (enum mtrep6__PackageLevel)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep6__PackageLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep6__PackageLevel * SOAP_FMAC4 soap_in_mtrep6__PackageLevel(struct soap *soap, const char *tag, enum mtrep6__PackageLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep6__PackageLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep6__PackageLevel, sizeof(enum mtrep6__PackageLevel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep6__PackageLevel(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep6__PackageLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep6__PackageLevel, SOAP_TYPE_mtrep6__PackageLevel, sizeof(enum mtrep6__PackageLevel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep6__PackageLevel(struct soap *soap, const enum mtrep6__PackageLevel *a, const char *tag, const char *type)
{
	if (soap_out_mtrep6__PackageLevel(soap, tag?tag:"mtrep6:PackageLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep6__PackageLevel * SOAP_FMAC4 soap_get_mtrep6__PackageLevel(struct soap *soap, enum mtrep6__PackageLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep6__PackageLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep6__RepositoryIntegrity(struct soap *soap, enum mtrep6__RepositoryIntegrity *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep6__RepositoryIntegrity
	*a = SOAP_DEFAULT_mtrep6__RepositoryIntegrity;
#else
	*a = (enum mtrep6__RepositoryIntegrity)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep6__RepositoryIntegrity[] =
{	{ (LONG64)mtrep6__RepositoryIntegrity__Intact, "Intact" },
	{ (LONG64)mtrep6__RepositoryIntegrity__Corrupted, "Corrupted" },
	{ (LONG64)mtrep6__RepositoryIntegrity__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep6__RepositoryIntegrity2s(struct soap *soap, enum mtrep6__RepositoryIntegrity n)
{	const char *s = soap_code_str(soap_codes_mtrep6__RepositoryIntegrity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep6__RepositoryIntegrity(struct soap *soap, const char *tag, int id, const enum mtrep6__RepositoryIntegrity *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep6__RepositoryIntegrity), type) || soap_send(soap, soap_mtrep6__RepositoryIntegrity2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep6__RepositoryIntegrity(struct soap *soap, const char *s, enum mtrep6__RepositoryIntegrity *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep6__RepositoryIntegrity, s);
	if (map)
		*a = (enum mtrep6__RepositoryIntegrity)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep6__RepositoryIntegrity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep6__RepositoryIntegrity * SOAP_FMAC4 soap_in_mtrep6__RepositoryIntegrity(struct soap *soap, const char *tag, enum mtrep6__RepositoryIntegrity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep6__RepositoryIntegrity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep6__RepositoryIntegrity, sizeof(enum mtrep6__RepositoryIntegrity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep6__RepositoryIntegrity(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep6__RepositoryIntegrity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep6__RepositoryIntegrity, SOAP_TYPE_mtrep6__RepositoryIntegrity, sizeof(enum mtrep6__RepositoryIntegrity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep6__RepositoryIntegrity(struct soap *soap, const enum mtrep6__RepositoryIntegrity *a, const char *tag, const char *type)
{
	if (soap_out_mtrep6__RepositoryIntegrity(soap, tag?tag:"mtrep6:RepositoryIntegrity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep6__RepositoryIntegrity * SOAP_FMAC4 soap_get_mtrep6__RepositoryIntegrity(struct soap *soap, enum mtrep6__RepositoryIntegrity *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep6__RepositoryIntegrity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep6__RepositoryReleaseState(struct soap *soap, enum mtrep6__RepositoryReleaseState *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep6__RepositoryReleaseState
	*a = SOAP_DEFAULT_mtrep6__RepositoryReleaseState;
#else
	*a = (enum mtrep6__RepositoryReleaseState)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep6__RepositoryReleaseState[] =
{	{ (LONG64)mtrep6__RepositoryReleaseState__Stable, "Stable" },
	{ (LONG64)mtrep6__RepositoryReleaseState__Next, "Next" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep6__RepositoryReleaseState2s(struct soap *soap, enum mtrep6__RepositoryReleaseState n)
{	const char *s = soap_code_str(soap_codes_mtrep6__RepositoryReleaseState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep6__RepositoryReleaseState(struct soap *soap, const char *tag, int id, const enum mtrep6__RepositoryReleaseState *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep6__RepositoryReleaseState), type) || soap_send(soap, soap_mtrep6__RepositoryReleaseState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep6__RepositoryReleaseState(struct soap *soap, const char *s, enum mtrep6__RepositoryReleaseState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep6__RepositoryReleaseState, s);
	if (map)
		*a = (enum mtrep6__RepositoryReleaseState)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep6__RepositoryReleaseState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep6__RepositoryReleaseState * SOAP_FMAC4 soap_in_mtrep6__RepositoryReleaseState(struct soap *soap, const char *tag, enum mtrep6__RepositoryReleaseState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep6__RepositoryReleaseState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep6__RepositoryReleaseState, sizeof(enum mtrep6__RepositoryReleaseState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep6__RepositoryReleaseState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep6__RepositoryReleaseState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep6__RepositoryReleaseState, SOAP_TYPE_mtrep6__RepositoryReleaseState, sizeof(enum mtrep6__RepositoryReleaseState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep6__RepositoryReleaseState(struct soap *soap, const enum mtrep6__RepositoryReleaseState *a, const char *tag, const char *type)
{
	if (soap_out_mtrep6__RepositoryReleaseState(soap, tag?tag:"mtrep6:RepositoryReleaseState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep6__RepositoryReleaseState * SOAP_FMAC4 soap_get_mtrep6__RepositoryReleaseState(struct soap *soap, enum mtrep6__RepositoryReleaseState *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep6__RepositoryReleaseState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep5__RepositoryStatus(struct soap *soap, enum mtrep5__RepositoryStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep5__RepositoryStatus
	*a = SOAP_DEFAULT_mtrep5__RepositoryStatus;
#else
	*a = (enum mtrep5__RepositoryStatus)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep5__RepositoryStatus[] =
{	{ (LONG64)mtrep5__RepositoryStatus__Online, "Online" },
	{ (LONG64)mtrep5__RepositoryStatus__Offline, "Offline" },
	{ (LONG64)mtrep5__RepositoryStatus__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep5__RepositoryStatus2s(struct soap *soap, enum mtrep5__RepositoryStatus n)
{	const char *s = soap_code_str(soap_codes_mtrep5__RepositoryStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep5__RepositoryStatus(struct soap *soap, const char *tag, int id, const enum mtrep5__RepositoryStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep5__RepositoryStatus), type) || soap_send(soap, soap_mtrep5__RepositoryStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep5__RepositoryStatus(struct soap *soap, const char *s, enum mtrep5__RepositoryStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep5__RepositoryStatus, s);
	if (map)
		*a = (enum mtrep5__RepositoryStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep5__RepositoryStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep5__RepositoryStatus * SOAP_FMAC4 soap_in_mtrep5__RepositoryStatus(struct soap *soap, const char *tag, enum mtrep5__RepositoryStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep5__RepositoryStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep5__RepositoryStatus, sizeof(enum mtrep5__RepositoryStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep5__RepositoryStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep5__RepositoryStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep5__RepositoryStatus, SOAP_TYPE_mtrep5__RepositoryStatus, sizeof(enum mtrep5__RepositoryStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep5__RepositoryStatus(struct soap *soap, const enum mtrep5__RepositoryStatus *a, const char *tag, const char *type)
{
	if (soap_out_mtrep5__RepositoryStatus(soap, tag?tag:"mtrep5:RepositoryStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep5__RepositoryStatus * SOAP_FMAC4 soap_get_mtrep5__RepositoryStatus(struct soap *soap, enum mtrep5__RepositoryStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep5__RepositoryStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep5__PackageLevel(struct soap *soap, enum mtrep5__PackageLevel *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep5__PackageLevel
	*a = SOAP_DEFAULT_mtrep5__PackageLevel;
#else
	*a = (enum mtrep5__PackageLevel)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep5__PackageLevel[] =
{	{ (LONG64)mtrep5__PackageLevel__Essential, "Essential" },
	{ (LONG64)mtrep5__PackageLevel__Basic, "Basic" },
	{ (LONG64)mtrep5__PackageLevel__Advanced, "Advanced" },
	{ (LONG64)mtrep5__PackageLevel__Complete, "Complete" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep5__PackageLevel2s(struct soap *soap, enum mtrep5__PackageLevel n)
{	const char *s = soap_code_str(soap_codes_mtrep5__PackageLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep5__PackageLevel(struct soap *soap, const char *tag, int id, const enum mtrep5__PackageLevel *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep5__PackageLevel), type) || soap_send(soap, soap_mtrep5__PackageLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep5__PackageLevel(struct soap *soap, const char *s, enum mtrep5__PackageLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep5__PackageLevel, s);
	if (map)
		*a = (enum mtrep5__PackageLevel)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep5__PackageLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep5__PackageLevel * SOAP_FMAC4 soap_in_mtrep5__PackageLevel(struct soap *soap, const char *tag, enum mtrep5__PackageLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep5__PackageLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep5__PackageLevel, sizeof(enum mtrep5__PackageLevel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep5__PackageLevel(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep5__PackageLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep5__PackageLevel, SOAP_TYPE_mtrep5__PackageLevel, sizeof(enum mtrep5__PackageLevel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep5__PackageLevel(struct soap *soap, const enum mtrep5__PackageLevel *a, const char *tag, const char *type)
{
	if (soap_out_mtrep5__PackageLevel(soap, tag?tag:"mtrep5:PackageLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep5__PackageLevel * SOAP_FMAC4 soap_get_mtrep5__PackageLevel(struct soap *soap, enum mtrep5__PackageLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep5__PackageLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep5__RepositoryIntegrity(struct soap *soap, enum mtrep5__RepositoryIntegrity *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep5__RepositoryIntegrity
	*a = SOAP_DEFAULT_mtrep5__RepositoryIntegrity;
#else
	*a = (enum mtrep5__RepositoryIntegrity)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep5__RepositoryIntegrity[] =
{	{ (LONG64)mtrep5__RepositoryIntegrity__Intact, "Intact" },
	{ (LONG64)mtrep5__RepositoryIntegrity__Corrupted, "Corrupted" },
	{ (LONG64)mtrep5__RepositoryIntegrity__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep5__RepositoryIntegrity2s(struct soap *soap, enum mtrep5__RepositoryIntegrity n)
{	const char *s = soap_code_str(soap_codes_mtrep5__RepositoryIntegrity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep5__RepositoryIntegrity(struct soap *soap, const char *tag, int id, const enum mtrep5__RepositoryIntegrity *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep5__RepositoryIntegrity), type) || soap_send(soap, soap_mtrep5__RepositoryIntegrity2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep5__RepositoryIntegrity(struct soap *soap, const char *s, enum mtrep5__RepositoryIntegrity *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep5__RepositoryIntegrity, s);
	if (map)
		*a = (enum mtrep5__RepositoryIntegrity)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep5__RepositoryIntegrity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep5__RepositoryIntegrity * SOAP_FMAC4 soap_in_mtrep5__RepositoryIntegrity(struct soap *soap, const char *tag, enum mtrep5__RepositoryIntegrity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep5__RepositoryIntegrity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep5__RepositoryIntegrity, sizeof(enum mtrep5__RepositoryIntegrity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep5__RepositoryIntegrity(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep5__RepositoryIntegrity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep5__RepositoryIntegrity, SOAP_TYPE_mtrep5__RepositoryIntegrity, sizeof(enum mtrep5__RepositoryIntegrity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep5__RepositoryIntegrity(struct soap *soap, const enum mtrep5__RepositoryIntegrity *a, const char *tag, const char *type)
{
	if (soap_out_mtrep5__RepositoryIntegrity(soap, tag?tag:"mtrep5:RepositoryIntegrity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep5__RepositoryIntegrity * SOAP_FMAC4 soap_get_mtrep5__RepositoryIntegrity(struct soap *soap, enum mtrep5__RepositoryIntegrity *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep5__RepositoryIntegrity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep4__RepositoryStatus(struct soap *soap, enum mtrep4__RepositoryStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep4__RepositoryStatus
	*a = SOAP_DEFAULT_mtrep4__RepositoryStatus;
#else
	*a = (enum mtrep4__RepositoryStatus)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep4__RepositoryStatus[] =
{	{ (LONG64)mtrep4__RepositoryStatus__Online, "Online" },
	{ (LONG64)mtrep4__RepositoryStatus__Offline, "Offline" },
	{ (LONG64)mtrep4__RepositoryStatus__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep4__RepositoryStatus2s(struct soap *soap, enum mtrep4__RepositoryStatus n)
{	const char *s = soap_code_str(soap_codes_mtrep4__RepositoryStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep4__RepositoryStatus(struct soap *soap, const char *tag, int id, const enum mtrep4__RepositoryStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep4__RepositoryStatus), type) || soap_send(soap, soap_mtrep4__RepositoryStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep4__RepositoryStatus(struct soap *soap, const char *s, enum mtrep4__RepositoryStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep4__RepositoryStatus, s);
	if (map)
		*a = (enum mtrep4__RepositoryStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep4__RepositoryStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep4__RepositoryStatus * SOAP_FMAC4 soap_in_mtrep4__RepositoryStatus(struct soap *soap, const char *tag, enum mtrep4__RepositoryStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep4__RepositoryStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep4__RepositoryStatus, sizeof(enum mtrep4__RepositoryStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep4__RepositoryStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep4__RepositoryStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep4__RepositoryStatus, SOAP_TYPE_mtrep4__RepositoryStatus, sizeof(enum mtrep4__RepositoryStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep4__RepositoryStatus(struct soap *soap, const enum mtrep4__RepositoryStatus *a, const char *tag, const char *type)
{
	if (soap_out_mtrep4__RepositoryStatus(soap, tag?tag:"mtrep4:RepositoryStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep4__RepositoryStatus * SOAP_FMAC4 soap_get_mtrep4__RepositoryStatus(struct soap *soap, enum mtrep4__RepositoryStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep4__RepositoryStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep4__PackageLevel(struct soap *soap, enum mtrep4__PackageLevel *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep4__PackageLevel
	*a = SOAP_DEFAULT_mtrep4__PackageLevel;
#else
	*a = (enum mtrep4__PackageLevel)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep4__PackageLevel[] =
{	{ (LONG64)mtrep4__PackageLevel__Essential, "Essential" },
	{ (LONG64)mtrep4__PackageLevel__Basic, "Basic" },
	{ (LONG64)mtrep4__PackageLevel__Advanced, "Advanced" },
	{ (LONG64)mtrep4__PackageLevel__Complete, "Complete" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep4__PackageLevel2s(struct soap *soap, enum mtrep4__PackageLevel n)
{	const char *s = soap_code_str(soap_codes_mtrep4__PackageLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep4__PackageLevel(struct soap *soap, const char *tag, int id, const enum mtrep4__PackageLevel *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep4__PackageLevel), type) || soap_send(soap, soap_mtrep4__PackageLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep4__PackageLevel(struct soap *soap, const char *s, enum mtrep4__PackageLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep4__PackageLevel, s);
	if (map)
		*a = (enum mtrep4__PackageLevel)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep4__PackageLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep4__PackageLevel * SOAP_FMAC4 soap_in_mtrep4__PackageLevel(struct soap *soap, const char *tag, enum mtrep4__PackageLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep4__PackageLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep4__PackageLevel, sizeof(enum mtrep4__PackageLevel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep4__PackageLevel(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep4__PackageLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep4__PackageLevel, SOAP_TYPE_mtrep4__PackageLevel, sizeof(enum mtrep4__PackageLevel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep4__PackageLevel(struct soap *soap, const enum mtrep4__PackageLevel *a, const char *tag, const char *type)
{
	if (soap_out_mtrep4__PackageLevel(soap, tag?tag:"mtrep4:PackageLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep4__PackageLevel * SOAP_FMAC4 soap_get_mtrep4__PackageLevel(struct soap *soap, enum mtrep4__PackageLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep4__PackageLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep4__RepositoryIntegrity(struct soap *soap, enum mtrep4__RepositoryIntegrity *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep4__RepositoryIntegrity
	*a = SOAP_DEFAULT_mtrep4__RepositoryIntegrity;
#else
	*a = (enum mtrep4__RepositoryIntegrity)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep4__RepositoryIntegrity[] =
{	{ (LONG64)mtrep4__RepositoryIntegrity__Intact, "Intact" },
	{ (LONG64)mtrep4__RepositoryIntegrity__Corrupted, "Corrupted" },
	{ (LONG64)mtrep4__RepositoryIntegrity__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep4__RepositoryIntegrity2s(struct soap *soap, enum mtrep4__RepositoryIntegrity n)
{	const char *s = soap_code_str(soap_codes_mtrep4__RepositoryIntegrity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep4__RepositoryIntegrity(struct soap *soap, const char *tag, int id, const enum mtrep4__RepositoryIntegrity *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep4__RepositoryIntegrity), type) || soap_send(soap, soap_mtrep4__RepositoryIntegrity2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep4__RepositoryIntegrity(struct soap *soap, const char *s, enum mtrep4__RepositoryIntegrity *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep4__RepositoryIntegrity, s);
	if (map)
		*a = (enum mtrep4__RepositoryIntegrity)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep4__RepositoryIntegrity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep4__RepositoryIntegrity * SOAP_FMAC4 soap_in_mtrep4__RepositoryIntegrity(struct soap *soap, const char *tag, enum mtrep4__RepositoryIntegrity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep4__RepositoryIntegrity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep4__RepositoryIntegrity, sizeof(enum mtrep4__RepositoryIntegrity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep4__RepositoryIntegrity(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep4__RepositoryIntegrity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep4__RepositoryIntegrity, SOAP_TYPE_mtrep4__RepositoryIntegrity, sizeof(enum mtrep4__RepositoryIntegrity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep4__RepositoryIntegrity(struct soap *soap, const enum mtrep4__RepositoryIntegrity *a, const char *tag, const char *type)
{
	if (soap_out_mtrep4__RepositoryIntegrity(soap, tag?tag:"mtrep4:RepositoryIntegrity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep4__RepositoryIntegrity * SOAP_FMAC4 soap_get_mtrep4__RepositoryIntegrity(struct soap *soap, enum mtrep4__RepositoryIntegrity *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep4__RepositoryIntegrity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep3__RepositoryStatus(struct soap *soap, enum mtrep3__RepositoryStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep3__RepositoryStatus
	*a = SOAP_DEFAULT_mtrep3__RepositoryStatus;
#else
	*a = (enum mtrep3__RepositoryStatus)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep3__RepositoryStatus[] =
{	{ (LONG64)mtrep3__RepositoryStatus__Online, "Online" },
	{ (LONG64)mtrep3__RepositoryStatus__Offline, "Offline" },
	{ (LONG64)mtrep3__RepositoryStatus__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep3__RepositoryStatus2s(struct soap *soap, enum mtrep3__RepositoryStatus n)
{	const char *s = soap_code_str(soap_codes_mtrep3__RepositoryStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep3__RepositoryStatus(struct soap *soap, const char *tag, int id, const enum mtrep3__RepositoryStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep3__RepositoryStatus), type) || soap_send(soap, soap_mtrep3__RepositoryStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep3__RepositoryStatus(struct soap *soap, const char *s, enum mtrep3__RepositoryStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep3__RepositoryStatus, s);
	if (map)
		*a = (enum mtrep3__RepositoryStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep3__RepositoryStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep3__RepositoryStatus * SOAP_FMAC4 soap_in_mtrep3__RepositoryStatus(struct soap *soap, const char *tag, enum mtrep3__RepositoryStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep3__RepositoryStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep3__RepositoryStatus, sizeof(enum mtrep3__RepositoryStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep3__RepositoryStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep3__RepositoryStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep3__RepositoryStatus, SOAP_TYPE_mtrep3__RepositoryStatus, sizeof(enum mtrep3__RepositoryStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep3__RepositoryStatus(struct soap *soap, const enum mtrep3__RepositoryStatus *a, const char *tag, const char *type)
{
	if (soap_out_mtrep3__RepositoryStatus(soap, tag?tag:"mtrep3:RepositoryStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep3__RepositoryStatus * SOAP_FMAC4 soap_get_mtrep3__RepositoryStatus(struct soap *soap, enum mtrep3__RepositoryStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep3__RepositoryStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep3__PackageLevel(struct soap *soap, enum mtrep3__PackageLevel *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep3__PackageLevel
	*a = SOAP_DEFAULT_mtrep3__PackageLevel;
#else
	*a = (enum mtrep3__PackageLevel)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep3__PackageLevel[] =
{	{ (LONG64)mtrep3__PackageLevel__Essential, "Essential" },
	{ (LONG64)mtrep3__PackageLevel__Basic, "Basic" },
	{ (LONG64)mtrep3__PackageLevel__Advanced, "Advanced" },
	{ (LONG64)mtrep3__PackageLevel__Complete, "Complete" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep3__PackageLevel2s(struct soap *soap, enum mtrep3__PackageLevel n)
{	const char *s = soap_code_str(soap_codes_mtrep3__PackageLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep3__PackageLevel(struct soap *soap, const char *tag, int id, const enum mtrep3__PackageLevel *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep3__PackageLevel), type) || soap_send(soap, soap_mtrep3__PackageLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep3__PackageLevel(struct soap *soap, const char *s, enum mtrep3__PackageLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep3__PackageLevel, s);
	if (map)
		*a = (enum mtrep3__PackageLevel)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep3__PackageLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep3__PackageLevel * SOAP_FMAC4 soap_in_mtrep3__PackageLevel(struct soap *soap, const char *tag, enum mtrep3__PackageLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep3__PackageLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep3__PackageLevel, sizeof(enum mtrep3__PackageLevel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep3__PackageLevel(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep3__PackageLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep3__PackageLevel, SOAP_TYPE_mtrep3__PackageLevel, sizeof(enum mtrep3__PackageLevel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep3__PackageLevel(struct soap *soap, const enum mtrep3__PackageLevel *a, const char *tag, const char *type)
{
	if (soap_out_mtrep3__PackageLevel(soap, tag?tag:"mtrep3:PackageLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep3__PackageLevel * SOAP_FMAC4 soap_get_mtrep3__PackageLevel(struct soap *soap, enum mtrep3__PackageLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep3__PackageLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep3__RepositoryIntegrity(struct soap *soap, enum mtrep3__RepositoryIntegrity *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep3__RepositoryIntegrity
	*a = SOAP_DEFAULT_mtrep3__RepositoryIntegrity;
#else
	*a = (enum mtrep3__RepositoryIntegrity)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep3__RepositoryIntegrity[] =
{	{ (LONG64)mtrep3__RepositoryIntegrity__Intact, "Intact" },
	{ (LONG64)mtrep3__RepositoryIntegrity__Corrupted, "Corrupted" },
	{ (LONG64)mtrep3__RepositoryIntegrity__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep3__RepositoryIntegrity2s(struct soap *soap, enum mtrep3__RepositoryIntegrity n)
{	const char *s = soap_code_str(soap_codes_mtrep3__RepositoryIntegrity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep3__RepositoryIntegrity(struct soap *soap, const char *tag, int id, const enum mtrep3__RepositoryIntegrity *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep3__RepositoryIntegrity), type) || soap_send(soap, soap_mtrep3__RepositoryIntegrity2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep3__RepositoryIntegrity(struct soap *soap, const char *s, enum mtrep3__RepositoryIntegrity *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep3__RepositoryIntegrity, s);
	if (map)
		*a = (enum mtrep3__RepositoryIntegrity)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep3__RepositoryIntegrity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep3__RepositoryIntegrity * SOAP_FMAC4 soap_in_mtrep3__RepositoryIntegrity(struct soap *soap, const char *tag, enum mtrep3__RepositoryIntegrity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep3__RepositoryIntegrity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep3__RepositoryIntegrity, sizeof(enum mtrep3__RepositoryIntegrity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep3__RepositoryIntegrity(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep3__RepositoryIntegrity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep3__RepositoryIntegrity, SOAP_TYPE_mtrep3__RepositoryIntegrity, sizeof(enum mtrep3__RepositoryIntegrity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep3__RepositoryIntegrity(struct soap *soap, const enum mtrep3__RepositoryIntegrity *a, const char *tag, const char *type)
{
	if (soap_out_mtrep3__RepositoryIntegrity(soap, tag?tag:"mtrep3:RepositoryIntegrity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep3__RepositoryIntegrity * SOAP_FMAC4 soap_get_mtrep3__RepositoryIntegrity(struct soap *soap, enum mtrep3__RepositoryIntegrity *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep3__RepositoryIntegrity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep__RepositoryStatus(struct soap *soap, enum mtrep__RepositoryStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep__RepositoryStatus
	*a = SOAP_DEFAULT_mtrep__RepositoryStatus;
#else
	*a = (enum mtrep__RepositoryStatus)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep__RepositoryStatus[] =
{	{ (LONG64)mtrep__RepositoryStatus__Online, "Online" },
	{ (LONG64)mtrep__RepositoryStatus__Offline, "Offline" },
	{ (LONG64)mtrep__RepositoryStatus__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep__RepositoryStatus2s(struct soap *soap, enum mtrep__RepositoryStatus n)
{	const char *s = soap_code_str(soap_codes_mtrep__RepositoryStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep__RepositoryStatus(struct soap *soap, const char *tag, int id, const enum mtrep__RepositoryStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep__RepositoryStatus), type) || soap_send(soap, soap_mtrep__RepositoryStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep__RepositoryStatus(struct soap *soap, const char *s, enum mtrep__RepositoryStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep__RepositoryStatus, s);
	if (map)
		*a = (enum mtrep__RepositoryStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep__RepositoryStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep__RepositoryStatus * SOAP_FMAC4 soap_in_mtrep__RepositoryStatus(struct soap *soap, const char *tag, enum mtrep__RepositoryStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep__RepositoryStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep__RepositoryStatus, sizeof(enum mtrep__RepositoryStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep__RepositoryStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep__RepositoryStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep__RepositoryStatus, SOAP_TYPE_mtrep__RepositoryStatus, sizeof(enum mtrep__RepositoryStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep__RepositoryStatus(struct soap *soap, const enum mtrep__RepositoryStatus *a, const char *tag, const char *type)
{
	if (soap_out_mtrep__RepositoryStatus(soap, tag?tag:"mtrep:RepositoryStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep__RepositoryStatus * SOAP_FMAC4 soap_get_mtrep__RepositoryStatus(struct soap *soap, enum mtrep__RepositoryStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep__RepositoryStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep__PackageLevel(struct soap *soap, enum mtrep__PackageLevel *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep__PackageLevel
	*a = SOAP_DEFAULT_mtrep__PackageLevel;
#else
	*a = (enum mtrep__PackageLevel)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep__PackageLevel[] =
{	{ (LONG64)mtrep__PackageLevel__Essential, "Essential" },
	{ (LONG64)mtrep__PackageLevel__Basic, "Basic" },
	{ (LONG64)mtrep__PackageLevel__Advanced, "Advanced" },
	{ (LONG64)mtrep__PackageLevel__Complete, "Complete" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep__PackageLevel2s(struct soap *soap, enum mtrep__PackageLevel n)
{	const char *s = soap_code_str(soap_codes_mtrep__PackageLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep__PackageLevel(struct soap *soap, const char *tag, int id, const enum mtrep__PackageLevel *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep__PackageLevel), type) || soap_send(soap, soap_mtrep__PackageLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep__PackageLevel(struct soap *soap, const char *s, enum mtrep__PackageLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep__PackageLevel, s);
	if (map)
		*a = (enum mtrep__PackageLevel)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep__PackageLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep__PackageLevel * SOAP_FMAC4 soap_in_mtrep__PackageLevel(struct soap *soap, const char *tag, enum mtrep__PackageLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep__PackageLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep__PackageLevel, sizeof(enum mtrep__PackageLevel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep__PackageLevel(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep__PackageLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep__PackageLevel, SOAP_TYPE_mtrep__PackageLevel, sizeof(enum mtrep__PackageLevel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep__PackageLevel(struct soap *soap, const enum mtrep__PackageLevel *a, const char *tag, const char *type)
{
	if (soap_out_mtrep__PackageLevel(soap, tag?tag:"mtrep:PackageLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep__PackageLevel * SOAP_FMAC4 soap_get_mtrep__PackageLevel(struct soap *soap, enum mtrep__PackageLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep__PackageLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_mtrep__RepositoryIntegrity(struct soap *soap, enum mtrep__RepositoryIntegrity *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_mtrep__RepositoryIntegrity
	*a = SOAP_DEFAULT_mtrep__RepositoryIntegrity;
#else
	*a = (enum mtrep__RepositoryIntegrity)0;
#endif
}

static const struct soap_code_map soap_codes_mtrep__RepositoryIntegrity[] =
{	{ (LONG64)mtrep__RepositoryIntegrity__Intact, "Intact" },
	{ (LONG64)mtrep__RepositoryIntegrity__Corrupted, "Corrupted" },
	{ (LONG64)mtrep__RepositoryIntegrity__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_mtrep__RepositoryIntegrity2s(struct soap *soap, enum mtrep__RepositoryIntegrity n)
{	const char *s = soap_code_str(soap_codes_mtrep__RepositoryIntegrity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep__RepositoryIntegrity(struct soap *soap, const char *tag, int id, const enum mtrep__RepositoryIntegrity *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep__RepositoryIntegrity), type) || soap_send(soap, soap_mtrep__RepositoryIntegrity2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2mtrep__RepositoryIntegrity(struct soap *soap, const char *s, enum mtrep__RepositoryIntegrity *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_mtrep__RepositoryIntegrity, s);
	if (map)
		*a = (enum mtrep__RepositoryIntegrity)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum mtrep__RepositoryIntegrity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum mtrep__RepositoryIntegrity * SOAP_FMAC4 soap_in_mtrep__RepositoryIntegrity(struct soap *soap, const char *tag, enum mtrep__RepositoryIntegrity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum mtrep__RepositoryIntegrity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep__RepositoryIntegrity, sizeof(enum mtrep__RepositoryIntegrity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2mtrep__RepositoryIntegrity(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum mtrep__RepositoryIntegrity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep__RepositoryIntegrity, SOAP_TYPE_mtrep__RepositoryIntegrity, sizeof(enum mtrep__RepositoryIntegrity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_mtrep__RepositoryIntegrity(struct soap *soap, const enum mtrep__RepositoryIntegrity *a, const char *tag, const char *type)
{
	if (soap_out_mtrep__RepositoryIntegrity(soap, tag?tag:"mtrep:RepositoryIntegrity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum mtrep__RepositoryIntegrity * SOAP_FMAC4 soap_get_mtrep__RepositoryIntegrity(struct soap *soap, enum mtrep__RepositoryIntegrity *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep__RepositoryIntegrity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, repository_instantiate, repository_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, repository_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 repository_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_std__string(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	if (n < 0)
	{	p = SOAP_NEW(std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__string, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep7__TryGetRepositoryInfo3Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_mtrep7__TryGetRepositoryInfo3Response::TryGetRepositoryInfo3Result);
	this->_mtrep7__TryGetRepositoryInfo3Response::repositoryInfo = NULL;
	/* transient soap skipped */
}

void _mtrep7__TryGetRepositoryInfo3Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep7__RepositoryInfo3(soap, &this->_mtrep7__TryGetRepositoryInfo3Response::repositoryInfo);
#endif
}

int _mtrep7__TryGetRepositoryInfo3Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep7__TryGetRepositoryInfo3Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep7__TryGetRepositoryInfo3Response(struct soap *soap, const char *tag, int id, const _mtrep7__TryGetRepositoryInfo3Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response), type))
		return soap->error;
	soap_element_result(soap, "mtrep7:TryGetRepositoryInfo3Result");
	if (soap_out_bool(soap, "mtrep7:TryGetRepositoryInfo3Result", -1, &a->_mtrep7__TryGetRepositoryInfo3Response::TryGetRepositoryInfo3Result, ""))
		return soap->error;
	if (soap_out_PointerTomtrep7__RepositoryInfo3(soap, "mtrep7:repositoryInfo", -1, &a->_mtrep7__TryGetRepositoryInfo3Response::repositoryInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep7__TryGetRepositoryInfo3Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep7__TryGetRepositoryInfo3Response(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep7__TryGetRepositoryInfo3Response * SOAP_FMAC4 soap_in__mtrep7__TryGetRepositoryInfo3Response(struct soap *soap, const char *tag, _mtrep7__TryGetRepositoryInfo3Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep7__TryGetRepositoryInfo3Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response, sizeof(_mtrep7__TryGetRepositoryInfo3Response), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TryGetRepositoryInfo3Result1 = 1;
	size_t soap_flag_repositoryInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TryGetRepositoryInfo3Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep7:TryGetRepositoryInfo3Result", &a->_mtrep7__TryGetRepositoryInfo3Response::TryGetRepositoryInfo3Result, "xsd:boolean"))
				{	soap_flag_TryGetRepositoryInfo3Result1--;
					continue;
				}
			if (soap_flag_repositoryInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep7__RepositoryInfo3(soap, "mtrep7:repositoryInfo", &a->_mtrep7__TryGetRepositoryInfo3Response::repositoryInfo, "mtrep7:RepositoryInfo3"))
				{	soap_flag_repositoryInfo1--;
					continue;
				}
			soap_check_result(soap, "mtrep7:TryGetRepositoryInfo3Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TryGetRepositoryInfo3Result1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_mtrep7__TryGetRepositoryInfo3Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response, SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response, sizeof(_mtrep7__TryGetRepositoryInfo3Response), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep7__TryGetRepositoryInfo3Response * SOAP_FMAC2 repository_instantiate__mtrep7__TryGetRepositoryInfo3Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep7__TryGetRepositoryInfo3Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep7__TryGetRepositoryInfo3Response *p;
	size_t k = sizeof(_mtrep7__TryGetRepositoryInfo3Response);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep7__TryGetRepositoryInfo3Response);
		if (p)
			((_mtrep7__TryGetRepositoryInfo3Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep7__TryGetRepositoryInfo3Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep7__TryGetRepositoryInfo3Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep7__TryGetRepositoryInfo3Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep7__TryGetRepositoryInfo3Response, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep7__TryGetRepositoryInfo3Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep7:TryGetRepositoryInfo3Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep7__TryGetRepositoryInfo3Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep7__TryGetRepositoryInfo3Response(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep7__TryGetRepositoryInfo3Response * SOAP_FMAC4 soap_get__mtrep7__TryGetRepositoryInfo3Response(struct soap *soap, _mtrep7__TryGetRepositoryInfo3Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep7__TryGetRepositoryInfo3Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep7__TryGetRepositoryInfo3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep7__TryGetRepositoryInfo3::clientInfo = NULL;
	this->_mtrep7__TryGetRepositoryInfo3::url = NULL;
	/* transient soap skipped */
}

void _mtrep7__TryGetRepositoryInfo3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep7__ClientInfo(soap, &this->_mtrep7__TryGetRepositoryInfo3::clientInfo);
	soap_serialize_PointerTostd__string(soap, &this->_mtrep7__TryGetRepositoryInfo3::url);
#endif
}

int _mtrep7__TryGetRepositoryInfo3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep7__TryGetRepositoryInfo3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep7__TryGetRepositoryInfo3(struct soap *soap, const char *tag, int id, const _mtrep7__TryGetRepositoryInfo3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep7__TryGetRepositoryInfo3), type))
		return soap->error;
	if (soap_out_PointerTomtrep7__ClientInfo(soap, "mtrep7:clientInfo", -1, &a->_mtrep7__TryGetRepositoryInfo3::clientInfo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:url", -1, &a->_mtrep7__TryGetRepositoryInfo3::url, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep7__TryGetRepositoryInfo3::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep7__TryGetRepositoryInfo3(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep7__TryGetRepositoryInfo3 * SOAP_FMAC4 soap_in__mtrep7__TryGetRepositoryInfo3(struct soap *soap, const char *tag, _mtrep7__TryGetRepositoryInfo3 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep7__TryGetRepositoryInfo3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep7__TryGetRepositoryInfo3, sizeof(_mtrep7__TryGetRepositoryInfo3), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_clientInfo1 = 1;
	size_t soap_flag_url1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep7__ClientInfo(soap, "mtrep7:clientInfo", &a->_mtrep7__TryGetRepositoryInfo3::clientInfo, "mtrep7:ClientInfo"))
				{	soap_flag_clientInfo1--;
					continue;
				}
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:url", &a->_mtrep7__TryGetRepositoryInfo3::url, "xsd:string"))
				{	soap_flag_url1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep7__TryGetRepositoryInfo3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep7__TryGetRepositoryInfo3, SOAP_TYPE__mtrep7__TryGetRepositoryInfo3, sizeof(_mtrep7__TryGetRepositoryInfo3), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep7__TryGetRepositoryInfo3 * SOAP_FMAC2 repository_instantiate__mtrep7__TryGetRepositoryInfo3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep7__TryGetRepositoryInfo3(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep7__TryGetRepositoryInfo3 *p;
	size_t k = sizeof(_mtrep7__TryGetRepositoryInfo3);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep7__TryGetRepositoryInfo3);
		if (p)
			((_mtrep7__TryGetRepositoryInfo3*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep7__TryGetRepositoryInfo3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep7__TryGetRepositoryInfo3*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep7__TryGetRepositoryInfo3 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep7__TryGetRepositoryInfo3, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep7__TryGetRepositoryInfo3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep7:TryGetRepositoryInfo3", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep7__TryGetRepositoryInfo3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep7__TryGetRepositoryInfo3(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep7__TryGetRepositoryInfo3 * SOAP_FMAC4 soap_get__mtrep7__TryGetRepositoryInfo3(struct soap *soap, _mtrep7__TryGetRepositoryInfo3 *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep7__TryGetRepositoryInfo3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep7__VerifyRepository2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_mtrep7__VerifyRepository2Response::VerifyRepository2Result);
	this->_mtrep7__VerifyRepository2Response::repositoryInfo = NULL;
	/* transient soap skipped */
}

void _mtrep7__VerifyRepository2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep7__RepositoryInfo3(soap, &this->_mtrep7__VerifyRepository2Response::repositoryInfo);
#endif
}

int _mtrep7__VerifyRepository2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep7__VerifyRepository2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep7__VerifyRepository2Response(struct soap *soap, const char *tag, int id, const _mtrep7__VerifyRepository2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep7__VerifyRepository2Response), type))
		return soap->error;
	soap_element_result(soap, "mtrep7:VerifyRepository2Result");
	if (soap_out_bool(soap, "mtrep7:VerifyRepository2Result", -1, &a->_mtrep7__VerifyRepository2Response::VerifyRepository2Result, ""))
		return soap->error;
	if (soap_out_PointerTomtrep7__RepositoryInfo3(soap, "mtrep7:repositoryInfo", -1, &a->_mtrep7__VerifyRepository2Response::repositoryInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep7__VerifyRepository2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep7__VerifyRepository2Response(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep7__VerifyRepository2Response * SOAP_FMAC4 soap_in__mtrep7__VerifyRepository2Response(struct soap *soap, const char *tag, _mtrep7__VerifyRepository2Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep7__VerifyRepository2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep7__VerifyRepository2Response, sizeof(_mtrep7__VerifyRepository2Response), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_VerifyRepository2Result1 = 1;
	size_t soap_flag_repositoryInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VerifyRepository2Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep7:VerifyRepository2Result", &a->_mtrep7__VerifyRepository2Response::VerifyRepository2Result, "xsd:boolean"))
				{	soap_flag_VerifyRepository2Result1--;
					continue;
				}
			if (soap_flag_repositoryInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep7__RepositoryInfo3(soap, "mtrep7:repositoryInfo", &a->_mtrep7__VerifyRepository2Response::repositoryInfo, "mtrep7:RepositoryInfo3"))
				{	soap_flag_repositoryInfo1--;
					continue;
				}
			soap_check_result(soap, "mtrep7:VerifyRepository2Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VerifyRepository2Result1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_mtrep7__VerifyRepository2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep7__VerifyRepository2Response, SOAP_TYPE__mtrep7__VerifyRepository2Response, sizeof(_mtrep7__VerifyRepository2Response), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep7__VerifyRepository2Response * SOAP_FMAC2 repository_instantiate__mtrep7__VerifyRepository2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep7__VerifyRepository2Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep7__VerifyRepository2Response *p;
	size_t k = sizeof(_mtrep7__VerifyRepository2Response);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep7__VerifyRepository2Response);
		if (p)
			((_mtrep7__VerifyRepository2Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep7__VerifyRepository2Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep7__VerifyRepository2Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep7__VerifyRepository2Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep7__VerifyRepository2Response, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep7__VerifyRepository2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep7:VerifyRepository2Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep7__VerifyRepository2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep7__VerifyRepository2Response(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep7__VerifyRepository2Response * SOAP_FMAC4 soap_get__mtrep7__VerifyRepository2Response(struct soap *soap, _mtrep7__VerifyRepository2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep7__VerifyRepository2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep7__VerifyRepository2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep7__VerifyRepository2::clientInfo = NULL;
	this->_mtrep7__VerifyRepository2::url = NULL;
	/* transient soap skipped */
}

void _mtrep7__VerifyRepository2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep7__ClientInfo(soap, &this->_mtrep7__VerifyRepository2::clientInfo);
	soap_serialize_PointerTostd__string(soap, &this->_mtrep7__VerifyRepository2::url);
#endif
}

int _mtrep7__VerifyRepository2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep7__VerifyRepository2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep7__VerifyRepository2(struct soap *soap, const char *tag, int id, const _mtrep7__VerifyRepository2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep7__VerifyRepository2), type))
		return soap->error;
	if (soap_out_PointerTomtrep7__ClientInfo(soap, "mtrep7:clientInfo", -1, &a->_mtrep7__VerifyRepository2::clientInfo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:url", -1, &a->_mtrep7__VerifyRepository2::url, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep7__VerifyRepository2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep7__VerifyRepository2(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep7__VerifyRepository2 * SOAP_FMAC4 soap_in__mtrep7__VerifyRepository2(struct soap *soap, const char *tag, _mtrep7__VerifyRepository2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep7__VerifyRepository2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep7__VerifyRepository2, sizeof(_mtrep7__VerifyRepository2), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_clientInfo1 = 1;
	size_t soap_flag_url1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep7__ClientInfo(soap, "mtrep7:clientInfo", &a->_mtrep7__VerifyRepository2::clientInfo, "mtrep7:ClientInfo"))
				{	soap_flag_clientInfo1--;
					continue;
				}
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:url", &a->_mtrep7__VerifyRepository2::url, "xsd:string"))
				{	soap_flag_url1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep7__VerifyRepository2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep7__VerifyRepository2, SOAP_TYPE__mtrep7__VerifyRepository2, sizeof(_mtrep7__VerifyRepository2), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep7__VerifyRepository2 * SOAP_FMAC2 repository_instantiate__mtrep7__VerifyRepository2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep7__VerifyRepository2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep7__VerifyRepository2 *p;
	size_t k = sizeof(_mtrep7__VerifyRepository2);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep7__VerifyRepository2);
		if (p)
			((_mtrep7__VerifyRepository2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep7__VerifyRepository2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep7__VerifyRepository2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep7__VerifyRepository2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep7__VerifyRepository2, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep7__VerifyRepository2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep7:VerifyRepository2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep7__VerifyRepository2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep7__VerifyRepository2(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep7__VerifyRepository2 * SOAP_FMAC4 soap_get__mtrep7__VerifyRepository2(struct soap *soap, _mtrep7__VerifyRepository2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep7__VerifyRepository2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep7__RepositoryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep7__RepositoryInfo::Country = NULL;
	soap_default_int(soap, &this->mtrep7__RepositoryInfo::Date);
	soap_default_int(soap, &this->mtrep7__RepositoryInfo::Delay);
	this->mtrep7__RepositoryInfo::Description = NULL;
	soap_default_mtrep7__RepositoryIntegrity(soap, &this->mtrep7__RepositoryInfo::Integrity);
	soap_default_mtrep7__PackageLevel(soap, &this->mtrep7__RepositoryInfo::Level);
	soap_default_mtrep7__RepositoryStatus(soap, &this->mtrep7__RepositoryInfo::Status);
	this->mtrep7__RepositoryInfo::Url = NULL;
	soap_default_int(soap, &this->mtrep7__RepositoryInfo::Version);
	/* transient soap skipped */
}

void mtrep7__RepositoryInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep7__RepositoryInfo::Country);
	soap_serialize_PointerTostd__string(soap, &this->mtrep7__RepositoryInfo::Description);
	soap_serialize_PointerTostd__string(soap, &this->mtrep7__RepositoryInfo::Url);
#endif
}

int mtrep7__RepositoryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep7__RepositoryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep7__RepositoryInfo(struct soap *soap, const char *tag, int id, const mtrep7__RepositoryInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep7__RepositoryInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:Country", -1, &a->mtrep7__RepositoryInfo::Country, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep7:Date", -1, &a->mtrep7__RepositoryInfo::Date, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep7:Delay", -1, &a->mtrep7__RepositoryInfo::Delay, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:Description", -1, &a->mtrep7__RepositoryInfo::Description, ""))
		return soap->error;
	if (soap_out_mtrep7__RepositoryIntegrity(soap, "mtrep7:Integrity", -1, &a->mtrep7__RepositoryInfo::Integrity, ""))
		return soap->error;
	if (soap_out_mtrep7__PackageLevel(soap, "mtrep7:Level", -1, &a->mtrep7__RepositoryInfo::Level, ""))
		return soap->error;
	if (soap_out_mtrep7__RepositoryStatus(soap, "mtrep7:Status", -1, &a->mtrep7__RepositoryInfo::Status, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:Url", -1, &a->mtrep7__RepositoryInfo::Url, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep7:Version", -1, &a->mtrep7__RepositoryInfo::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep7__RepositoryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep7__RepositoryInfo(soap, tag, this, type);
}

SOAP_FMAC3 mtrep7__RepositoryInfo * SOAP_FMAC4 soap_in_mtrep7__RepositoryInfo(struct soap *soap, const char *tag, mtrep7__RepositoryInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep7__RepositoryInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep7__RepositoryInfo, sizeof(mtrep7__RepositoryInfo), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Country1 = 1;
	size_t soap_flag_Date1 = 1;
	size_t soap_flag_Delay1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_Integrity1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_Url1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:Country", &a->mtrep7__RepositoryInfo::Country, "xsd:string"))
				{	soap_flag_Country1--;
					continue;
				}
			if (soap_flag_Date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep7:Date", &a->mtrep7__RepositoryInfo::Date, "xsd:int"))
				{	soap_flag_Date1--;
					continue;
				}
			if (soap_flag_Delay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep7:Delay", &a->mtrep7__RepositoryInfo::Delay, "xsd:int"))
				{	soap_flag_Delay1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:Description", &a->mtrep7__RepositoryInfo::Description, "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_Integrity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep7__RepositoryIntegrity(soap, "mtrep7:Integrity", &a->mtrep7__RepositoryInfo::Integrity, "mtrep7:RepositoryIntegrity"))
				{	soap_flag_Integrity1--;
					continue;
				}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep7__PackageLevel(soap, "mtrep7:Level", &a->mtrep7__RepositoryInfo::Level, "mtrep7:PackageLevel"))
				{	soap_flag_Level1--;
					continue;
				}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep7__RepositoryStatus(soap, "mtrep7:Status", &a->mtrep7__RepositoryInfo::Status, "mtrep7:RepositoryStatus"))
				{	soap_flag_Status1--;
					continue;
				}
			if (soap_flag_Url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:Url", &a->mtrep7__RepositoryInfo::Url, "xsd:string"))
				{	soap_flag_Url1--;
					continue;
				}
			if (soap_flag_Version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep7:Version", &a->mtrep7__RepositoryInfo::Version, "xsd:int"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Date1 > 0 || soap_flag_Delay1 > 0 || soap_flag_Integrity1 > 0 || soap_flag_Level1 > 0 || soap_flag_Status1 > 0 || soap_flag_Version1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (mtrep7__RepositoryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep7__RepositoryInfo, SOAP_TYPE_mtrep7__RepositoryInfo, sizeof(mtrep7__RepositoryInfo), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep7__RepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep7__RepositoryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep7__RepositoryInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "mtrep7:RepositoryInfo2"))
		return repository_instantiate_mtrep7__RepositoryInfo2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "mtrep7:RepositoryInfo3"))
		return repository_instantiate_mtrep7__RepositoryInfo3(soap, n, NULL, NULL, size);
	mtrep7__RepositoryInfo *p;
	size_t k = sizeof(mtrep7__RepositoryInfo);
	if (n < 0)
	{	p = SOAP_NEW(mtrep7__RepositoryInfo);
		if (p)
			((mtrep7__RepositoryInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep7__RepositoryInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep7__RepositoryInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep7__RepositoryInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep7__RepositoryInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep7__RepositoryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep7:RepositoryInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep7__RepositoryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep7__RepositoryInfo(soap, this, tag, type);
}

SOAP_FMAC3 mtrep7__RepositoryInfo * SOAP_FMAC4 soap_get_mtrep7__RepositoryInfo(struct soap *soap, mtrep7__RepositoryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep7__RepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep7__RepositoryInfo2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep7__RepositoryInfo::soap_default(soap);
	this->mtrep7__RepositoryInfo2::CountryCode = NULL;
	this->mtrep7__RepositoryInfo2::City = NULL;
	soap_default_double(soap, &this->mtrep7__RepositoryInfo2::Latitude);
	soap_default_double(soap, &this->mtrep7__RepositoryInfo2::Longitude);
}

void mtrep7__RepositoryInfo2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep7__RepositoryInfo2::CountryCode);
	soap_serialize_PointerTostd__string(soap, &this->mtrep7__RepositoryInfo2::City);
	this->mtrep7__RepositoryInfo::soap_serialize(soap);
#endif
}

int mtrep7__RepositoryInfo2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep7__RepositoryInfo2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep7__RepositoryInfo2(struct soap *soap, const char *tag, int id, const mtrep7__RepositoryInfo2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep7__RepositoryInfo2), "mtrep7:RepositoryInfo2"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:Country", -1, &a->mtrep7__RepositoryInfo::Country, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep7:Date", -1, &a->mtrep7__RepositoryInfo::Date, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep7:Delay", -1, &a->mtrep7__RepositoryInfo::Delay, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:Description", -1, &a->mtrep7__RepositoryInfo::Description, ""))
		return soap->error;
	if (soap_out_mtrep7__RepositoryIntegrity(soap, "mtrep7:Integrity", -1, &a->mtrep7__RepositoryInfo::Integrity, ""))
		return soap->error;
	if (soap_out_mtrep7__PackageLevel(soap, "mtrep7:Level", -1, &a->mtrep7__RepositoryInfo::Level, ""))
		return soap->error;
	if (soap_out_mtrep7__RepositoryStatus(soap, "mtrep7:Status", -1, &a->mtrep7__RepositoryInfo::Status, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:Url", -1, &a->mtrep7__RepositoryInfo::Url, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep7:Version", -1, &a->mtrep7__RepositoryInfo::Version, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:CountryCode", -1, &a->mtrep7__RepositoryInfo2::CountryCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:City", -1, &a->mtrep7__RepositoryInfo2::City, ""))
		return soap->error;
	if (soap_out_double(soap, "mtrep7:Latitude", -1, &a->mtrep7__RepositoryInfo2::Latitude, ""))
		return soap->error;
	if (soap_out_double(soap, "mtrep7:Longitude", -1, &a->mtrep7__RepositoryInfo2::Longitude, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep7__RepositoryInfo2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep7__RepositoryInfo2(soap, tag, this, type);
}

SOAP_FMAC3 mtrep7__RepositoryInfo2 * SOAP_FMAC4 soap_in_mtrep7__RepositoryInfo2(struct soap *soap, const char *tag, mtrep7__RepositoryInfo2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep7__RepositoryInfo2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep7__RepositoryInfo2, sizeof(mtrep7__RepositoryInfo2), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_mtrep7__RepositoryInfo2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (mtrep7__RepositoryInfo2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Country2 = 1;
	size_t soap_flag_Date2 = 1;
	size_t soap_flag_Delay2 = 1;
	size_t soap_flag_Description2 = 1;
	size_t soap_flag_Integrity2 = 1;
	size_t soap_flag_Level2 = 1;
	size_t soap_flag_Status2 = 1;
	size_t soap_flag_Url2 = 1;
	size_t soap_flag_Version2 = 1;
	size_t soap_flag_CountryCode1 = 1;
	size_t soap_flag_City1 = 1;
	size_t soap_flag_Latitude1 = 1;
	size_t soap_flag_Longitude1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Country2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:Country", &a->mtrep7__RepositoryInfo::Country, "xsd:string"))
				{	soap_flag_Country2--;
					continue;
				}
			if (soap_flag_Date2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep7:Date", &a->mtrep7__RepositoryInfo::Date, "xsd:int"))
				{	soap_flag_Date2--;
					continue;
				}
			if (soap_flag_Delay2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep7:Delay", &a->mtrep7__RepositoryInfo::Delay, "xsd:int"))
				{	soap_flag_Delay2--;
					continue;
				}
			if (soap_flag_Description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:Description", &a->mtrep7__RepositoryInfo::Description, "xsd:string"))
				{	soap_flag_Description2--;
					continue;
				}
			if (soap_flag_Integrity2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep7__RepositoryIntegrity(soap, "mtrep7:Integrity", &a->mtrep7__RepositoryInfo::Integrity, "mtrep7:RepositoryIntegrity"))
				{	soap_flag_Integrity2--;
					continue;
				}
			if (soap_flag_Level2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep7__PackageLevel(soap, "mtrep7:Level", &a->mtrep7__RepositoryInfo::Level, "mtrep7:PackageLevel"))
				{	soap_flag_Level2--;
					continue;
				}
			if (soap_flag_Status2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep7__RepositoryStatus(soap, "mtrep7:Status", &a->mtrep7__RepositoryInfo::Status, "mtrep7:RepositoryStatus"))
				{	soap_flag_Status2--;
					continue;
				}
			if (soap_flag_Url2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:Url", &a->mtrep7__RepositoryInfo::Url, "xsd:string"))
				{	soap_flag_Url2--;
					continue;
				}
			if (soap_flag_Version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep7:Version", &a->mtrep7__RepositoryInfo::Version, "xsd:int"))
				{	soap_flag_Version2--;
					continue;
				}
			if (soap_flag_CountryCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:CountryCode", &a->mtrep7__RepositoryInfo2::CountryCode, "xsd:string"))
				{	soap_flag_CountryCode1--;
					continue;
				}
			if (soap_flag_City1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:City", &a->mtrep7__RepositoryInfo2::City, "xsd:string"))
				{	soap_flag_City1--;
					continue;
				}
			if (soap_flag_Latitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "mtrep7:Latitude", &a->mtrep7__RepositoryInfo2::Latitude, "xsd:double"))
				{	soap_flag_Latitude1--;
					continue;
				}
			if (soap_flag_Longitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "mtrep7:Longitude", &a->mtrep7__RepositoryInfo2::Longitude, "xsd:double"))
				{	soap_flag_Longitude1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Date2 > 0 || soap_flag_Delay2 > 0 || soap_flag_Integrity2 > 0 || soap_flag_Level2 > 0 || soap_flag_Status2 > 0 || soap_flag_Version2 > 0 || soap_flag_Latitude1 > 0 || soap_flag_Longitude1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (mtrep7__RepositoryInfo2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep7__RepositoryInfo2, SOAP_TYPE_mtrep7__RepositoryInfo2, sizeof(mtrep7__RepositoryInfo2), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep7__RepositoryInfo2 * SOAP_FMAC2 repository_instantiate_mtrep7__RepositoryInfo2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep7__RepositoryInfo2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "mtrep7:RepositoryInfo3"))
		return repository_instantiate_mtrep7__RepositoryInfo3(soap, n, NULL, NULL, size);
	mtrep7__RepositoryInfo2 *p;
	size_t k = sizeof(mtrep7__RepositoryInfo2);
	if (n < 0)
	{	p = SOAP_NEW(mtrep7__RepositoryInfo2);
		if (p)
			((mtrep7__RepositoryInfo2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep7__RepositoryInfo2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep7__RepositoryInfo2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep7__RepositoryInfo2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep7__RepositoryInfo2, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep7__RepositoryInfo2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep7:RepositoryInfo2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep7__RepositoryInfo2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep7__RepositoryInfo2(soap, this, tag, type);
}

SOAP_FMAC3 mtrep7__RepositoryInfo2 * SOAP_FMAC4 soap_get_mtrep7__RepositoryInfo2(struct soap *soap, mtrep7__RepositoryInfo2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep7__RepositoryInfo2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep7__RepositoryInfo3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep7__RepositoryInfo2::soap_default(soap);
	this->mtrep7__RepositoryInfo3::Attributes = NULL;
	soap_default_mtrep7__RepositoryReleaseState(soap, &this->mtrep7__RepositoryInfo3::ReleaseState);
}

void mtrep7__RepositoryInfo3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep7__RepositoryInfo3::Attributes);
	this->mtrep7__RepositoryInfo2::soap_serialize(soap);
#endif
}

int mtrep7__RepositoryInfo3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep7__RepositoryInfo3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep7__RepositoryInfo3(struct soap *soap, const char *tag, int id, const mtrep7__RepositoryInfo3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep7__RepositoryInfo3), "mtrep7:RepositoryInfo3"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:Country", -1, &a->mtrep7__RepositoryInfo::Country, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep7:Date", -1, &a->mtrep7__RepositoryInfo::Date, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep7:Delay", -1, &a->mtrep7__RepositoryInfo::Delay, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:Description", -1, &a->mtrep7__RepositoryInfo::Description, ""))
		return soap->error;
	if (soap_out_mtrep7__RepositoryIntegrity(soap, "mtrep7:Integrity", -1, &a->mtrep7__RepositoryInfo::Integrity, ""))
		return soap->error;
	if (soap_out_mtrep7__PackageLevel(soap, "mtrep7:Level", -1, &a->mtrep7__RepositoryInfo::Level, ""))
		return soap->error;
	if (soap_out_mtrep7__RepositoryStatus(soap, "mtrep7:Status", -1, &a->mtrep7__RepositoryInfo::Status, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:Url", -1, &a->mtrep7__RepositoryInfo::Url, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep7:Version", -1, &a->mtrep7__RepositoryInfo::Version, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:CountryCode", -1, &a->mtrep7__RepositoryInfo2::CountryCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:City", -1, &a->mtrep7__RepositoryInfo2::City, ""))
		return soap->error;
	if (soap_out_double(soap, "mtrep7:Latitude", -1, &a->mtrep7__RepositoryInfo2::Latitude, ""))
		return soap->error;
	if (soap_out_double(soap, "mtrep7:Longitude", -1, &a->mtrep7__RepositoryInfo2::Longitude, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:Attributes", -1, &a->mtrep7__RepositoryInfo3::Attributes, ""))
		return soap->error;
	if (soap_out_mtrep7__RepositoryReleaseState(soap, "mtrep7:ReleaseState", -1, &a->mtrep7__RepositoryInfo3::ReleaseState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep7__RepositoryInfo3::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep7__RepositoryInfo3(soap, tag, this, type);
}

SOAP_FMAC3 mtrep7__RepositoryInfo3 * SOAP_FMAC4 soap_in_mtrep7__RepositoryInfo3(struct soap *soap, const char *tag, mtrep7__RepositoryInfo3 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep7__RepositoryInfo3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep7__RepositoryInfo3, sizeof(mtrep7__RepositoryInfo3), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_mtrep7__RepositoryInfo3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (mtrep7__RepositoryInfo3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Country3 = 1;
	size_t soap_flag_Date3 = 1;
	size_t soap_flag_Delay3 = 1;
	size_t soap_flag_Description3 = 1;
	size_t soap_flag_Integrity3 = 1;
	size_t soap_flag_Level3 = 1;
	size_t soap_flag_Status3 = 1;
	size_t soap_flag_Url3 = 1;
	size_t soap_flag_Version3 = 1;
	size_t soap_flag_CountryCode2 = 1;
	size_t soap_flag_City2 = 1;
	size_t soap_flag_Latitude2 = 1;
	size_t soap_flag_Longitude2 = 1;
	size_t soap_flag_Attributes1 = 1;
	size_t soap_flag_ReleaseState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Country3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:Country", &a->mtrep7__RepositoryInfo::Country, "xsd:string"))
				{	soap_flag_Country3--;
					continue;
				}
			if (soap_flag_Date3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep7:Date", &a->mtrep7__RepositoryInfo::Date, "xsd:int"))
				{	soap_flag_Date3--;
					continue;
				}
			if (soap_flag_Delay3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep7:Delay", &a->mtrep7__RepositoryInfo::Delay, "xsd:int"))
				{	soap_flag_Delay3--;
					continue;
				}
			if (soap_flag_Description3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:Description", &a->mtrep7__RepositoryInfo::Description, "xsd:string"))
				{	soap_flag_Description3--;
					continue;
				}
			if (soap_flag_Integrity3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep7__RepositoryIntegrity(soap, "mtrep7:Integrity", &a->mtrep7__RepositoryInfo::Integrity, "mtrep7:RepositoryIntegrity"))
				{	soap_flag_Integrity3--;
					continue;
				}
			if (soap_flag_Level3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep7__PackageLevel(soap, "mtrep7:Level", &a->mtrep7__RepositoryInfo::Level, "mtrep7:PackageLevel"))
				{	soap_flag_Level3--;
					continue;
				}
			if (soap_flag_Status3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep7__RepositoryStatus(soap, "mtrep7:Status", &a->mtrep7__RepositoryInfo::Status, "mtrep7:RepositoryStatus"))
				{	soap_flag_Status3--;
					continue;
				}
			if (soap_flag_Url3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:Url", &a->mtrep7__RepositoryInfo::Url, "xsd:string"))
				{	soap_flag_Url3--;
					continue;
				}
			if (soap_flag_Version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep7:Version", &a->mtrep7__RepositoryInfo::Version, "xsd:int"))
				{	soap_flag_Version3--;
					continue;
				}
			if (soap_flag_CountryCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:CountryCode", &a->mtrep7__RepositoryInfo2::CountryCode, "xsd:string"))
				{	soap_flag_CountryCode2--;
					continue;
				}
			if (soap_flag_City2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:City", &a->mtrep7__RepositoryInfo2::City, "xsd:string"))
				{	soap_flag_City2--;
					continue;
				}
			if (soap_flag_Latitude2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "mtrep7:Latitude", &a->mtrep7__RepositoryInfo2::Latitude, "xsd:double"))
				{	soap_flag_Latitude2--;
					continue;
				}
			if (soap_flag_Longitude2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "mtrep7:Longitude", &a->mtrep7__RepositoryInfo2::Longitude, "xsd:double"))
				{	soap_flag_Longitude2--;
					continue;
				}
			if (soap_flag_Attributes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:Attributes", &a->mtrep7__RepositoryInfo3::Attributes, "xsd:string"))
				{	soap_flag_Attributes1--;
					continue;
				}
			if (soap_flag_ReleaseState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep7__RepositoryReleaseState(soap, "mtrep7:ReleaseState", &a->mtrep7__RepositoryInfo3::ReleaseState, "mtrep7:RepositoryReleaseState"))
				{	soap_flag_ReleaseState1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Date3 > 0 || soap_flag_Delay3 > 0 || soap_flag_Integrity3 > 0 || soap_flag_Level3 > 0 || soap_flag_Status3 > 0 || soap_flag_Version3 > 0 || soap_flag_Latitude2 > 0 || soap_flag_Longitude2 > 0 || soap_flag_ReleaseState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (mtrep7__RepositoryInfo3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep7__RepositoryInfo3, SOAP_TYPE_mtrep7__RepositoryInfo3, sizeof(mtrep7__RepositoryInfo3), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep7__RepositoryInfo3 * SOAP_FMAC2 repository_instantiate_mtrep7__RepositoryInfo3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep7__RepositoryInfo3(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep7__RepositoryInfo3 *p;
	size_t k = sizeof(mtrep7__RepositoryInfo3);
	if (n < 0)
	{	p = SOAP_NEW(mtrep7__RepositoryInfo3);
		if (p)
			((mtrep7__RepositoryInfo3*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep7__RepositoryInfo3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep7__RepositoryInfo3*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep7__RepositoryInfo3 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep7__RepositoryInfo3, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep7__RepositoryInfo3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep7:RepositoryInfo3", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep7__RepositoryInfo3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep7__RepositoryInfo3(soap, this, tag, type);
}

SOAP_FMAC3 mtrep7__RepositoryInfo3 * SOAP_FMAC4 soap_get_mtrep7__RepositoryInfo3(struct soap *soap, mtrep7__RepositoryInfo3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep7__RepositoryInfo3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep7__ClientInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep7__ClientInfo::Name = NULL;
	this->mtrep7__ClientInfo::Version = NULL;
	/* transient soap skipped */
}

void mtrep7__ClientInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep7__ClientInfo::Name);
	soap_serialize_PointerTostd__string(soap, &this->mtrep7__ClientInfo::Version);
#endif
}

int mtrep7__ClientInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep7__ClientInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep7__ClientInfo(struct soap *soap, const char *tag, int id, const mtrep7__ClientInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep7__ClientInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:Name", -1, &a->mtrep7__ClientInfo::Name, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep7:Version", -1, &a->mtrep7__ClientInfo::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep7__ClientInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep7__ClientInfo(soap, tag, this, type);
}

SOAP_FMAC3 mtrep7__ClientInfo * SOAP_FMAC4 soap_in_mtrep7__ClientInfo(struct soap *soap, const char *tag, mtrep7__ClientInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep7__ClientInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep7__ClientInfo, sizeof(mtrep7__ClientInfo), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:Name", &a->mtrep7__ClientInfo::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep7:Version", &a->mtrep7__ClientInfo::Version, "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mtrep7__ClientInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep7__ClientInfo, SOAP_TYPE_mtrep7__ClientInfo, sizeof(mtrep7__ClientInfo), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep7__ClientInfo * SOAP_FMAC2 repository_instantiate_mtrep7__ClientInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep7__ClientInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep7__ClientInfo *p;
	size_t k = sizeof(mtrep7__ClientInfo);
	if (n < 0)
	{	p = SOAP_NEW(mtrep7__ClientInfo);
		if (p)
			((mtrep7__ClientInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep7__ClientInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep7__ClientInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep7__ClientInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep7__ClientInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep7__ClientInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep7:ClientInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep7__ClientInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep7__ClientInfo(soap, this, tag, type);
}

SOAP_FMAC3 mtrep7__ClientInfo * SOAP_FMAC4 soap_get_mtrep7__ClientInfo(struct soap *soap, mtrep7__ClientInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep7__ClientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep6__PickRepository4Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep6__PickRepository4Response::PickRepository4Result = NULL;
	/* transient soap skipped */
}

void _mtrep6__PickRepository4Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep6__RepositoryInfo3(soap, &this->_mtrep6__PickRepository4Response::PickRepository4Result);
#endif
}

int _mtrep6__PickRepository4Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep6__PickRepository4Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep6__PickRepository4Response(struct soap *soap, const char *tag, int id, const _mtrep6__PickRepository4Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep6__PickRepository4Response), type))
		return soap->error;
	if (a->PickRepository4Result)
		soap_element_result(soap, "mtrep6:PickRepository4Result");
	if (soap_out_PointerTomtrep6__RepositoryInfo3(soap, "mtrep6:PickRepository4Result", -1, &a->_mtrep6__PickRepository4Response::PickRepository4Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep6__PickRepository4Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep6__PickRepository4Response(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep6__PickRepository4Response * SOAP_FMAC4 soap_in__mtrep6__PickRepository4Response(struct soap *soap, const char *tag, _mtrep6__PickRepository4Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep6__PickRepository4Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep6__PickRepository4Response, sizeof(_mtrep6__PickRepository4Response), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PickRepository4Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PickRepository4Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep6__RepositoryInfo3(soap, "mtrep6:PickRepository4Result", &a->_mtrep6__PickRepository4Response::PickRepository4Result, "mtrep6:RepositoryInfo3"))
				{	soap_flag_PickRepository4Result1--;
					continue;
				}
			soap_check_result(soap, "mtrep6:PickRepository4Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep6__PickRepository4Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep6__PickRepository4Response, SOAP_TYPE__mtrep6__PickRepository4Response, sizeof(_mtrep6__PickRepository4Response), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep6__PickRepository4Response * SOAP_FMAC2 repository_instantiate__mtrep6__PickRepository4Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep6__PickRepository4Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep6__PickRepository4Response *p;
	size_t k = sizeof(_mtrep6__PickRepository4Response);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep6__PickRepository4Response);
		if (p)
			((_mtrep6__PickRepository4Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep6__PickRepository4Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep6__PickRepository4Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep6__PickRepository4Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep6__PickRepository4Response, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep6__PickRepository4Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep6:PickRepository4Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep6__PickRepository4Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep6__PickRepository4Response(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep6__PickRepository4Response * SOAP_FMAC4 soap_get__mtrep6__PickRepository4Response(struct soap *soap, _mtrep6__PickRepository4Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep6__PickRepository4Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep6__PickRepository4::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep6__PickRepository4::clientInfo = NULL;
	soap_default_bool(soap, &this->_mtrep6__PickRepository4::favorHttp);
	soap_default_bool(soap, &this->_mtrep6__PickRepository4::nearest);
	soap_default_mtrep6__RepositoryReleaseState(soap, &this->_mtrep6__PickRepository4::releaseState);
	/* transient soap skipped */
}

void _mtrep6__PickRepository4::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep6__ClientInfo(soap, &this->_mtrep6__PickRepository4::clientInfo);
#endif
}

int _mtrep6__PickRepository4::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep6__PickRepository4(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep6__PickRepository4(struct soap *soap, const char *tag, int id, const _mtrep6__PickRepository4 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep6__PickRepository4), type))
		return soap->error;
	if (soap_out_PointerTomtrep6__ClientInfo(soap, "mtrep6:clientInfo", -1, &a->_mtrep6__PickRepository4::clientInfo, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep6:favorHttp", -1, &a->_mtrep6__PickRepository4::favorHttp, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep6:nearest", -1, &a->_mtrep6__PickRepository4::nearest, ""))
		return soap->error;
	if (soap_out_mtrep6__RepositoryReleaseState(soap, "mtrep6:releaseState", -1, &a->_mtrep6__PickRepository4::releaseState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep6__PickRepository4::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep6__PickRepository4(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep6__PickRepository4 * SOAP_FMAC4 soap_in__mtrep6__PickRepository4(struct soap *soap, const char *tag, _mtrep6__PickRepository4 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep6__PickRepository4 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep6__PickRepository4, sizeof(_mtrep6__PickRepository4), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_clientInfo1 = 1;
	size_t soap_flag_favorHttp1 = 1;
	size_t soap_flag_nearest1 = 1;
	size_t soap_flag_releaseState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep6__ClientInfo(soap, "mtrep6:clientInfo", &a->_mtrep6__PickRepository4::clientInfo, "mtrep6:ClientInfo"))
				{	soap_flag_clientInfo1--;
					continue;
				}
			if (soap_flag_favorHttp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep6:favorHttp", &a->_mtrep6__PickRepository4::favorHttp, "xsd:boolean"))
				{	soap_flag_favorHttp1--;
					continue;
				}
			if (soap_flag_nearest1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep6:nearest", &a->_mtrep6__PickRepository4::nearest, "xsd:boolean"))
				{	soap_flag_nearest1--;
					continue;
				}
			if (soap_flag_releaseState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep6__RepositoryReleaseState(soap, "mtrep6:releaseState", &a->_mtrep6__PickRepository4::releaseState, "mtrep6:RepositoryReleaseState"))
				{	soap_flag_releaseState1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_favorHttp1 > 0 || soap_flag_nearest1 > 0 || soap_flag_releaseState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_mtrep6__PickRepository4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep6__PickRepository4, SOAP_TYPE__mtrep6__PickRepository4, sizeof(_mtrep6__PickRepository4), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep6__PickRepository4 * SOAP_FMAC2 repository_instantiate__mtrep6__PickRepository4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep6__PickRepository4(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep6__PickRepository4 *p;
	size_t k = sizeof(_mtrep6__PickRepository4);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep6__PickRepository4);
		if (p)
			((_mtrep6__PickRepository4*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep6__PickRepository4, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep6__PickRepository4*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep6__PickRepository4 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep6__PickRepository4, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep6__PickRepository4::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep6:PickRepository4", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep6__PickRepository4::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep6__PickRepository4(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep6__PickRepository4 * SOAP_FMAC4 soap_get__mtrep6__PickRepository4(struct soap *soap, _mtrep6__PickRepository4 *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep6__PickRepository4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep6__GetRepositories4Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep6__GetRepositories4Response::GetRepositories4Result = NULL;
	/* transient soap skipped */
}

void _mtrep6__GetRepositories4Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep6__ArrayOfRepositoryInfo3(soap, &this->_mtrep6__GetRepositories4Response::GetRepositories4Result);
#endif
}

int _mtrep6__GetRepositories4Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep6__GetRepositories4Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep6__GetRepositories4Response(struct soap *soap, const char *tag, int id, const _mtrep6__GetRepositories4Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep6__GetRepositories4Response), type))
		return soap->error;
	if (a->GetRepositories4Result)
		soap_element_result(soap, "mtrep6:GetRepositories4Result");
	if (soap_out_PointerTomtrep6__ArrayOfRepositoryInfo3(soap, "mtrep6:GetRepositories4Result", -1, &a->_mtrep6__GetRepositories4Response::GetRepositories4Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep6__GetRepositories4Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep6__GetRepositories4Response(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep6__GetRepositories4Response * SOAP_FMAC4 soap_in__mtrep6__GetRepositories4Response(struct soap *soap, const char *tag, _mtrep6__GetRepositories4Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep6__GetRepositories4Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep6__GetRepositories4Response, sizeof(_mtrep6__GetRepositories4Response), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetRepositories4Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetRepositories4Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep6__ArrayOfRepositoryInfo3(soap, "mtrep6:GetRepositories4Result", &a->_mtrep6__GetRepositories4Response::GetRepositories4Result, "mtrep6:ArrayOfRepositoryInfo3"))
				{	soap_flag_GetRepositories4Result1--;
					continue;
				}
			soap_check_result(soap, "mtrep6:GetRepositories4Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep6__GetRepositories4Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep6__GetRepositories4Response, SOAP_TYPE__mtrep6__GetRepositories4Response, sizeof(_mtrep6__GetRepositories4Response), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep6__GetRepositories4Response * SOAP_FMAC2 repository_instantiate__mtrep6__GetRepositories4Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep6__GetRepositories4Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep6__GetRepositories4Response *p;
	size_t k = sizeof(_mtrep6__GetRepositories4Response);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep6__GetRepositories4Response);
		if (p)
			((_mtrep6__GetRepositories4Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep6__GetRepositories4Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep6__GetRepositories4Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep6__GetRepositories4Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep6__GetRepositories4Response, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep6__GetRepositories4Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep6:GetRepositories4Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep6__GetRepositories4Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep6__GetRepositories4Response(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep6__GetRepositories4Response * SOAP_FMAC4 soap_get__mtrep6__GetRepositories4Response(struct soap *soap, _mtrep6__GetRepositories4Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep6__GetRepositories4Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep6__GetRepositories4::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep6__GetRepositories4::clientInfo = NULL;
	soap_default_bool(soap, &this->_mtrep6__GetRepositories4::onlyOnline);
	soap_default_bool(soap, &this->_mtrep6__GetRepositories4::noCorrupted);
	soap_default_bool(soap, &this->_mtrep6__GetRepositories4::httpOnly);
	soap_default_bool(soap, &this->_mtrep6__GetRepositories4::excludeHidden);
	soap_default_int(soap, &this->_mtrep6__GetRepositories4::maxDelay);
	soap_default_mtrep6__RepositoryReleaseState(soap, &this->_mtrep6__GetRepositories4::releaseState);
	/* transient soap skipped */
}

void _mtrep6__GetRepositories4::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep6__ClientInfo(soap, &this->_mtrep6__GetRepositories4::clientInfo);
#endif
}

int _mtrep6__GetRepositories4::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep6__GetRepositories4(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep6__GetRepositories4(struct soap *soap, const char *tag, int id, const _mtrep6__GetRepositories4 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep6__GetRepositories4), type))
		return soap->error;
	if (soap_out_PointerTomtrep6__ClientInfo(soap, "mtrep6:clientInfo", -1, &a->_mtrep6__GetRepositories4::clientInfo, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep6:onlyOnline", -1, &a->_mtrep6__GetRepositories4::onlyOnline, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep6:noCorrupted", -1, &a->_mtrep6__GetRepositories4::noCorrupted, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep6:httpOnly", -1, &a->_mtrep6__GetRepositories4::httpOnly, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep6:excludeHidden", -1, &a->_mtrep6__GetRepositories4::excludeHidden, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep6:maxDelay", -1, &a->_mtrep6__GetRepositories4::maxDelay, ""))
		return soap->error;
	if (soap_out_mtrep6__RepositoryReleaseState(soap, "mtrep6:releaseState", -1, &a->_mtrep6__GetRepositories4::releaseState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep6__GetRepositories4::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep6__GetRepositories4(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep6__GetRepositories4 * SOAP_FMAC4 soap_in__mtrep6__GetRepositories4(struct soap *soap, const char *tag, _mtrep6__GetRepositories4 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep6__GetRepositories4 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep6__GetRepositories4, sizeof(_mtrep6__GetRepositories4), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_clientInfo1 = 1;
	size_t soap_flag_onlyOnline1 = 1;
	size_t soap_flag_noCorrupted1 = 1;
	size_t soap_flag_httpOnly1 = 1;
	size_t soap_flag_excludeHidden1 = 1;
	size_t soap_flag_maxDelay1 = 1;
	size_t soap_flag_releaseState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep6__ClientInfo(soap, "mtrep6:clientInfo", &a->_mtrep6__GetRepositories4::clientInfo, "mtrep6:ClientInfo"))
				{	soap_flag_clientInfo1--;
					continue;
				}
			if (soap_flag_onlyOnline1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep6:onlyOnline", &a->_mtrep6__GetRepositories4::onlyOnline, "xsd:boolean"))
				{	soap_flag_onlyOnline1--;
					continue;
				}
			if (soap_flag_noCorrupted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep6:noCorrupted", &a->_mtrep6__GetRepositories4::noCorrupted, "xsd:boolean"))
				{	soap_flag_noCorrupted1--;
					continue;
				}
			if (soap_flag_httpOnly1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep6:httpOnly", &a->_mtrep6__GetRepositories4::httpOnly, "xsd:boolean"))
				{	soap_flag_httpOnly1--;
					continue;
				}
			if (soap_flag_excludeHidden1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep6:excludeHidden", &a->_mtrep6__GetRepositories4::excludeHidden, "xsd:boolean"))
				{	soap_flag_excludeHidden1--;
					continue;
				}
			if (soap_flag_maxDelay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep6:maxDelay", &a->_mtrep6__GetRepositories4::maxDelay, "xsd:int"))
				{	soap_flag_maxDelay1--;
					continue;
				}
			if (soap_flag_releaseState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep6__RepositoryReleaseState(soap, "mtrep6:releaseState", &a->_mtrep6__GetRepositories4::releaseState, "mtrep6:RepositoryReleaseState"))
				{	soap_flag_releaseState1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_onlyOnline1 > 0 || soap_flag_noCorrupted1 > 0 || soap_flag_httpOnly1 > 0 || soap_flag_excludeHidden1 > 0 || soap_flag_maxDelay1 > 0 || soap_flag_releaseState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_mtrep6__GetRepositories4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep6__GetRepositories4, SOAP_TYPE__mtrep6__GetRepositories4, sizeof(_mtrep6__GetRepositories4), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep6__GetRepositories4 * SOAP_FMAC2 repository_instantiate__mtrep6__GetRepositories4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep6__GetRepositories4(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep6__GetRepositories4 *p;
	size_t k = sizeof(_mtrep6__GetRepositories4);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep6__GetRepositories4);
		if (p)
			((_mtrep6__GetRepositories4*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep6__GetRepositories4, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep6__GetRepositories4*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep6__GetRepositories4 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep6__GetRepositories4, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep6__GetRepositories4::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep6:GetRepositories4", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep6__GetRepositories4::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep6__GetRepositories4(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep6__GetRepositories4 * SOAP_FMAC4 soap_get__mtrep6__GetRepositories4(struct soap *soap, _mtrep6__GetRepositories4 *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep6__GetRepositories4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep6__RepositoryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep6__RepositoryInfo::Country = NULL;
	soap_default_int(soap, &this->mtrep6__RepositoryInfo::Date);
	soap_default_int(soap, &this->mtrep6__RepositoryInfo::Delay);
	this->mtrep6__RepositoryInfo::Description = NULL;
	soap_default_mtrep6__RepositoryIntegrity(soap, &this->mtrep6__RepositoryInfo::Integrity);
	soap_default_mtrep6__PackageLevel(soap, &this->mtrep6__RepositoryInfo::Level);
	soap_default_mtrep6__RepositoryStatus(soap, &this->mtrep6__RepositoryInfo::Status);
	this->mtrep6__RepositoryInfo::Url = NULL;
	soap_default_int(soap, &this->mtrep6__RepositoryInfo::Version);
	/* transient soap skipped */
}

void mtrep6__RepositoryInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep6__RepositoryInfo::Country);
	soap_serialize_PointerTostd__string(soap, &this->mtrep6__RepositoryInfo::Description);
	soap_serialize_PointerTostd__string(soap, &this->mtrep6__RepositoryInfo::Url);
#endif
}

int mtrep6__RepositoryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep6__RepositoryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep6__RepositoryInfo(struct soap *soap, const char *tag, int id, const mtrep6__RepositoryInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep6__RepositoryInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:Country", -1, &a->mtrep6__RepositoryInfo::Country, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep6:Date", -1, &a->mtrep6__RepositoryInfo::Date, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep6:Delay", -1, &a->mtrep6__RepositoryInfo::Delay, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:Description", -1, &a->mtrep6__RepositoryInfo::Description, ""))
		return soap->error;
	if (soap_out_mtrep6__RepositoryIntegrity(soap, "mtrep6:Integrity", -1, &a->mtrep6__RepositoryInfo::Integrity, ""))
		return soap->error;
	if (soap_out_mtrep6__PackageLevel(soap, "mtrep6:Level", -1, &a->mtrep6__RepositoryInfo::Level, ""))
		return soap->error;
	if (soap_out_mtrep6__RepositoryStatus(soap, "mtrep6:Status", -1, &a->mtrep6__RepositoryInfo::Status, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:Url", -1, &a->mtrep6__RepositoryInfo::Url, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep6:Version", -1, &a->mtrep6__RepositoryInfo::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep6__RepositoryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep6__RepositoryInfo(soap, tag, this, type);
}

SOAP_FMAC3 mtrep6__RepositoryInfo * SOAP_FMAC4 soap_in_mtrep6__RepositoryInfo(struct soap *soap, const char *tag, mtrep6__RepositoryInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep6__RepositoryInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep6__RepositoryInfo, sizeof(mtrep6__RepositoryInfo), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Country1 = 1;
	size_t soap_flag_Date1 = 1;
	size_t soap_flag_Delay1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_Integrity1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_Url1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:Country", &a->mtrep6__RepositoryInfo::Country, "xsd:string"))
				{	soap_flag_Country1--;
					continue;
				}
			if (soap_flag_Date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep6:Date", &a->mtrep6__RepositoryInfo::Date, "xsd:int"))
				{	soap_flag_Date1--;
					continue;
				}
			if (soap_flag_Delay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep6:Delay", &a->mtrep6__RepositoryInfo::Delay, "xsd:int"))
				{	soap_flag_Delay1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:Description", &a->mtrep6__RepositoryInfo::Description, "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_Integrity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep6__RepositoryIntegrity(soap, "mtrep6:Integrity", &a->mtrep6__RepositoryInfo::Integrity, "mtrep6:RepositoryIntegrity"))
				{	soap_flag_Integrity1--;
					continue;
				}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep6__PackageLevel(soap, "mtrep6:Level", &a->mtrep6__RepositoryInfo::Level, "mtrep6:PackageLevel"))
				{	soap_flag_Level1--;
					continue;
				}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep6__RepositoryStatus(soap, "mtrep6:Status", &a->mtrep6__RepositoryInfo::Status, "mtrep6:RepositoryStatus"))
				{	soap_flag_Status1--;
					continue;
				}
			if (soap_flag_Url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:Url", &a->mtrep6__RepositoryInfo::Url, "xsd:string"))
				{	soap_flag_Url1--;
					continue;
				}
			if (soap_flag_Version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep6:Version", &a->mtrep6__RepositoryInfo::Version, "xsd:int"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Date1 > 0 || soap_flag_Delay1 > 0 || soap_flag_Integrity1 > 0 || soap_flag_Level1 > 0 || soap_flag_Status1 > 0 || soap_flag_Version1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (mtrep6__RepositoryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep6__RepositoryInfo, SOAP_TYPE_mtrep6__RepositoryInfo, sizeof(mtrep6__RepositoryInfo), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep6__RepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep6__RepositoryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep6__RepositoryInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "mtrep6:RepositoryInfo2"))
		return repository_instantiate_mtrep6__RepositoryInfo2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "mtrep6:RepositoryInfo3"))
		return repository_instantiate_mtrep6__RepositoryInfo3(soap, n, NULL, NULL, size);
	mtrep6__RepositoryInfo *p;
	size_t k = sizeof(mtrep6__RepositoryInfo);
	if (n < 0)
	{	p = SOAP_NEW(mtrep6__RepositoryInfo);
		if (p)
			((mtrep6__RepositoryInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep6__RepositoryInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep6__RepositoryInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep6__RepositoryInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep6__RepositoryInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep6__RepositoryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep6:RepositoryInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep6__RepositoryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep6__RepositoryInfo(soap, this, tag, type);
}

SOAP_FMAC3 mtrep6__RepositoryInfo * SOAP_FMAC4 soap_get_mtrep6__RepositoryInfo(struct soap *soap, mtrep6__RepositoryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep6__RepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep6__RepositoryInfo2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep6__RepositoryInfo::soap_default(soap);
	this->mtrep6__RepositoryInfo2::CountryCode = NULL;
	this->mtrep6__RepositoryInfo2::City = NULL;
	soap_default_double(soap, &this->mtrep6__RepositoryInfo2::Latitude);
	soap_default_double(soap, &this->mtrep6__RepositoryInfo2::Longitude);
}

void mtrep6__RepositoryInfo2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep6__RepositoryInfo2::CountryCode);
	soap_serialize_PointerTostd__string(soap, &this->mtrep6__RepositoryInfo2::City);
	this->mtrep6__RepositoryInfo::soap_serialize(soap);
#endif
}

int mtrep6__RepositoryInfo2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep6__RepositoryInfo2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep6__RepositoryInfo2(struct soap *soap, const char *tag, int id, const mtrep6__RepositoryInfo2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep6__RepositoryInfo2), "mtrep6:RepositoryInfo2"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:Country", -1, &a->mtrep6__RepositoryInfo::Country, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep6:Date", -1, &a->mtrep6__RepositoryInfo::Date, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep6:Delay", -1, &a->mtrep6__RepositoryInfo::Delay, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:Description", -1, &a->mtrep6__RepositoryInfo::Description, ""))
		return soap->error;
	if (soap_out_mtrep6__RepositoryIntegrity(soap, "mtrep6:Integrity", -1, &a->mtrep6__RepositoryInfo::Integrity, ""))
		return soap->error;
	if (soap_out_mtrep6__PackageLevel(soap, "mtrep6:Level", -1, &a->mtrep6__RepositoryInfo::Level, ""))
		return soap->error;
	if (soap_out_mtrep6__RepositoryStatus(soap, "mtrep6:Status", -1, &a->mtrep6__RepositoryInfo::Status, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:Url", -1, &a->mtrep6__RepositoryInfo::Url, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep6:Version", -1, &a->mtrep6__RepositoryInfo::Version, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:CountryCode", -1, &a->mtrep6__RepositoryInfo2::CountryCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:City", -1, &a->mtrep6__RepositoryInfo2::City, ""))
		return soap->error;
	if (soap_out_double(soap, "mtrep6:Latitude", -1, &a->mtrep6__RepositoryInfo2::Latitude, ""))
		return soap->error;
	if (soap_out_double(soap, "mtrep6:Longitude", -1, &a->mtrep6__RepositoryInfo2::Longitude, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep6__RepositoryInfo2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep6__RepositoryInfo2(soap, tag, this, type);
}

SOAP_FMAC3 mtrep6__RepositoryInfo2 * SOAP_FMAC4 soap_in_mtrep6__RepositoryInfo2(struct soap *soap, const char *tag, mtrep6__RepositoryInfo2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep6__RepositoryInfo2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep6__RepositoryInfo2, sizeof(mtrep6__RepositoryInfo2), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_mtrep6__RepositoryInfo2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (mtrep6__RepositoryInfo2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Country2 = 1;
	size_t soap_flag_Date2 = 1;
	size_t soap_flag_Delay2 = 1;
	size_t soap_flag_Description2 = 1;
	size_t soap_flag_Integrity2 = 1;
	size_t soap_flag_Level2 = 1;
	size_t soap_flag_Status2 = 1;
	size_t soap_flag_Url2 = 1;
	size_t soap_flag_Version2 = 1;
	size_t soap_flag_CountryCode1 = 1;
	size_t soap_flag_City1 = 1;
	size_t soap_flag_Latitude1 = 1;
	size_t soap_flag_Longitude1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Country2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:Country", &a->mtrep6__RepositoryInfo::Country, "xsd:string"))
				{	soap_flag_Country2--;
					continue;
				}
			if (soap_flag_Date2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep6:Date", &a->mtrep6__RepositoryInfo::Date, "xsd:int"))
				{	soap_flag_Date2--;
					continue;
				}
			if (soap_flag_Delay2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep6:Delay", &a->mtrep6__RepositoryInfo::Delay, "xsd:int"))
				{	soap_flag_Delay2--;
					continue;
				}
			if (soap_flag_Description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:Description", &a->mtrep6__RepositoryInfo::Description, "xsd:string"))
				{	soap_flag_Description2--;
					continue;
				}
			if (soap_flag_Integrity2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep6__RepositoryIntegrity(soap, "mtrep6:Integrity", &a->mtrep6__RepositoryInfo::Integrity, "mtrep6:RepositoryIntegrity"))
				{	soap_flag_Integrity2--;
					continue;
				}
			if (soap_flag_Level2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep6__PackageLevel(soap, "mtrep6:Level", &a->mtrep6__RepositoryInfo::Level, "mtrep6:PackageLevel"))
				{	soap_flag_Level2--;
					continue;
				}
			if (soap_flag_Status2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep6__RepositoryStatus(soap, "mtrep6:Status", &a->mtrep6__RepositoryInfo::Status, "mtrep6:RepositoryStatus"))
				{	soap_flag_Status2--;
					continue;
				}
			if (soap_flag_Url2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:Url", &a->mtrep6__RepositoryInfo::Url, "xsd:string"))
				{	soap_flag_Url2--;
					continue;
				}
			if (soap_flag_Version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep6:Version", &a->mtrep6__RepositoryInfo::Version, "xsd:int"))
				{	soap_flag_Version2--;
					continue;
				}
			if (soap_flag_CountryCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:CountryCode", &a->mtrep6__RepositoryInfo2::CountryCode, "xsd:string"))
				{	soap_flag_CountryCode1--;
					continue;
				}
			if (soap_flag_City1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:City", &a->mtrep6__RepositoryInfo2::City, "xsd:string"))
				{	soap_flag_City1--;
					continue;
				}
			if (soap_flag_Latitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "mtrep6:Latitude", &a->mtrep6__RepositoryInfo2::Latitude, "xsd:double"))
				{	soap_flag_Latitude1--;
					continue;
				}
			if (soap_flag_Longitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "mtrep6:Longitude", &a->mtrep6__RepositoryInfo2::Longitude, "xsd:double"))
				{	soap_flag_Longitude1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Date2 > 0 || soap_flag_Delay2 > 0 || soap_flag_Integrity2 > 0 || soap_flag_Level2 > 0 || soap_flag_Status2 > 0 || soap_flag_Version2 > 0 || soap_flag_Latitude1 > 0 || soap_flag_Longitude1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (mtrep6__RepositoryInfo2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep6__RepositoryInfo2, SOAP_TYPE_mtrep6__RepositoryInfo2, sizeof(mtrep6__RepositoryInfo2), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep6__RepositoryInfo2 * SOAP_FMAC2 repository_instantiate_mtrep6__RepositoryInfo2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep6__RepositoryInfo2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "mtrep6:RepositoryInfo3"))
		return repository_instantiate_mtrep6__RepositoryInfo3(soap, n, NULL, NULL, size);
	mtrep6__RepositoryInfo2 *p;
	size_t k = sizeof(mtrep6__RepositoryInfo2);
	if (n < 0)
	{	p = SOAP_NEW(mtrep6__RepositoryInfo2);
		if (p)
			((mtrep6__RepositoryInfo2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep6__RepositoryInfo2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep6__RepositoryInfo2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep6__RepositoryInfo2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep6__RepositoryInfo2, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep6__RepositoryInfo2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep6:RepositoryInfo2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep6__RepositoryInfo2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep6__RepositoryInfo2(soap, this, tag, type);
}

SOAP_FMAC3 mtrep6__RepositoryInfo2 * SOAP_FMAC4 soap_get_mtrep6__RepositoryInfo2(struct soap *soap, mtrep6__RepositoryInfo2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep6__RepositoryInfo2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep6__RepositoryInfo3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep6__RepositoryInfo2::soap_default(soap);
	this->mtrep6__RepositoryInfo3::Attributes = NULL;
	soap_default_mtrep6__RepositoryReleaseState(soap, &this->mtrep6__RepositoryInfo3::ReleaseState);
}

void mtrep6__RepositoryInfo3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep6__RepositoryInfo3::Attributes);
	this->mtrep6__RepositoryInfo2::soap_serialize(soap);
#endif
}

int mtrep6__RepositoryInfo3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep6__RepositoryInfo3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep6__RepositoryInfo3(struct soap *soap, const char *tag, int id, const mtrep6__RepositoryInfo3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep6__RepositoryInfo3), "mtrep6:RepositoryInfo3"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:Country", -1, &a->mtrep6__RepositoryInfo::Country, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep6:Date", -1, &a->mtrep6__RepositoryInfo::Date, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep6:Delay", -1, &a->mtrep6__RepositoryInfo::Delay, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:Description", -1, &a->mtrep6__RepositoryInfo::Description, ""))
		return soap->error;
	if (soap_out_mtrep6__RepositoryIntegrity(soap, "mtrep6:Integrity", -1, &a->mtrep6__RepositoryInfo::Integrity, ""))
		return soap->error;
	if (soap_out_mtrep6__PackageLevel(soap, "mtrep6:Level", -1, &a->mtrep6__RepositoryInfo::Level, ""))
		return soap->error;
	if (soap_out_mtrep6__RepositoryStatus(soap, "mtrep6:Status", -1, &a->mtrep6__RepositoryInfo::Status, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:Url", -1, &a->mtrep6__RepositoryInfo::Url, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep6:Version", -1, &a->mtrep6__RepositoryInfo::Version, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:CountryCode", -1, &a->mtrep6__RepositoryInfo2::CountryCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:City", -1, &a->mtrep6__RepositoryInfo2::City, ""))
		return soap->error;
	if (soap_out_double(soap, "mtrep6:Latitude", -1, &a->mtrep6__RepositoryInfo2::Latitude, ""))
		return soap->error;
	if (soap_out_double(soap, "mtrep6:Longitude", -1, &a->mtrep6__RepositoryInfo2::Longitude, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:Attributes", -1, &a->mtrep6__RepositoryInfo3::Attributes, ""))
		return soap->error;
	if (soap_out_mtrep6__RepositoryReleaseState(soap, "mtrep6:ReleaseState", -1, &a->mtrep6__RepositoryInfo3::ReleaseState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep6__RepositoryInfo3::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep6__RepositoryInfo3(soap, tag, this, type);
}

SOAP_FMAC3 mtrep6__RepositoryInfo3 * SOAP_FMAC4 soap_in_mtrep6__RepositoryInfo3(struct soap *soap, const char *tag, mtrep6__RepositoryInfo3 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep6__RepositoryInfo3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep6__RepositoryInfo3, sizeof(mtrep6__RepositoryInfo3), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_mtrep6__RepositoryInfo3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (mtrep6__RepositoryInfo3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Country3 = 1;
	size_t soap_flag_Date3 = 1;
	size_t soap_flag_Delay3 = 1;
	size_t soap_flag_Description3 = 1;
	size_t soap_flag_Integrity3 = 1;
	size_t soap_flag_Level3 = 1;
	size_t soap_flag_Status3 = 1;
	size_t soap_flag_Url3 = 1;
	size_t soap_flag_Version3 = 1;
	size_t soap_flag_CountryCode2 = 1;
	size_t soap_flag_City2 = 1;
	size_t soap_flag_Latitude2 = 1;
	size_t soap_flag_Longitude2 = 1;
	size_t soap_flag_Attributes1 = 1;
	size_t soap_flag_ReleaseState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Country3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:Country", &a->mtrep6__RepositoryInfo::Country, "xsd:string"))
				{	soap_flag_Country3--;
					continue;
				}
			if (soap_flag_Date3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep6:Date", &a->mtrep6__RepositoryInfo::Date, "xsd:int"))
				{	soap_flag_Date3--;
					continue;
				}
			if (soap_flag_Delay3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep6:Delay", &a->mtrep6__RepositoryInfo::Delay, "xsd:int"))
				{	soap_flag_Delay3--;
					continue;
				}
			if (soap_flag_Description3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:Description", &a->mtrep6__RepositoryInfo::Description, "xsd:string"))
				{	soap_flag_Description3--;
					continue;
				}
			if (soap_flag_Integrity3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep6__RepositoryIntegrity(soap, "mtrep6:Integrity", &a->mtrep6__RepositoryInfo::Integrity, "mtrep6:RepositoryIntegrity"))
				{	soap_flag_Integrity3--;
					continue;
				}
			if (soap_flag_Level3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep6__PackageLevel(soap, "mtrep6:Level", &a->mtrep6__RepositoryInfo::Level, "mtrep6:PackageLevel"))
				{	soap_flag_Level3--;
					continue;
				}
			if (soap_flag_Status3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep6__RepositoryStatus(soap, "mtrep6:Status", &a->mtrep6__RepositoryInfo::Status, "mtrep6:RepositoryStatus"))
				{	soap_flag_Status3--;
					continue;
				}
			if (soap_flag_Url3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:Url", &a->mtrep6__RepositoryInfo::Url, "xsd:string"))
				{	soap_flag_Url3--;
					continue;
				}
			if (soap_flag_Version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep6:Version", &a->mtrep6__RepositoryInfo::Version, "xsd:int"))
				{	soap_flag_Version3--;
					continue;
				}
			if (soap_flag_CountryCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:CountryCode", &a->mtrep6__RepositoryInfo2::CountryCode, "xsd:string"))
				{	soap_flag_CountryCode2--;
					continue;
				}
			if (soap_flag_City2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:City", &a->mtrep6__RepositoryInfo2::City, "xsd:string"))
				{	soap_flag_City2--;
					continue;
				}
			if (soap_flag_Latitude2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "mtrep6:Latitude", &a->mtrep6__RepositoryInfo2::Latitude, "xsd:double"))
				{	soap_flag_Latitude2--;
					continue;
				}
			if (soap_flag_Longitude2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "mtrep6:Longitude", &a->mtrep6__RepositoryInfo2::Longitude, "xsd:double"))
				{	soap_flag_Longitude2--;
					continue;
				}
			if (soap_flag_Attributes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:Attributes", &a->mtrep6__RepositoryInfo3::Attributes, "xsd:string"))
				{	soap_flag_Attributes1--;
					continue;
				}
			if (soap_flag_ReleaseState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep6__RepositoryReleaseState(soap, "mtrep6:ReleaseState", &a->mtrep6__RepositoryInfo3::ReleaseState, "mtrep6:RepositoryReleaseState"))
				{	soap_flag_ReleaseState1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Date3 > 0 || soap_flag_Delay3 > 0 || soap_flag_Integrity3 > 0 || soap_flag_Level3 > 0 || soap_flag_Status3 > 0 || soap_flag_Version3 > 0 || soap_flag_Latitude2 > 0 || soap_flag_Longitude2 > 0 || soap_flag_ReleaseState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (mtrep6__RepositoryInfo3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep6__RepositoryInfo3, SOAP_TYPE_mtrep6__RepositoryInfo3, sizeof(mtrep6__RepositoryInfo3), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep6__RepositoryInfo3 * SOAP_FMAC2 repository_instantiate_mtrep6__RepositoryInfo3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep6__RepositoryInfo3(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep6__RepositoryInfo3 *p;
	size_t k = sizeof(mtrep6__RepositoryInfo3);
	if (n < 0)
	{	p = SOAP_NEW(mtrep6__RepositoryInfo3);
		if (p)
			((mtrep6__RepositoryInfo3*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep6__RepositoryInfo3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep6__RepositoryInfo3*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep6__RepositoryInfo3 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep6__RepositoryInfo3, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep6__RepositoryInfo3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep6:RepositoryInfo3", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep6__RepositoryInfo3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep6__RepositoryInfo3(soap, this, tag, type);
}

SOAP_FMAC3 mtrep6__RepositoryInfo3 * SOAP_FMAC4 soap_get_mtrep6__RepositoryInfo3(struct soap *soap, mtrep6__RepositoryInfo3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep6__RepositoryInfo3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep6__ArrayOfRepositoryInfo3::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3(soap, &this->mtrep6__ArrayOfRepositoryInfo3::RepositoryInfo3);
	/* transient soap skipped */
}

void mtrep6__ArrayOfRepositoryInfo3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3(soap, &this->mtrep6__ArrayOfRepositoryInfo3::RepositoryInfo3);
#endif
}

int mtrep6__ArrayOfRepositoryInfo3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep6__ArrayOfRepositoryInfo3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep6__ArrayOfRepositoryInfo3(struct soap *soap, const char *tag, int id, const mtrep6__ArrayOfRepositoryInfo3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3(soap, "mtrep6:RepositoryInfo3", -1, &a->mtrep6__ArrayOfRepositoryInfo3::RepositoryInfo3, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep6__ArrayOfRepositoryInfo3::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep6__ArrayOfRepositoryInfo3(soap, tag, this, type);
}

SOAP_FMAC3 mtrep6__ArrayOfRepositoryInfo3 * SOAP_FMAC4 soap_in_mtrep6__ArrayOfRepositoryInfo3(struct soap *soap, const char *tag, mtrep6__ArrayOfRepositoryInfo3 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep6__ArrayOfRepositoryInfo3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3, sizeof(mtrep6__ArrayOfRepositoryInfo3), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3(soap, "mtrep6:RepositoryInfo3", &a->mtrep6__ArrayOfRepositoryInfo3::RepositoryInfo3, "mtrep6:RepositoryInfo3"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mtrep6__ArrayOfRepositoryInfo3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3, SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3, sizeof(mtrep6__ArrayOfRepositoryInfo3), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep6__ArrayOfRepositoryInfo3 * SOAP_FMAC2 repository_instantiate_mtrep6__ArrayOfRepositoryInfo3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep6__ArrayOfRepositoryInfo3(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep6__ArrayOfRepositoryInfo3 *p;
	size_t k = sizeof(mtrep6__ArrayOfRepositoryInfo3);
	if (n < 0)
	{	p = SOAP_NEW(mtrep6__ArrayOfRepositoryInfo3);
		if (p)
			((mtrep6__ArrayOfRepositoryInfo3*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep6__ArrayOfRepositoryInfo3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep6__ArrayOfRepositoryInfo3*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep6__ArrayOfRepositoryInfo3 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep6__ArrayOfRepositoryInfo3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep6:ArrayOfRepositoryInfo3", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep6__ArrayOfRepositoryInfo3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep6__ArrayOfRepositoryInfo3(soap, this, tag, type);
}

SOAP_FMAC3 mtrep6__ArrayOfRepositoryInfo3 * SOAP_FMAC4 soap_get_mtrep6__ArrayOfRepositoryInfo3(struct soap *soap, mtrep6__ArrayOfRepositoryInfo3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep6__ArrayOfRepositoryInfo3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep6__ClientInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep6__ClientInfo::Name = NULL;
	this->mtrep6__ClientInfo::Version = NULL;
	/* transient soap skipped */
}

void mtrep6__ClientInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep6__ClientInfo::Name);
	soap_serialize_PointerTostd__string(soap, &this->mtrep6__ClientInfo::Version);
#endif
}

int mtrep6__ClientInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep6__ClientInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep6__ClientInfo(struct soap *soap, const char *tag, int id, const mtrep6__ClientInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep6__ClientInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:Name", -1, &a->mtrep6__ClientInfo::Name, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep6:Version", -1, &a->mtrep6__ClientInfo::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep6__ClientInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep6__ClientInfo(soap, tag, this, type);
}

SOAP_FMAC3 mtrep6__ClientInfo * SOAP_FMAC4 soap_in_mtrep6__ClientInfo(struct soap *soap, const char *tag, mtrep6__ClientInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep6__ClientInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep6__ClientInfo, sizeof(mtrep6__ClientInfo), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:Name", &a->mtrep6__ClientInfo::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep6:Version", &a->mtrep6__ClientInfo::Version, "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mtrep6__ClientInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep6__ClientInfo, SOAP_TYPE_mtrep6__ClientInfo, sizeof(mtrep6__ClientInfo), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep6__ClientInfo * SOAP_FMAC2 repository_instantiate_mtrep6__ClientInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep6__ClientInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep6__ClientInfo *p;
	size_t k = sizeof(mtrep6__ClientInfo);
	if (n < 0)
	{	p = SOAP_NEW(mtrep6__ClientInfo);
		if (p)
			((mtrep6__ClientInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep6__ClientInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep6__ClientInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep6__ClientInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep6__ClientInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep6__ClientInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep6:ClientInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep6__ClientInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep6__ClientInfo(soap, this, tag, type);
}

SOAP_FMAC3 mtrep6__ClientInfo * SOAP_FMAC4 soap_get_mtrep6__ClientInfo(struct soap *soap, mtrep6__ClientInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep6__ClientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep5__PickRepository3Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep5__PickRepository3Response::PickRepository3Result = NULL;
	/* transient soap skipped */
}

void _mtrep5__PickRepository3Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep5__RepositoryInfo2(soap, &this->_mtrep5__PickRepository3Response::PickRepository3Result);
#endif
}

int _mtrep5__PickRepository3Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep5__PickRepository3Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep5__PickRepository3Response(struct soap *soap, const char *tag, int id, const _mtrep5__PickRepository3Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep5__PickRepository3Response), type))
		return soap->error;
	if (a->PickRepository3Result)
		soap_element_result(soap, "mtrep5:PickRepository3Result");
	if (soap_out_PointerTomtrep5__RepositoryInfo2(soap, "mtrep5:PickRepository3Result", -1, &a->_mtrep5__PickRepository3Response::PickRepository3Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep5__PickRepository3Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep5__PickRepository3Response(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep5__PickRepository3Response * SOAP_FMAC4 soap_in__mtrep5__PickRepository3Response(struct soap *soap, const char *tag, _mtrep5__PickRepository3Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep5__PickRepository3Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep5__PickRepository3Response, sizeof(_mtrep5__PickRepository3Response), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PickRepository3Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PickRepository3Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep5__RepositoryInfo2(soap, "mtrep5:PickRepository3Result", &a->_mtrep5__PickRepository3Response::PickRepository3Result, "mtrep5:RepositoryInfo2"))
				{	soap_flag_PickRepository3Result1--;
					continue;
				}
			soap_check_result(soap, "mtrep5:PickRepository3Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep5__PickRepository3Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep5__PickRepository3Response, SOAP_TYPE__mtrep5__PickRepository3Response, sizeof(_mtrep5__PickRepository3Response), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep5__PickRepository3Response * SOAP_FMAC2 repository_instantiate__mtrep5__PickRepository3Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep5__PickRepository3Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep5__PickRepository3Response *p;
	size_t k = sizeof(_mtrep5__PickRepository3Response);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep5__PickRepository3Response);
		if (p)
			((_mtrep5__PickRepository3Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep5__PickRepository3Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep5__PickRepository3Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep5__PickRepository3Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep5__PickRepository3Response, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep5__PickRepository3Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep5:PickRepository3Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep5__PickRepository3Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep5__PickRepository3Response(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep5__PickRepository3Response * SOAP_FMAC4 soap_get__mtrep5__PickRepository3Response(struct soap *soap, _mtrep5__PickRepository3Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep5__PickRepository3Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep5__PickRepository3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep5__PickRepository3::clientInfo = NULL;
	soap_default_bool(soap, &this->_mtrep5__PickRepository3::favorHttp);
	soap_default_bool(soap, &this->_mtrep5__PickRepository3::nearest);
	/* transient soap skipped */
}

void _mtrep5__PickRepository3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep5__ClientInfo(soap, &this->_mtrep5__PickRepository3::clientInfo);
#endif
}

int _mtrep5__PickRepository3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep5__PickRepository3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep5__PickRepository3(struct soap *soap, const char *tag, int id, const _mtrep5__PickRepository3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep5__PickRepository3), type))
		return soap->error;
	if (soap_out_PointerTomtrep5__ClientInfo(soap, "mtrep5:clientInfo", -1, &a->_mtrep5__PickRepository3::clientInfo, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep5:favorHttp", -1, &a->_mtrep5__PickRepository3::favorHttp, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep5:nearest", -1, &a->_mtrep5__PickRepository3::nearest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep5__PickRepository3::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep5__PickRepository3(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep5__PickRepository3 * SOAP_FMAC4 soap_in__mtrep5__PickRepository3(struct soap *soap, const char *tag, _mtrep5__PickRepository3 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep5__PickRepository3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep5__PickRepository3, sizeof(_mtrep5__PickRepository3), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_clientInfo1 = 1;
	size_t soap_flag_favorHttp1 = 1;
	size_t soap_flag_nearest1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep5__ClientInfo(soap, "mtrep5:clientInfo", &a->_mtrep5__PickRepository3::clientInfo, "mtrep5:ClientInfo"))
				{	soap_flag_clientInfo1--;
					continue;
				}
			if (soap_flag_favorHttp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep5:favorHttp", &a->_mtrep5__PickRepository3::favorHttp, "xsd:boolean"))
				{	soap_flag_favorHttp1--;
					continue;
				}
			if (soap_flag_nearest1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep5:nearest", &a->_mtrep5__PickRepository3::nearest, "xsd:boolean"))
				{	soap_flag_nearest1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_favorHttp1 > 0 || soap_flag_nearest1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_mtrep5__PickRepository3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep5__PickRepository3, SOAP_TYPE__mtrep5__PickRepository3, sizeof(_mtrep5__PickRepository3), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep5__PickRepository3 * SOAP_FMAC2 repository_instantiate__mtrep5__PickRepository3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep5__PickRepository3(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep5__PickRepository3 *p;
	size_t k = sizeof(_mtrep5__PickRepository3);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep5__PickRepository3);
		if (p)
			((_mtrep5__PickRepository3*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep5__PickRepository3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep5__PickRepository3*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep5__PickRepository3 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep5__PickRepository3, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep5__PickRepository3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep5:PickRepository3", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep5__PickRepository3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep5__PickRepository3(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep5__PickRepository3 * SOAP_FMAC4 soap_get__mtrep5__PickRepository3(struct soap *soap, _mtrep5__PickRepository3 *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep5__PickRepository3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep5__GetRepositories3Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep5__GetRepositories3Response::GetRepositories3Result = NULL;
	/* transient soap skipped */
}

void _mtrep5__GetRepositories3Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep5__ArrayOfRepositoryInfo2(soap, &this->_mtrep5__GetRepositories3Response::GetRepositories3Result);
#endif
}

int _mtrep5__GetRepositories3Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep5__GetRepositories3Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep5__GetRepositories3Response(struct soap *soap, const char *tag, int id, const _mtrep5__GetRepositories3Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep5__GetRepositories3Response), type))
		return soap->error;
	if (a->GetRepositories3Result)
		soap_element_result(soap, "mtrep5:GetRepositories3Result");
	if (soap_out_PointerTomtrep5__ArrayOfRepositoryInfo2(soap, "mtrep5:GetRepositories3Result", -1, &a->_mtrep5__GetRepositories3Response::GetRepositories3Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep5__GetRepositories3Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep5__GetRepositories3Response(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep5__GetRepositories3Response * SOAP_FMAC4 soap_in__mtrep5__GetRepositories3Response(struct soap *soap, const char *tag, _mtrep5__GetRepositories3Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep5__GetRepositories3Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep5__GetRepositories3Response, sizeof(_mtrep5__GetRepositories3Response), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetRepositories3Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetRepositories3Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep5__ArrayOfRepositoryInfo2(soap, "mtrep5:GetRepositories3Result", &a->_mtrep5__GetRepositories3Response::GetRepositories3Result, "mtrep5:ArrayOfRepositoryInfo2"))
				{	soap_flag_GetRepositories3Result1--;
					continue;
				}
			soap_check_result(soap, "mtrep5:GetRepositories3Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep5__GetRepositories3Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep5__GetRepositories3Response, SOAP_TYPE__mtrep5__GetRepositories3Response, sizeof(_mtrep5__GetRepositories3Response), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep5__GetRepositories3Response * SOAP_FMAC2 repository_instantiate__mtrep5__GetRepositories3Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep5__GetRepositories3Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep5__GetRepositories3Response *p;
	size_t k = sizeof(_mtrep5__GetRepositories3Response);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep5__GetRepositories3Response);
		if (p)
			((_mtrep5__GetRepositories3Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep5__GetRepositories3Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep5__GetRepositories3Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep5__GetRepositories3Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep5__GetRepositories3Response, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep5__GetRepositories3Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep5:GetRepositories3Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep5__GetRepositories3Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep5__GetRepositories3Response(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep5__GetRepositories3Response * SOAP_FMAC4 soap_get__mtrep5__GetRepositories3Response(struct soap *soap, _mtrep5__GetRepositories3Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep5__GetRepositories3Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep5__GetRepositories3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep5__GetRepositories3::clientInfo = NULL;
	soap_default_bool(soap, &this->_mtrep5__GetRepositories3::onlyOnline);
	soap_default_bool(soap, &this->_mtrep5__GetRepositories3::noCorrupted);
	soap_default_bool(soap, &this->_mtrep5__GetRepositories3::httpOnly);
	soap_default_bool(soap, &this->_mtrep5__GetRepositories3::excludeHidden);
	soap_default_int(soap, &this->_mtrep5__GetRepositories3::maxDelay);
	/* transient soap skipped */
}

void _mtrep5__GetRepositories3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep5__ClientInfo(soap, &this->_mtrep5__GetRepositories3::clientInfo);
#endif
}

int _mtrep5__GetRepositories3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep5__GetRepositories3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep5__GetRepositories3(struct soap *soap, const char *tag, int id, const _mtrep5__GetRepositories3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep5__GetRepositories3), type))
		return soap->error;
	if (soap_out_PointerTomtrep5__ClientInfo(soap, "mtrep5:clientInfo", -1, &a->_mtrep5__GetRepositories3::clientInfo, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep5:onlyOnline", -1, &a->_mtrep5__GetRepositories3::onlyOnline, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep5:noCorrupted", -1, &a->_mtrep5__GetRepositories3::noCorrupted, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep5:httpOnly", -1, &a->_mtrep5__GetRepositories3::httpOnly, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep5:excludeHidden", -1, &a->_mtrep5__GetRepositories3::excludeHidden, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep5:maxDelay", -1, &a->_mtrep5__GetRepositories3::maxDelay, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep5__GetRepositories3::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep5__GetRepositories3(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep5__GetRepositories3 * SOAP_FMAC4 soap_in__mtrep5__GetRepositories3(struct soap *soap, const char *tag, _mtrep5__GetRepositories3 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep5__GetRepositories3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep5__GetRepositories3, sizeof(_mtrep5__GetRepositories3), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_clientInfo1 = 1;
	size_t soap_flag_onlyOnline1 = 1;
	size_t soap_flag_noCorrupted1 = 1;
	size_t soap_flag_httpOnly1 = 1;
	size_t soap_flag_excludeHidden1 = 1;
	size_t soap_flag_maxDelay1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep5__ClientInfo(soap, "mtrep5:clientInfo", &a->_mtrep5__GetRepositories3::clientInfo, "mtrep5:ClientInfo"))
				{	soap_flag_clientInfo1--;
					continue;
				}
			if (soap_flag_onlyOnline1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep5:onlyOnline", &a->_mtrep5__GetRepositories3::onlyOnline, "xsd:boolean"))
				{	soap_flag_onlyOnline1--;
					continue;
				}
			if (soap_flag_noCorrupted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep5:noCorrupted", &a->_mtrep5__GetRepositories3::noCorrupted, "xsd:boolean"))
				{	soap_flag_noCorrupted1--;
					continue;
				}
			if (soap_flag_httpOnly1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep5:httpOnly", &a->_mtrep5__GetRepositories3::httpOnly, "xsd:boolean"))
				{	soap_flag_httpOnly1--;
					continue;
				}
			if (soap_flag_excludeHidden1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep5:excludeHidden", &a->_mtrep5__GetRepositories3::excludeHidden, "xsd:boolean"))
				{	soap_flag_excludeHidden1--;
					continue;
				}
			if (soap_flag_maxDelay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep5:maxDelay", &a->_mtrep5__GetRepositories3::maxDelay, "xsd:int"))
				{	soap_flag_maxDelay1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_onlyOnline1 > 0 || soap_flag_noCorrupted1 > 0 || soap_flag_httpOnly1 > 0 || soap_flag_excludeHidden1 > 0 || soap_flag_maxDelay1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_mtrep5__GetRepositories3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep5__GetRepositories3, SOAP_TYPE__mtrep5__GetRepositories3, sizeof(_mtrep5__GetRepositories3), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep5__GetRepositories3 * SOAP_FMAC2 repository_instantiate__mtrep5__GetRepositories3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep5__GetRepositories3(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep5__GetRepositories3 *p;
	size_t k = sizeof(_mtrep5__GetRepositories3);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep5__GetRepositories3);
		if (p)
			((_mtrep5__GetRepositories3*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep5__GetRepositories3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep5__GetRepositories3*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep5__GetRepositories3 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep5__GetRepositories3, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep5__GetRepositories3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep5:GetRepositories3", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep5__GetRepositories3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep5__GetRepositories3(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep5__GetRepositories3 * SOAP_FMAC4 soap_get__mtrep5__GetRepositories3(struct soap *soap, _mtrep5__GetRepositories3 *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep5__GetRepositories3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep5__RepositoryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep5__RepositoryInfo::Country = NULL;
	soap_default_int(soap, &this->mtrep5__RepositoryInfo::Date);
	soap_default_int(soap, &this->mtrep5__RepositoryInfo::Delay);
	this->mtrep5__RepositoryInfo::Description = NULL;
	soap_default_mtrep5__RepositoryIntegrity(soap, &this->mtrep5__RepositoryInfo::Integrity);
	soap_default_mtrep5__PackageLevel(soap, &this->mtrep5__RepositoryInfo::Level);
	soap_default_mtrep5__RepositoryStatus(soap, &this->mtrep5__RepositoryInfo::Status);
	this->mtrep5__RepositoryInfo::Url = NULL;
	soap_default_int(soap, &this->mtrep5__RepositoryInfo::Version);
	/* transient soap skipped */
}

void mtrep5__RepositoryInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep5__RepositoryInfo::Country);
	soap_serialize_PointerTostd__string(soap, &this->mtrep5__RepositoryInfo::Description);
	soap_serialize_PointerTostd__string(soap, &this->mtrep5__RepositoryInfo::Url);
#endif
}

int mtrep5__RepositoryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep5__RepositoryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep5__RepositoryInfo(struct soap *soap, const char *tag, int id, const mtrep5__RepositoryInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep5__RepositoryInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep5:Country", -1, &a->mtrep5__RepositoryInfo::Country, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep5:Date", -1, &a->mtrep5__RepositoryInfo::Date, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep5:Delay", -1, &a->mtrep5__RepositoryInfo::Delay, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep5:Description", -1, &a->mtrep5__RepositoryInfo::Description, ""))
		return soap->error;
	if (soap_out_mtrep5__RepositoryIntegrity(soap, "mtrep5:Integrity", -1, &a->mtrep5__RepositoryInfo::Integrity, ""))
		return soap->error;
	if (soap_out_mtrep5__PackageLevel(soap, "mtrep5:Level", -1, &a->mtrep5__RepositoryInfo::Level, ""))
		return soap->error;
	if (soap_out_mtrep5__RepositoryStatus(soap, "mtrep5:Status", -1, &a->mtrep5__RepositoryInfo::Status, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep5:Url", -1, &a->mtrep5__RepositoryInfo::Url, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep5:Version", -1, &a->mtrep5__RepositoryInfo::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep5__RepositoryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep5__RepositoryInfo(soap, tag, this, type);
}

SOAP_FMAC3 mtrep5__RepositoryInfo * SOAP_FMAC4 soap_in_mtrep5__RepositoryInfo(struct soap *soap, const char *tag, mtrep5__RepositoryInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep5__RepositoryInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep5__RepositoryInfo, sizeof(mtrep5__RepositoryInfo), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Country1 = 1;
	size_t soap_flag_Date1 = 1;
	size_t soap_flag_Delay1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_Integrity1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_Url1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep5:Country", &a->mtrep5__RepositoryInfo::Country, "xsd:string"))
				{	soap_flag_Country1--;
					continue;
				}
			if (soap_flag_Date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep5:Date", &a->mtrep5__RepositoryInfo::Date, "xsd:int"))
				{	soap_flag_Date1--;
					continue;
				}
			if (soap_flag_Delay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep5:Delay", &a->mtrep5__RepositoryInfo::Delay, "xsd:int"))
				{	soap_flag_Delay1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep5:Description", &a->mtrep5__RepositoryInfo::Description, "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_Integrity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep5__RepositoryIntegrity(soap, "mtrep5:Integrity", &a->mtrep5__RepositoryInfo::Integrity, "mtrep5:RepositoryIntegrity"))
				{	soap_flag_Integrity1--;
					continue;
				}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep5__PackageLevel(soap, "mtrep5:Level", &a->mtrep5__RepositoryInfo::Level, "mtrep5:PackageLevel"))
				{	soap_flag_Level1--;
					continue;
				}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep5__RepositoryStatus(soap, "mtrep5:Status", &a->mtrep5__RepositoryInfo::Status, "mtrep5:RepositoryStatus"))
				{	soap_flag_Status1--;
					continue;
				}
			if (soap_flag_Url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep5:Url", &a->mtrep5__RepositoryInfo::Url, "xsd:string"))
				{	soap_flag_Url1--;
					continue;
				}
			if (soap_flag_Version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep5:Version", &a->mtrep5__RepositoryInfo::Version, "xsd:int"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Date1 > 0 || soap_flag_Delay1 > 0 || soap_flag_Integrity1 > 0 || soap_flag_Level1 > 0 || soap_flag_Status1 > 0 || soap_flag_Version1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (mtrep5__RepositoryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep5__RepositoryInfo, SOAP_TYPE_mtrep5__RepositoryInfo, sizeof(mtrep5__RepositoryInfo), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep5__RepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep5__RepositoryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep5__RepositoryInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "mtrep5:RepositoryInfo2"))
		return repository_instantiate_mtrep5__RepositoryInfo2(soap, n, NULL, NULL, size);
	mtrep5__RepositoryInfo *p;
	size_t k = sizeof(mtrep5__RepositoryInfo);
	if (n < 0)
	{	p = SOAP_NEW(mtrep5__RepositoryInfo);
		if (p)
			((mtrep5__RepositoryInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep5__RepositoryInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep5__RepositoryInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep5__RepositoryInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep5__RepositoryInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep5__RepositoryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep5:RepositoryInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep5__RepositoryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep5__RepositoryInfo(soap, this, tag, type);
}

SOAP_FMAC3 mtrep5__RepositoryInfo * SOAP_FMAC4 soap_get_mtrep5__RepositoryInfo(struct soap *soap, mtrep5__RepositoryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep5__RepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep5__RepositoryInfo2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep5__RepositoryInfo::soap_default(soap);
	this->mtrep5__RepositoryInfo2::CountryCode = NULL;
	this->mtrep5__RepositoryInfo2::City = NULL;
	soap_default_double(soap, &this->mtrep5__RepositoryInfo2::Latitude);
	soap_default_double(soap, &this->mtrep5__RepositoryInfo2::Longitude);
}

void mtrep5__RepositoryInfo2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep5__RepositoryInfo2::CountryCode);
	soap_serialize_PointerTostd__string(soap, &this->mtrep5__RepositoryInfo2::City);
	this->mtrep5__RepositoryInfo::soap_serialize(soap);
#endif
}

int mtrep5__RepositoryInfo2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep5__RepositoryInfo2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep5__RepositoryInfo2(struct soap *soap, const char *tag, int id, const mtrep5__RepositoryInfo2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep5__RepositoryInfo2), "mtrep5:RepositoryInfo2"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep5:Country", -1, &a->mtrep5__RepositoryInfo::Country, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep5:Date", -1, &a->mtrep5__RepositoryInfo::Date, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep5:Delay", -1, &a->mtrep5__RepositoryInfo::Delay, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep5:Description", -1, &a->mtrep5__RepositoryInfo::Description, ""))
		return soap->error;
	if (soap_out_mtrep5__RepositoryIntegrity(soap, "mtrep5:Integrity", -1, &a->mtrep5__RepositoryInfo::Integrity, ""))
		return soap->error;
	if (soap_out_mtrep5__PackageLevel(soap, "mtrep5:Level", -1, &a->mtrep5__RepositoryInfo::Level, ""))
		return soap->error;
	if (soap_out_mtrep5__RepositoryStatus(soap, "mtrep5:Status", -1, &a->mtrep5__RepositoryInfo::Status, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep5:Url", -1, &a->mtrep5__RepositoryInfo::Url, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep5:Version", -1, &a->mtrep5__RepositoryInfo::Version, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep5:CountryCode", -1, &a->mtrep5__RepositoryInfo2::CountryCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep5:City", -1, &a->mtrep5__RepositoryInfo2::City, ""))
		return soap->error;
	if (soap_out_double(soap, "mtrep5:Latitude", -1, &a->mtrep5__RepositoryInfo2::Latitude, ""))
		return soap->error;
	if (soap_out_double(soap, "mtrep5:Longitude", -1, &a->mtrep5__RepositoryInfo2::Longitude, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep5__RepositoryInfo2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep5__RepositoryInfo2(soap, tag, this, type);
}

SOAP_FMAC3 mtrep5__RepositoryInfo2 * SOAP_FMAC4 soap_in_mtrep5__RepositoryInfo2(struct soap *soap, const char *tag, mtrep5__RepositoryInfo2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep5__RepositoryInfo2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep5__RepositoryInfo2, sizeof(mtrep5__RepositoryInfo2), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_mtrep5__RepositoryInfo2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (mtrep5__RepositoryInfo2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Country2 = 1;
	size_t soap_flag_Date2 = 1;
	size_t soap_flag_Delay2 = 1;
	size_t soap_flag_Description2 = 1;
	size_t soap_flag_Integrity2 = 1;
	size_t soap_flag_Level2 = 1;
	size_t soap_flag_Status2 = 1;
	size_t soap_flag_Url2 = 1;
	size_t soap_flag_Version2 = 1;
	size_t soap_flag_CountryCode1 = 1;
	size_t soap_flag_City1 = 1;
	size_t soap_flag_Latitude1 = 1;
	size_t soap_flag_Longitude1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Country2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep5:Country", &a->mtrep5__RepositoryInfo::Country, "xsd:string"))
				{	soap_flag_Country2--;
					continue;
				}
			if (soap_flag_Date2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep5:Date", &a->mtrep5__RepositoryInfo::Date, "xsd:int"))
				{	soap_flag_Date2--;
					continue;
				}
			if (soap_flag_Delay2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep5:Delay", &a->mtrep5__RepositoryInfo::Delay, "xsd:int"))
				{	soap_flag_Delay2--;
					continue;
				}
			if (soap_flag_Description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep5:Description", &a->mtrep5__RepositoryInfo::Description, "xsd:string"))
				{	soap_flag_Description2--;
					continue;
				}
			if (soap_flag_Integrity2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep5__RepositoryIntegrity(soap, "mtrep5:Integrity", &a->mtrep5__RepositoryInfo::Integrity, "mtrep5:RepositoryIntegrity"))
				{	soap_flag_Integrity2--;
					continue;
				}
			if (soap_flag_Level2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep5__PackageLevel(soap, "mtrep5:Level", &a->mtrep5__RepositoryInfo::Level, "mtrep5:PackageLevel"))
				{	soap_flag_Level2--;
					continue;
				}
			if (soap_flag_Status2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep5__RepositoryStatus(soap, "mtrep5:Status", &a->mtrep5__RepositoryInfo::Status, "mtrep5:RepositoryStatus"))
				{	soap_flag_Status2--;
					continue;
				}
			if (soap_flag_Url2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep5:Url", &a->mtrep5__RepositoryInfo::Url, "xsd:string"))
				{	soap_flag_Url2--;
					continue;
				}
			if (soap_flag_Version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep5:Version", &a->mtrep5__RepositoryInfo::Version, "xsd:int"))
				{	soap_flag_Version2--;
					continue;
				}
			if (soap_flag_CountryCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep5:CountryCode", &a->mtrep5__RepositoryInfo2::CountryCode, "xsd:string"))
				{	soap_flag_CountryCode1--;
					continue;
				}
			if (soap_flag_City1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep5:City", &a->mtrep5__RepositoryInfo2::City, "xsd:string"))
				{	soap_flag_City1--;
					continue;
				}
			if (soap_flag_Latitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "mtrep5:Latitude", &a->mtrep5__RepositoryInfo2::Latitude, "xsd:double"))
				{	soap_flag_Latitude1--;
					continue;
				}
			if (soap_flag_Longitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "mtrep5:Longitude", &a->mtrep5__RepositoryInfo2::Longitude, "xsd:double"))
				{	soap_flag_Longitude1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Date2 > 0 || soap_flag_Delay2 > 0 || soap_flag_Integrity2 > 0 || soap_flag_Level2 > 0 || soap_flag_Status2 > 0 || soap_flag_Version2 > 0 || soap_flag_Latitude1 > 0 || soap_flag_Longitude1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (mtrep5__RepositoryInfo2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep5__RepositoryInfo2, SOAP_TYPE_mtrep5__RepositoryInfo2, sizeof(mtrep5__RepositoryInfo2), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep5__RepositoryInfo2 * SOAP_FMAC2 repository_instantiate_mtrep5__RepositoryInfo2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep5__RepositoryInfo2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep5__RepositoryInfo2 *p;
	size_t k = sizeof(mtrep5__RepositoryInfo2);
	if (n < 0)
	{	p = SOAP_NEW(mtrep5__RepositoryInfo2);
		if (p)
			((mtrep5__RepositoryInfo2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep5__RepositoryInfo2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep5__RepositoryInfo2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep5__RepositoryInfo2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep5__RepositoryInfo2, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep5__RepositoryInfo2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep5:RepositoryInfo2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep5__RepositoryInfo2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep5__RepositoryInfo2(soap, this, tag, type);
}

SOAP_FMAC3 mtrep5__RepositoryInfo2 * SOAP_FMAC4 soap_get_mtrep5__RepositoryInfo2(struct soap *soap, mtrep5__RepositoryInfo2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep5__RepositoryInfo2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep5__ArrayOfRepositoryInfo2::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2(soap, &this->mtrep5__ArrayOfRepositoryInfo2::RepositoryInfo2);
	/* transient soap skipped */
}

void mtrep5__ArrayOfRepositoryInfo2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2(soap, &this->mtrep5__ArrayOfRepositoryInfo2::RepositoryInfo2);
#endif
}

int mtrep5__ArrayOfRepositoryInfo2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep5__ArrayOfRepositoryInfo2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep5__ArrayOfRepositoryInfo2(struct soap *soap, const char *tag, int id, const mtrep5__ArrayOfRepositoryInfo2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2(soap, "mtrep5:RepositoryInfo2", -1, &a->mtrep5__ArrayOfRepositoryInfo2::RepositoryInfo2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep5__ArrayOfRepositoryInfo2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep5__ArrayOfRepositoryInfo2(soap, tag, this, type);
}

SOAP_FMAC3 mtrep5__ArrayOfRepositoryInfo2 * SOAP_FMAC4 soap_in_mtrep5__ArrayOfRepositoryInfo2(struct soap *soap, const char *tag, mtrep5__ArrayOfRepositoryInfo2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep5__ArrayOfRepositoryInfo2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2, sizeof(mtrep5__ArrayOfRepositoryInfo2), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2(soap, "mtrep5:RepositoryInfo2", &a->mtrep5__ArrayOfRepositoryInfo2::RepositoryInfo2, "mtrep5:RepositoryInfo2"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mtrep5__ArrayOfRepositoryInfo2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2, SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2, sizeof(mtrep5__ArrayOfRepositoryInfo2), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep5__ArrayOfRepositoryInfo2 * SOAP_FMAC2 repository_instantiate_mtrep5__ArrayOfRepositoryInfo2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep5__ArrayOfRepositoryInfo2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep5__ArrayOfRepositoryInfo2 *p;
	size_t k = sizeof(mtrep5__ArrayOfRepositoryInfo2);
	if (n < 0)
	{	p = SOAP_NEW(mtrep5__ArrayOfRepositoryInfo2);
		if (p)
			((mtrep5__ArrayOfRepositoryInfo2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep5__ArrayOfRepositoryInfo2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep5__ArrayOfRepositoryInfo2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep5__ArrayOfRepositoryInfo2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep5__ArrayOfRepositoryInfo2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep5:ArrayOfRepositoryInfo2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep5__ArrayOfRepositoryInfo2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep5__ArrayOfRepositoryInfo2(soap, this, tag, type);
}

SOAP_FMAC3 mtrep5__ArrayOfRepositoryInfo2 * SOAP_FMAC4 soap_get_mtrep5__ArrayOfRepositoryInfo2(struct soap *soap, mtrep5__ArrayOfRepositoryInfo2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep5__ArrayOfRepositoryInfo2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep5__ClientInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep5__ClientInfo::Name = NULL;
	this->mtrep5__ClientInfo::Version = NULL;
	/* transient soap skipped */
}

void mtrep5__ClientInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep5__ClientInfo::Name);
	soap_serialize_PointerTostd__string(soap, &this->mtrep5__ClientInfo::Version);
#endif
}

int mtrep5__ClientInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep5__ClientInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep5__ClientInfo(struct soap *soap, const char *tag, int id, const mtrep5__ClientInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep5__ClientInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep5:Name", -1, &a->mtrep5__ClientInfo::Name, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep5:Version", -1, &a->mtrep5__ClientInfo::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep5__ClientInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep5__ClientInfo(soap, tag, this, type);
}

SOAP_FMAC3 mtrep5__ClientInfo * SOAP_FMAC4 soap_in_mtrep5__ClientInfo(struct soap *soap, const char *tag, mtrep5__ClientInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep5__ClientInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep5__ClientInfo, sizeof(mtrep5__ClientInfo), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep5:Name", &a->mtrep5__ClientInfo::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep5:Version", &a->mtrep5__ClientInfo::Version, "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mtrep5__ClientInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep5__ClientInfo, SOAP_TYPE_mtrep5__ClientInfo, sizeof(mtrep5__ClientInfo), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep5__ClientInfo * SOAP_FMAC2 repository_instantiate_mtrep5__ClientInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep5__ClientInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep5__ClientInfo *p;
	size_t k = sizeof(mtrep5__ClientInfo);
	if (n < 0)
	{	p = SOAP_NEW(mtrep5__ClientInfo);
		if (p)
			((mtrep5__ClientInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep5__ClientInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep5__ClientInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep5__ClientInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep5__ClientInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep5__ClientInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep5:ClientInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep5__ClientInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep5__ClientInfo(soap, this, tag, type);
}

SOAP_FMAC3 mtrep5__ClientInfo * SOAP_FMAC4 soap_get_mtrep5__ClientInfo(struct soap *soap, mtrep5__ClientInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep5__ClientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep4__VerifyRepositoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_mtrep4__VerifyRepositoryResponse::VerifyRepositoryResult);
	this->_mtrep4__VerifyRepositoryResponse::repositoryInfo = NULL;
	/* transient soap skipped */
}

void _mtrep4__VerifyRepositoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep4__RepositoryInfo(soap, &this->_mtrep4__VerifyRepositoryResponse::repositoryInfo);
#endif
}

int _mtrep4__VerifyRepositoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep4__VerifyRepositoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep4__VerifyRepositoryResponse(struct soap *soap, const char *tag, int id, const _mtrep4__VerifyRepositoryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep4__VerifyRepositoryResponse), type))
		return soap->error;
	soap_element_result(soap, "mtrep4:VerifyRepositoryResult");
	if (soap_out_bool(soap, "mtrep4:VerifyRepositoryResult", -1, &a->_mtrep4__VerifyRepositoryResponse::VerifyRepositoryResult, ""))
		return soap->error;
	if (soap_out_PointerTomtrep4__RepositoryInfo(soap, "mtrep4:repositoryInfo", -1, &a->_mtrep4__VerifyRepositoryResponse::repositoryInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep4__VerifyRepositoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep4__VerifyRepositoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep4__VerifyRepositoryResponse * SOAP_FMAC4 soap_in__mtrep4__VerifyRepositoryResponse(struct soap *soap, const char *tag, _mtrep4__VerifyRepositoryResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep4__VerifyRepositoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep4__VerifyRepositoryResponse, sizeof(_mtrep4__VerifyRepositoryResponse), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_VerifyRepositoryResult1 = 1;
	size_t soap_flag_repositoryInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VerifyRepositoryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep4:VerifyRepositoryResult", &a->_mtrep4__VerifyRepositoryResponse::VerifyRepositoryResult, "xsd:boolean"))
				{	soap_flag_VerifyRepositoryResult1--;
					continue;
				}
			if (soap_flag_repositoryInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep4__RepositoryInfo(soap, "mtrep4:repositoryInfo", &a->_mtrep4__VerifyRepositoryResponse::repositoryInfo, "mtrep4:RepositoryInfo"))
				{	soap_flag_repositoryInfo1--;
					continue;
				}
			soap_check_result(soap, "mtrep4:VerifyRepositoryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VerifyRepositoryResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_mtrep4__VerifyRepositoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep4__VerifyRepositoryResponse, SOAP_TYPE__mtrep4__VerifyRepositoryResponse, sizeof(_mtrep4__VerifyRepositoryResponse), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep4__VerifyRepositoryResponse * SOAP_FMAC2 repository_instantiate__mtrep4__VerifyRepositoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep4__VerifyRepositoryResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep4__VerifyRepositoryResponse *p;
	size_t k = sizeof(_mtrep4__VerifyRepositoryResponse);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep4__VerifyRepositoryResponse);
		if (p)
			((_mtrep4__VerifyRepositoryResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep4__VerifyRepositoryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep4__VerifyRepositoryResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep4__VerifyRepositoryResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep4__VerifyRepositoryResponse, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep4__VerifyRepositoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep4:VerifyRepositoryResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep4__VerifyRepositoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep4__VerifyRepositoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep4__VerifyRepositoryResponse * SOAP_FMAC4 soap_get__mtrep4__VerifyRepositoryResponse(struct soap *soap, _mtrep4__VerifyRepositoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep4__VerifyRepositoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep4__VerifyRepository::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep4__VerifyRepository::clientInfo = NULL;
	this->_mtrep4__VerifyRepository::url = NULL;
	/* transient soap skipped */
}

void _mtrep4__VerifyRepository::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep4__ClientInfo(soap, &this->_mtrep4__VerifyRepository::clientInfo);
	soap_serialize_PointerTostd__string(soap, &this->_mtrep4__VerifyRepository::url);
#endif
}

int _mtrep4__VerifyRepository::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep4__VerifyRepository(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep4__VerifyRepository(struct soap *soap, const char *tag, int id, const _mtrep4__VerifyRepository *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep4__VerifyRepository), type))
		return soap->error;
	if (soap_out_PointerTomtrep4__ClientInfo(soap, "mtrep4:clientInfo", -1, &a->_mtrep4__VerifyRepository::clientInfo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep4:url", -1, &a->_mtrep4__VerifyRepository::url, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep4__VerifyRepository::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep4__VerifyRepository(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep4__VerifyRepository * SOAP_FMAC4 soap_in__mtrep4__VerifyRepository(struct soap *soap, const char *tag, _mtrep4__VerifyRepository *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep4__VerifyRepository *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep4__VerifyRepository, sizeof(_mtrep4__VerifyRepository), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_clientInfo1 = 1;
	size_t soap_flag_url1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep4__ClientInfo(soap, "mtrep4:clientInfo", &a->_mtrep4__VerifyRepository::clientInfo, "mtrep4:ClientInfo"))
				{	soap_flag_clientInfo1--;
					continue;
				}
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep4:url", &a->_mtrep4__VerifyRepository::url, "xsd:string"))
				{	soap_flag_url1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep4__VerifyRepository *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep4__VerifyRepository, SOAP_TYPE__mtrep4__VerifyRepository, sizeof(_mtrep4__VerifyRepository), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep4__VerifyRepository * SOAP_FMAC2 repository_instantiate__mtrep4__VerifyRepository(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep4__VerifyRepository(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep4__VerifyRepository *p;
	size_t k = sizeof(_mtrep4__VerifyRepository);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep4__VerifyRepository);
		if (p)
			((_mtrep4__VerifyRepository*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep4__VerifyRepository, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep4__VerifyRepository*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep4__VerifyRepository location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep4__VerifyRepository, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep4__VerifyRepository::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep4:VerifyRepository", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep4__VerifyRepository::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep4__VerifyRepository(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep4__VerifyRepository * SOAP_FMAC4 soap_get__mtrep4__VerifyRepository(struct soap *soap, _mtrep4__VerifyRepository *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep4__VerifyRepository(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep4__RepositoryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep4__RepositoryInfo::Country = NULL;
	soap_default_int(soap, &this->mtrep4__RepositoryInfo::Date);
	soap_default_int(soap, &this->mtrep4__RepositoryInfo::Delay);
	this->mtrep4__RepositoryInfo::Description = NULL;
	soap_default_mtrep4__RepositoryIntegrity(soap, &this->mtrep4__RepositoryInfo::Integrity);
	soap_default_mtrep4__PackageLevel(soap, &this->mtrep4__RepositoryInfo::Level);
	soap_default_mtrep4__RepositoryStatus(soap, &this->mtrep4__RepositoryInfo::Status);
	this->mtrep4__RepositoryInfo::Url = NULL;
	soap_default_int(soap, &this->mtrep4__RepositoryInfo::Version);
	/* transient soap skipped */
}

void mtrep4__RepositoryInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep4__RepositoryInfo::Country);
	soap_serialize_PointerTostd__string(soap, &this->mtrep4__RepositoryInfo::Description);
	soap_serialize_PointerTostd__string(soap, &this->mtrep4__RepositoryInfo::Url);
#endif
}

int mtrep4__RepositoryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep4__RepositoryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep4__RepositoryInfo(struct soap *soap, const char *tag, int id, const mtrep4__RepositoryInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep4__RepositoryInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep4:Country", -1, &a->mtrep4__RepositoryInfo::Country, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep4:Date", -1, &a->mtrep4__RepositoryInfo::Date, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep4:Delay", -1, &a->mtrep4__RepositoryInfo::Delay, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep4:Description", -1, &a->mtrep4__RepositoryInfo::Description, ""))
		return soap->error;
	if (soap_out_mtrep4__RepositoryIntegrity(soap, "mtrep4:Integrity", -1, &a->mtrep4__RepositoryInfo::Integrity, ""))
		return soap->error;
	if (soap_out_mtrep4__PackageLevel(soap, "mtrep4:Level", -1, &a->mtrep4__RepositoryInfo::Level, ""))
		return soap->error;
	if (soap_out_mtrep4__RepositoryStatus(soap, "mtrep4:Status", -1, &a->mtrep4__RepositoryInfo::Status, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep4:Url", -1, &a->mtrep4__RepositoryInfo::Url, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep4:Version", -1, &a->mtrep4__RepositoryInfo::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep4__RepositoryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep4__RepositoryInfo(soap, tag, this, type);
}

SOAP_FMAC3 mtrep4__RepositoryInfo * SOAP_FMAC4 soap_in_mtrep4__RepositoryInfo(struct soap *soap, const char *tag, mtrep4__RepositoryInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep4__RepositoryInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep4__RepositoryInfo, sizeof(mtrep4__RepositoryInfo), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Country1 = 1;
	size_t soap_flag_Date1 = 1;
	size_t soap_flag_Delay1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_Integrity1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_Url1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep4:Country", &a->mtrep4__RepositoryInfo::Country, "xsd:string"))
				{	soap_flag_Country1--;
					continue;
				}
			if (soap_flag_Date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep4:Date", &a->mtrep4__RepositoryInfo::Date, "xsd:int"))
				{	soap_flag_Date1--;
					continue;
				}
			if (soap_flag_Delay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep4:Delay", &a->mtrep4__RepositoryInfo::Delay, "xsd:int"))
				{	soap_flag_Delay1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep4:Description", &a->mtrep4__RepositoryInfo::Description, "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_Integrity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep4__RepositoryIntegrity(soap, "mtrep4:Integrity", &a->mtrep4__RepositoryInfo::Integrity, "mtrep4:RepositoryIntegrity"))
				{	soap_flag_Integrity1--;
					continue;
				}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep4__PackageLevel(soap, "mtrep4:Level", &a->mtrep4__RepositoryInfo::Level, "mtrep4:PackageLevel"))
				{	soap_flag_Level1--;
					continue;
				}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep4__RepositoryStatus(soap, "mtrep4:Status", &a->mtrep4__RepositoryInfo::Status, "mtrep4:RepositoryStatus"))
				{	soap_flag_Status1--;
					continue;
				}
			if (soap_flag_Url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep4:Url", &a->mtrep4__RepositoryInfo::Url, "xsd:string"))
				{	soap_flag_Url1--;
					continue;
				}
			if (soap_flag_Version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep4:Version", &a->mtrep4__RepositoryInfo::Version, "xsd:int"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Date1 > 0 || soap_flag_Delay1 > 0 || soap_flag_Integrity1 > 0 || soap_flag_Level1 > 0 || soap_flag_Status1 > 0 || soap_flag_Version1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (mtrep4__RepositoryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep4__RepositoryInfo, SOAP_TYPE_mtrep4__RepositoryInfo, sizeof(mtrep4__RepositoryInfo), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep4__RepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep4__RepositoryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep4__RepositoryInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep4__RepositoryInfo *p;
	size_t k = sizeof(mtrep4__RepositoryInfo);
	if (n < 0)
	{	p = SOAP_NEW(mtrep4__RepositoryInfo);
		if (p)
			((mtrep4__RepositoryInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep4__RepositoryInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep4__RepositoryInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep4__RepositoryInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep4__RepositoryInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep4__RepositoryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep4:RepositoryInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep4__RepositoryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep4__RepositoryInfo(soap, this, tag, type);
}

SOAP_FMAC3 mtrep4__RepositoryInfo * SOAP_FMAC4 soap_get_mtrep4__RepositoryInfo(struct soap *soap, mtrep4__RepositoryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep4__RepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep4__ClientInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep4__ClientInfo::Name = NULL;
	this->mtrep4__ClientInfo::Version = NULL;
	/* transient soap skipped */
}

void mtrep4__ClientInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep4__ClientInfo::Name);
	soap_serialize_PointerTostd__string(soap, &this->mtrep4__ClientInfo::Version);
#endif
}

int mtrep4__ClientInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep4__ClientInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep4__ClientInfo(struct soap *soap, const char *tag, int id, const mtrep4__ClientInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep4__ClientInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep4:Name", -1, &a->mtrep4__ClientInfo::Name, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep4:Version", -1, &a->mtrep4__ClientInfo::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep4__ClientInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep4__ClientInfo(soap, tag, this, type);
}

SOAP_FMAC3 mtrep4__ClientInfo * SOAP_FMAC4 soap_in_mtrep4__ClientInfo(struct soap *soap, const char *tag, mtrep4__ClientInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep4__ClientInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep4__ClientInfo, sizeof(mtrep4__ClientInfo), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep4:Name", &a->mtrep4__ClientInfo::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep4:Version", &a->mtrep4__ClientInfo::Version, "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mtrep4__ClientInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep4__ClientInfo, SOAP_TYPE_mtrep4__ClientInfo, sizeof(mtrep4__ClientInfo), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep4__ClientInfo * SOAP_FMAC2 repository_instantiate_mtrep4__ClientInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep4__ClientInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep4__ClientInfo *p;
	size_t k = sizeof(mtrep4__ClientInfo);
	if (n < 0)
	{	p = SOAP_NEW(mtrep4__ClientInfo);
		if (p)
			((mtrep4__ClientInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep4__ClientInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep4__ClientInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep4__ClientInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep4__ClientInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep4__ClientInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep4:ClientInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep4__ClientInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep4__ClientInfo(soap, this, tag, type);
}

SOAP_FMAC3 mtrep4__ClientInfo * SOAP_FMAC4 soap_get_mtrep4__ClientInfo(struct soap *soap, mtrep4__ClientInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep4__ClientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep3__TryGetRepositoryInfo2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_mtrep3__TryGetRepositoryInfo2Response::TryGetRepositoryInfo2Result);
	this->_mtrep3__TryGetRepositoryInfo2Response::repositoryInfo = NULL;
	/* transient soap skipped */
}

void _mtrep3__TryGetRepositoryInfo2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep3__RepositoryInfo(soap, &this->_mtrep3__TryGetRepositoryInfo2Response::repositoryInfo);
#endif
}

int _mtrep3__TryGetRepositoryInfo2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep3__TryGetRepositoryInfo2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep3__TryGetRepositoryInfo2Response(struct soap *soap, const char *tag, int id, const _mtrep3__TryGetRepositoryInfo2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response), type))
		return soap->error;
	soap_element_result(soap, "mtrep3:TryGetRepositoryInfo2Result");
	if (soap_out_bool(soap, "mtrep3:TryGetRepositoryInfo2Result", -1, &a->_mtrep3__TryGetRepositoryInfo2Response::TryGetRepositoryInfo2Result, ""))
		return soap->error;
	if (soap_out_PointerTomtrep3__RepositoryInfo(soap, "mtrep3:repositoryInfo", -1, &a->_mtrep3__TryGetRepositoryInfo2Response::repositoryInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep3__TryGetRepositoryInfo2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep3__TryGetRepositoryInfo2Response(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep3__TryGetRepositoryInfo2Response * SOAP_FMAC4 soap_in__mtrep3__TryGetRepositoryInfo2Response(struct soap *soap, const char *tag, _mtrep3__TryGetRepositoryInfo2Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep3__TryGetRepositoryInfo2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response, sizeof(_mtrep3__TryGetRepositoryInfo2Response), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TryGetRepositoryInfo2Result1 = 1;
	size_t soap_flag_repositoryInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TryGetRepositoryInfo2Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep3:TryGetRepositoryInfo2Result", &a->_mtrep3__TryGetRepositoryInfo2Response::TryGetRepositoryInfo2Result, "xsd:boolean"))
				{	soap_flag_TryGetRepositoryInfo2Result1--;
					continue;
				}
			if (soap_flag_repositoryInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep3__RepositoryInfo(soap, "mtrep3:repositoryInfo", &a->_mtrep3__TryGetRepositoryInfo2Response::repositoryInfo, "mtrep3:RepositoryInfo"))
				{	soap_flag_repositoryInfo1--;
					continue;
				}
			soap_check_result(soap, "mtrep3:TryGetRepositoryInfo2Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TryGetRepositoryInfo2Result1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_mtrep3__TryGetRepositoryInfo2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response, SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response, sizeof(_mtrep3__TryGetRepositoryInfo2Response), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep3__TryGetRepositoryInfo2Response * SOAP_FMAC2 repository_instantiate__mtrep3__TryGetRepositoryInfo2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep3__TryGetRepositoryInfo2Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep3__TryGetRepositoryInfo2Response *p;
	size_t k = sizeof(_mtrep3__TryGetRepositoryInfo2Response);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep3__TryGetRepositoryInfo2Response);
		if (p)
			((_mtrep3__TryGetRepositoryInfo2Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep3__TryGetRepositoryInfo2Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep3__TryGetRepositoryInfo2Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep3__TryGetRepositoryInfo2Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep3__TryGetRepositoryInfo2Response, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep3__TryGetRepositoryInfo2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep3:TryGetRepositoryInfo2Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep3__TryGetRepositoryInfo2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep3__TryGetRepositoryInfo2Response(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep3__TryGetRepositoryInfo2Response * SOAP_FMAC4 soap_get__mtrep3__TryGetRepositoryInfo2Response(struct soap *soap, _mtrep3__TryGetRepositoryInfo2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep3__TryGetRepositoryInfo2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep3__TryGetRepositoryInfo2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep3__TryGetRepositoryInfo2::clientInfo = NULL;
	this->_mtrep3__TryGetRepositoryInfo2::url = NULL;
	/* transient soap skipped */
}

void _mtrep3__TryGetRepositoryInfo2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep3__ClientInfo(soap, &this->_mtrep3__TryGetRepositoryInfo2::clientInfo);
	soap_serialize_PointerTostd__string(soap, &this->_mtrep3__TryGetRepositoryInfo2::url);
#endif
}

int _mtrep3__TryGetRepositoryInfo2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep3__TryGetRepositoryInfo2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep3__TryGetRepositoryInfo2(struct soap *soap, const char *tag, int id, const _mtrep3__TryGetRepositoryInfo2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep3__TryGetRepositoryInfo2), type))
		return soap->error;
	if (soap_out_PointerTomtrep3__ClientInfo(soap, "mtrep3:clientInfo", -1, &a->_mtrep3__TryGetRepositoryInfo2::clientInfo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep3:url", -1, &a->_mtrep3__TryGetRepositoryInfo2::url, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep3__TryGetRepositoryInfo2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep3__TryGetRepositoryInfo2(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep3__TryGetRepositoryInfo2 * SOAP_FMAC4 soap_in__mtrep3__TryGetRepositoryInfo2(struct soap *soap, const char *tag, _mtrep3__TryGetRepositoryInfo2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep3__TryGetRepositoryInfo2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep3__TryGetRepositoryInfo2, sizeof(_mtrep3__TryGetRepositoryInfo2), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_clientInfo1 = 1;
	size_t soap_flag_url1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep3__ClientInfo(soap, "mtrep3:clientInfo", &a->_mtrep3__TryGetRepositoryInfo2::clientInfo, "mtrep3:ClientInfo"))
				{	soap_flag_clientInfo1--;
					continue;
				}
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep3:url", &a->_mtrep3__TryGetRepositoryInfo2::url, "xsd:string"))
				{	soap_flag_url1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep3__TryGetRepositoryInfo2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep3__TryGetRepositoryInfo2, SOAP_TYPE__mtrep3__TryGetRepositoryInfo2, sizeof(_mtrep3__TryGetRepositoryInfo2), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep3__TryGetRepositoryInfo2 * SOAP_FMAC2 repository_instantiate__mtrep3__TryGetRepositoryInfo2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep3__TryGetRepositoryInfo2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep3__TryGetRepositoryInfo2 *p;
	size_t k = sizeof(_mtrep3__TryGetRepositoryInfo2);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep3__TryGetRepositoryInfo2);
		if (p)
			((_mtrep3__TryGetRepositoryInfo2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep3__TryGetRepositoryInfo2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep3__TryGetRepositoryInfo2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep3__TryGetRepositoryInfo2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep3__TryGetRepositoryInfo2, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep3__TryGetRepositoryInfo2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep3:TryGetRepositoryInfo2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep3__TryGetRepositoryInfo2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep3__TryGetRepositoryInfo2(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep3__TryGetRepositoryInfo2 * SOAP_FMAC4 soap_get__mtrep3__TryGetRepositoryInfo2(struct soap *soap, _mtrep3__TryGetRepositoryInfo2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep3__TryGetRepositoryInfo2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep3__PickRepository2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep3__PickRepository2Response::PickRepository2Result = NULL;
	/* transient soap skipped */
}

void _mtrep3__PickRepository2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep3__RepositoryInfo(soap, &this->_mtrep3__PickRepository2Response::PickRepository2Result);
#endif
}

int _mtrep3__PickRepository2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep3__PickRepository2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep3__PickRepository2Response(struct soap *soap, const char *tag, int id, const _mtrep3__PickRepository2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep3__PickRepository2Response), type))
		return soap->error;
	if (a->PickRepository2Result)
		soap_element_result(soap, "mtrep3:PickRepository2Result");
	if (soap_out_PointerTomtrep3__RepositoryInfo(soap, "mtrep3:PickRepository2Result", -1, &a->_mtrep3__PickRepository2Response::PickRepository2Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep3__PickRepository2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep3__PickRepository2Response(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep3__PickRepository2Response * SOAP_FMAC4 soap_in__mtrep3__PickRepository2Response(struct soap *soap, const char *tag, _mtrep3__PickRepository2Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep3__PickRepository2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep3__PickRepository2Response, sizeof(_mtrep3__PickRepository2Response), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PickRepository2Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PickRepository2Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep3__RepositoryInfo(soap, "mtrep3:PickRepository2Result", &a->_mtrep3__PickRepository2Response::PickRepository2Result, "mtrep3:RepositoryInfo"))
				{	soap_flag_PickRepository2Result1--;
					continue;
				}
			soap_check_result(soap, "mtrep3:PickRepository2Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep3__PickRepository2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep3__PickRepository2Response, SOAP_TYPE__mtrep3__PickRepository2Response, sizeof(_mtrep3__PickRepository2Response), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep3__PickRepository2Response * SOAP_FMAC2 repository_instantiate__mtrep3__PickRepository2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep3__PickRepository2Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep3__PickRepository2Response *p;
	size_t k = sizeof(_mtrep3__PickRepository2Response);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep3__PickRepository2Response);
		if (p)
			((_mtrep3__PickRepository2Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep3__PickRepository2Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep3__PickRepository2Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep3__PickRepository2Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep3__PickRepository2Response, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep3__PickRepository2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep3:PickRepository2Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep3__PickRepository2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep3__PickRepository2Response(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep3__PickRepository2Response * SOAP_FMAC4 soap_get__mtrep3__PickRepository2Response(struct soap *soap, _mtrep3__PickRepository2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep3__PickRepository2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep3__PickRepository2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep3__PickRepository2::clientInfo = NULL;
	/* transient soap skipped */
}

void _mtrep3__PickRepository2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep3__ClientInfo(soap, &this->_mtrep3__PickRepository2::clientInfo);
#endif
}

int _mtrep3__PickRepository2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep3__PickRepository2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep3__PickRepository2(struct soap *soap, const char *tag, int id, const _mtrep3__PickRepository2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep3__PickRepository2), type))
		return soap->error;
	if (soap_out_PointerTomtrep3__ClientInfo(soap, "mtrep3:clientInfo", -1, &a->_mtrep3__PickRepository2::clientInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep3__PickRepository2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep3__PickRepository2(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep3__PickRepository2 * SOAP_FMAC4 soap_in__mtrep3__PickRepository2(struct soap *soap, const char *tag, _mtrep3__PickRepository2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep3__PickRepository2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep3__PickRepository2, sizeof(_mtrep3__PickRepository2), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_clientInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep3__ClientInfo(soap, "mtrep3:clientInfo", &a->_mtrep3__PickRepository2::clientInfo, "mtrep3:ClientInfo"))
				{	soap_flag_clientInfo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep3__PickRepository2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep3__PickRepository2, SOAP_TYPE__mtrep3__PickRepository2, sizeof(_mtrep3__PickRepository2), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep3__PickRepository2 * SOAP_FMAC2 repository_instantiate__mtrep3__PickRepository2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep3__PickRepository2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep3__PickRepository2 *p;
	size_t k = sizeof(_mtrep3__PickRepository2);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep3__PickRepository2);
		if (p)
			((_mtrep3__PickRepository2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep3__PickRepository2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep3__PickRepository2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep3__PickRepository2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep3__PickRepository2, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep3__PickRepository2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep3:PickRepository2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep3__PickRepository2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep3__PickRepository2(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep3__PickRepository2 * SOAP_FMAC4 soap_get__mtrep3__PickRepository2(struct soap *soap, _mtrep3__PickRepository2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep3__PickRepository2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep3__GetRepositories2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep3__GetRepositories2Response::GetRepositories2Result = NULL;
	/* transient soap skipped */
}

void _mtrep3__GetRepositories2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep3__ArrayOfRepositoryInfo(soap, &this->_mtrep3__GetRepositories2Response::GetRepositories2Result);
#endif
}

int _mtrep3__GetRepositories2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep3__GetRepositories2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep3__GetRepositories2Response(struct soap *soap, const char *tag, int id, const _mtrep3__GetRepositories2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep3__GetRepositories2Response), type))
		return soap->error;
	if (a->GetRepositories2Result)
		soap_element_result(soap, "mtrep3:GetRepositories2Result");
	if (soap_out_PointerTomtrep3__ArrayOfRepositoryInfo(soap, "mtrep3:GetRepositories2Result", -1, &a->_mtrep3__GetRepositories2Response::GetRepositories2Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep3__GetRepositories2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep3__GetRepositories2Response(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep3__GetRepositories2Response * SOAP_FMAC4 soap_in__mtrep3__GetRepositories2Response(struct soap *soap, const char *tag, _mtrep3__GetRepositories2Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep3__GetRepositories2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep3__GetRepositories2Response, sizeof(_mtrep3__GetRepositories2Response), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetRepositories2Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetRepositories2Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep3__ArrayOfRepositoryInfo(soap, "mtrep3:GetRepositories2Result", &a->_mtrep3__GetRepositories2Response::GetRepositories2Result, "mtrep3:ArrayOfRepositoryInfo"))
				{	soap_flag_GetRepositories2Result1--;
					continue;
				}
			soap_check_result(soap, "mtrep3:GetRepositories2Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep3__GetRepositories2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep3__GetRepositories2Response, SOAP_TYPE__mtrep3__GetRepositories2Response, sizeof(_mtrep3__GetRepositories2Response), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep3__GetRepositories2Response * SOAP_FMAC2 repository_instantiate__mtrep3__GetRepositories2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep3__GetRepositories2Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep3__GetRepositories2Response *p;
	size_t k = sizeof(_mtrep3__GetRepositories2Response);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep3__GetRepositories2Response);
		if (p)
			((_mtrep3__GetRepositories2Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep3__GetRepositories2Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep3__GetRepositories2Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep3__GetRepositories2Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep3__GetRepositories2Response, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep3__GetRepositories2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep3:GetRepositories2Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep3__GetRepositories2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep3__GetRepositories2Response(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep3__GetRepositories2Response * SOAP_FMAC4 soap_get__mtrep3__GetRepositories2Response(struct soap *soap, _mtrep3__GetRepositories2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep3__GetRepositories2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep3__GetRepositories2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep3__GetRepositories2::clientInfo = NULL;
	soap_default_bool(soap, &this->_mtrep3__GetRepositories2::onlyOnline);
	soap_default_bool(soap, &this->_mtrep3__GetRepositories2::noCorrupted);
	soap_default_int(soap, &this->_mtrep3__GetRepositories2::maxDelay);
	/* transient soap skipped */
}

void _mtrep3__GetRepositories2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep3__ClientInfo(soap, &this->_mtrep3__GetRepositories2::clientInfo);
#endif
}

int _mtrep3__GetRepositories2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep3__GetRepositories2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep3__GetRepositories2(struct soap *soap, const char *tag, int id, const _mtrep3__GetRepositories2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep3__GetRepositories2), type))
		return soap->error;
	if (soap_out_PointerTomtrep3__ClientInfo(soap, "mtrep3:clientInfo", -1, &a->_mtrep3__GetRepositories2::clientInfo, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep3:onlyOnline", -1, &a->_mtrep3__GetRepositories2::onlyOnline, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep3:noCorrupted", -1, &a->_mtrep3__GetRepositories2::noCorrupted, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep3:maxDelay", -1, &a->_mtrep3__GetRepositories2::maxDelay, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep3__GetRepositories2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep3__GetRepositories2(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep3__GetRepositories2 * SOAP_FMAC4 soap_in__mtrep3__GetRepositories2(struct soap *soap, const char *tag, _mtrep3__GetRepositories2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep3__GetRepositories2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep3__GetRepositories2, sizeof(_mtrep3__GetRepositories2), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_clientInfo1 = 1;
	size_t soap_flag_onlyOnline1 = 1;
	size_t soap_flag_noCorrupted1 = 1;
	size_t soap_flag_maxDelay1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep3__ClientInfo(soap, "mtrep3:clientInfo", &a->_mtrep3__GetRepositories2::clientInfo, "mtrep3:ClientInfo"))
				{	soap_flag_clientInfo1--;
					continue;
				}
			if (soap_flag_onlyOnline1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep3:onlyOnline", &a->_mtrep3__GetRepositories2::onlyOnline, "xsd:boolean"))
				{	soap_flag_onlyOnline1--;
					continue;
				}
			if (soap_flag_noCorrupted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep3:noCorrupted", &a->_mtrep3__GetRepositories2::noCorrupted, "xsd:boolean"))
				{	soap_flag_noCorrupted1--;
					continue;
				}
			if (soap_flag_maxDelay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep3:maxDelay", &a->_mtrep3__GetRepositories2::maxDelay, "xsd:int"))
				{	soap_flag_maxDelay1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_onlyOnline1 > 0 || soap_flag_noCorrupted1 > 0 || soap_flag_maxDelay1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_mtrep3__GetRepositories2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep3__GetRepositories2, SOAP_TYPE__mtrep3__GetRepositories2, sizeof(_mtrep3__GetRepositories2), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep3__GetRepositories2 * SOAP_FMAC2 repository_instantiate__mtrep3__GetRepositories2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep3__GetRepositories2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep3__GetRepositories2 *p;
	size_t k = sizeof(_mtrep3__GetRepositories2);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep3__GetRepositories2);
		if (p)
			((_mtrep3__GetRepositories2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep3__GetRepositories2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep3__GetRepositories2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep3__GetRepositories2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep3__GetRepositories2, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep3__GetRepositories2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep3:GetRepositories2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep3__GetRepositories2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep3__GetRepositories2(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep3__GetRepositories2 * SOAP_FMAC4 soap_get__mtrep3__GetRepositories2(struct soap *soap, _mtrep3__GetRepositories2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep3__GetRepositories2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep3__RepositoryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep3__RepositoryInfo::Country = NULL;
	soap_default_int(soap, &this->mtrep3__RepositoryInfo::Date);
	soap_default_int(soap, &this->mtrep3__RepositoryInfo::Delay);
	this->mtrep3__RepositoryInfo::Description = NULL;
	soap_default_mtrep3__RepositoryIntegrity(soap, &this->mtrep3__RepositoryInfo::Integrity);
	soap_default_mtrep3__PackageLevel(soap, &this->mtrep3__RepositoryInfo::Level);
	soap_default_mtrep3__RepositoryStatus(soap, &this->mtrep3__RepositoryInfo::Status);
	this->mtrep3__RepositoryInfo::Url = NULL;
	soap_default_int(soap, &this->mtrep3__RepositoryInfo::Version);
	/* transient soap skipped */
}

void mtrep3__RepositoryInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep3__RepositoryInfo::Country);
	soap_serialize_PointerTostd__string(soap, &this->mtrep3__RepositoryInfo::Description);
	soap_serialize_PointerTostd__string(soap, &this->mtrep3__RepositoryInfo::Url);
#endif
}

int mtrep3__RepositoryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep3__RepositoryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep3__RepositoryInfo(struct soap *soap, const char *tag, int id, const mtrep3__RepositoryInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep3__RepositoryInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep3:Country", -1, &a->mtrep3__RepositoryInfo::Country, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep3:Date", -1, &a->mtrep3__RepositoryInfo::Date, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep3:Delay", -1, &a->mtrep3__RepositoryInfo::Delay, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep3:Description", -1, &a->mtrep3__RepositoryInfo::Description, ""))
		return soap->error;
	if (soap_out_mtrep3__RepositoryIntegrity(soap, "mtrep3:Integrity", -1, &a->mtrep3__RepositoryInfo::Integrity, ""))
		return soap->error;
	if (soap_out_mtrep3__PackageLevel(soap, "mtrep3:Level", -1, &a->mtrep3__RepositoryInfo::Level, ""))
		return soap->error;
	if (soap_out_mtrep3__RepositoryStatus(soap, "mtrep3:Status", -1, &a->mtrep3__RepositoryInfo::Status, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep3:Url", -1, &a->mtrep3__RepositoryInfo::Url, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep3:Version", -1, &a->mtrep3__RepositoryInfo::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep3__RepositoryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep3__RepositoryInfo(soap, tag, this, type);
}

SOAP_FMAC3 mtrep3__RepositoryInfo * SOAP_FMAC4 soap_in_mtrep3__RepositoryInfo(struct soap *soap, const char *tag, mtrep3__RepositoryInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep3__RepositoryInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep3__RepositoryInfo, sizeof(mtrep3__RepositoryInfo), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Country1 = 1;
	size_t soap_flag_Date1 = 1;
	size_t soap_flag_Delay1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_Integrity1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_Url1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep3:Country", &a->mtrep3__RepositoryInfo::Country, "xsd:string"))
				{	soap_flag_Country1--;
					continue;
				}
			if (soap_flag_Date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep3:Date", &a->mtrep3__RepositoryInfo::Date, "xsd:int"))
				{	soap_flag_Date1--;
					continue;
				}
			if (soap_flag_Delay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep3:Delay", &a->mtrep3__RepositoryInfo::Delay, "xsd:int"))
				{	soap_flag_Delay1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep3:Description", &a->mtrep3__RepositoryInfo::Description, "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_Integrity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep3__RepositoryIntegrity(soap, "mtrep3:Integrity", &a->mtrep3__RepositoryInfo::Integrity, "mtrep3:RepositoryIntegrity"))
				{	soap_flag_Integrity1--;
					continue;
				}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep3__PackageLevel(soap, "mtrep3:Level", &a->mtrep3__RepositoryInfo::Level, "mtrep3:PackageLevel"))
				{	soap_flag_Level1--;
					continue;
				}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep3__RepositoryStatus(soap, "mtrep3:Status", &a->mtrep3__RepositoryInfo::Status, "mtrep3:RepositoryStatus"))
				{	soap_flag_Status1--;
					continue;
				}
			if (soap_flag_Url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep3:Url", &a->mtrep3__RepositoryInfo::Url, "xsd:string"))
				{	soap_flag_Url1--;
					continue;
				}
			if (soap_flag_Version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep3:Version", &a->mtrep3__RepositoryInfo::Version, "xsd:int"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Date1 > 0 || soap_flag_Delay1 > 0 || soap_flag_Integrity1 > 0 || soap_flag_Level1 > 0 || soap_flag_Status1 > 0 || soap_flag_Version1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (mtrep3__RepositoryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep3__RepositoryInfo, SOAP_TYPE_mtrep3__RepositoryInfo, sizeof(mtrep3__RepositoryInfo), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep3__RepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep3__RepositoryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep3__RepositoryInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep3__RepositoryInfo *p;
	size_t k = sizeof(mtrep3__RepositoryInfo);
	if (n < 0)
	{	p = SOAP_NEW(mtrep3__RepositoryInfo);
		if (p)
			((mtrep3__RepositoryInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep3__RepositoryInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep3__RepositoryInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep3__RepositoryInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep3__RepositoryInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep3__RepositoryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep3:RepositoryInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep3__RepositoryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep3__RepositoryInfo(soap, this, tag, type);
}

SOAP_FMAC3 mtrep3__RepositoryInfo * SOAP_FMAC4 soap_get_mtrep3__RepositoryInfo(struct soap *soap, mtrep3__RepositoryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep3__RepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep3__ArrayOfRepositoryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo(soap, &this->mtrep3__ArrayOfRepositoryInfo::RepositoryInfo);
	/* transient soap skipped */
}

void mtrep3__ArrayOfRepositoryInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo(soap, &this->mtrep3__ArrayOfRepositoryInfo::RepositoryInfo);
#endif
}

int mtrep3__ArrayOfRepositoryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep3__ArrayOfRepositoryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep3__ArrayOfRepositoryInfo(struct soap *soap, const char *tag, int id, const mtrep3__ArrayOfRepositoryInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo(soap, "mtrep3:RepositoryInfo", -1, &a->mtrep3__ArrayOfRepositoryInfo::RepositoryInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep3__ArrayOfRepositoryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep3__ArrayOfRepositoryInfo(soap, tag, this, type);
}

SOAP_FMAC3 mtrep3__ArrayOfRepositoryInfo * SOAP_FMAC4 soap_in_mtrep3__ArrayOfRepositoryInfo(struct soap *soap, const char *tag, mtrep3__ArrayOfRepositoryInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep3__ArrayOfRepositoryInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo, sizeof(mtrep3__ArrayOfRepositoryInfo), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo(soap, "mtrep3:RepositoryInfo", &a->mtrep3__ArrayOfRepositoryInfo::RepositoryInfo, "mtrep3:RepositoryInfo"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mtrep3__ArrayOfRepositoryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo, SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo, sizeof(mtrep3__ArrayOfRepositoryInfo), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep3__ArrayOfRepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep3__ArrayOfRepositoryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep3__ArrayOfRepositoryInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep3__ArrayOfRepositoryInfo *p;
	size_t k = sizeof(mtrep3__ArrayOfRepositoryInfo);
	if (n < 0)
	{	p = SOAP_NEW(mtrep3__ArrayOfRepositoryInfo);
		if (p)
			((mtrep3__ArrayOfRepositoryInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep3__ArrayOfRepositoryInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep3__ArrayOfRepositoryInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep3__ArrayOfRepositoryInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep3__ArrayOfRepositoryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep3:ArrayOfRepositoryInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep3__ArrayOfRepositoryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep3__ArrayOfRepositoryInfo(soap, this, tag, type);
}

SOAP_FMAC3 mtrep3__ArrayOfRepositoryInfo * SOAP_FMAC4 soap_get_mtrep3__ArrayOfRepositoryInfo(struct soap *soap, mtrep3__ArrayOfRepositoryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep3__ArrayOfRepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep3__ClientInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep3__ClientInfo::Name = NULL;
	this->mtrep3__ClientInfo::Version = NULL;
	/* transient soap skipped */
}

void mtrep3__ClientInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep3__ClientInfo::Name);
	soap_serialize_PointerTostd__string(soap, &this->mtrep3__ClientInfo::Version);
#endif
}

int mtrep3__ClientInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep3__ClientInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep3__ClientInfo(struct soap *soap, const char *tag, int id, const mtrep3__ClientInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep3__ClientInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep3:Name", -1, &a->mtrep3__ClientInfo::Name, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep3:Version", -1, &a->mtrep3__ClientInfo::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep3__ClientInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep3__ClientInfo(soap, tag, this, type);
}

SOAP_FMAC3 mtrep3__ClientInfo * SOAP_FMAC4 soap_in_mtrep3__ClientInfo(struct soap *soap, const char *tag, mtrep3__ClientInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep3__ClientInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep3__ClientInfo, sizeof(mtrep3__ClientInfo), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep3:Name", &a->mtrep3__ClientInfo::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep3:Version", &a->mtrep3__ClientInfo::Version, "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mtrep3__ClientInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep3__ClientInfo, SOAP_TYPE_mtrep3__ClientInfo, sizeof(mtrep3__ClientInfo), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep3__ClientInfo * SOAP_FMAC2 repository_instantiate_mtrep3__ClientInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep3__ClientInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep3__ClientInfo *p;
	size_t k = sizeof(mtrep3__ClientInfo);
	if (n < 0)
	{	p = SOAP_NEW(mtrep3__ClientInfo);
		if (p)
			((mtrep3__ClientInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep3__ClientInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep3__ClientInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep3__ClientInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep3__ClientInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep3__ClientInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep3:ClientInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep3__ClientInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep3__ClientInfo(soap, this, tag, type);
}

SOAP_FMAC3 mtrep3__ClientInfo * SOAP_FMAC4 soap_get_mtrep3__ClientInfo(struct soap *soap, mtrep3__ClientInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep3__ClientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep2__GetListCreationTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_mtrep2__GetListCreationTimeResponse::GetListCreationTimeResult);
	/* transient soap skipped */
}

void _mtrep2__GetListCreationTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _mtrep2__GetListCreationTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep2__GetListCreationTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep2__GetListCreationTimeResponse(struct soap *soap, const char *tag, int id, const _mtrep2__GetListCreationTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep2__GetListCreationTimeResponse), type))
		return soap->error;
	soap_element_result(soap, "mtrep2:GetListCreationTimeResult");
	if (soap_out_int(soap, "mtrep2:GetListCreationTimeResult", -1, &a->_mtrep2__GetListCreationTimeResponse::GetListCreationTimeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep2__GetListCreationTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep2__GetListCreationTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep2__GetListCreationTimeResponse * SOAP_FMAC4 soap_in__mtrep2__GetListCreationTimeResponse(struct soap *soap, const char *tag, _mtrep2__GetListCreationTimeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep2__GetListCreationTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep2__GetListCreationTimeResponse, sizeof(_mtrep2__GetListCreationTimeResponse), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetListCreationTimeResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetListCreationTimeResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep2:GetListCreationTimeResult", &a->_mtrep2__GetListCreationTimeResponse::GetListCreationTimeResult, "xsd:int"))
				{	soap_flag_GetListCreationTimeResult1--;
					continue;
				}
			soap_check_result(soap, "mtrep2:GetListCreationTimeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetListCreationTimeResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_mtrep2__GetListCreationTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep2__GetListCreationTimeResponse, SOAP_TYPE__mtrep2__GetListCreationTimeResponse, sizeof(_mtrep2__GetListCreationTimeResponse), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep2__GetListCreationTimeResponse * SOAP_FMAC2 repository_instantiate__mtrep2__GetListCreationTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep2__GetListCreationTimeResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep2__GetListCreationTimeResponse *p;
	size_t k = sizeof(_mtrep2__GetListCreationTimeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep2__GetListCreationTimeResponse);
		if (p)
			((_mtrep2__GetListCreationTimeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep2__GetListCreationTimeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep2__GetListCreationTimeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep2__GetListCreationTimeResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep2__GetListCreationTimeResponse, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep2__GetListCreationTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep2:GetListCreationTimeResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep2__GetListCreationTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep2__GetListCreationTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep2__GetListCreationTimeResponse * SOAP_FMAC4 soap_get__mtrep2__GetListCreationTimeResponse(struct soap *soap, _mtrep2__GetListCreationTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep2__GetListCreationTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep2__GetListCreationTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _mtrep2__GetListCreationTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _mtrep2__GetListCreationTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep2__GetListCreationTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep2__GetListCreationTime(struct soap *soap, const char *tag, int id, const _mtrep2__GetListCreationTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep2__GetListCreationTime), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep2__GetListCreationTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep2__GetListCreationTime(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep2__GetListCreationTime * SOAP_FMAC4 soap_in__mtrep2__GetListCreationTime(struct soap *soap, const char *tag, _mtrep2__GetListCreationTime *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep2__GetListCreationTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep2__GetListCreationTime, sizeof(_mtrep2__GetListCreationTime), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep2__GetListCreationTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep2__GetListCreationTime, SOAP_TYPE__mtrep2__GetListCreationTime, sizeof(_mtrep2__GetListCreationTime), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep2__GetListCreationTime * SOAP_FMAC2 repository_instantiate__mtrep2__GetListCreationTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep2__GetListCreationTime(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep2__GetListCreationTime *p;
	size_t k = sizeof(_mtrep2__GetListCreationTime);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep2__GetListCreationTime);
		if (p)
			((_mtrep2__GetListCreationTime*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep2__GetListCreationTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep2__GetListCreationTime*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep2__GetListCreationTime location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep2__GetListCreationTime, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep2__GetListCreationTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep2:GetListCreationTime", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep2__GetListCreationTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep2__GetListCreationTime(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep2__GetListCreationTime * SOAP_FMAC4 soap_get__mtrep2__GetListCreationTime(struct soap *soap, _mtrep2__GetListCreationTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep2__GetListCreationTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep__GetRepositoriesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep__GetRepositoriesResponse::GetRepositoriesResult = NULL;
	/* transient soap skipped */
}

void _mtrep__GetRepositoriesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep__ArrayOfRepositoryInfo(soap, &this->_mtrep__GetRepositoriesResponse::GetRepositoriesResult);
#endif
}

int _mtrep__GetRepositoriesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep__GetRepositoriesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep__GetRepositoriesResponse(struct soap *soap, const char *tag, int id, const _mtrep__GetRepositoriesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep__GetRepositoriesResponse), type))
		return soap->error;
	if (a->GetRepositoriesResult)
		soap_element_result(soap, "mtrep:GetRepositoriesResult");
	if (soap_out_PointerTomtrep__ArrayOfRepositoryInfo(soap, "mtrep:GetRepositoriesResult", -1, &a->_mtrep__GetRepositoriesResponse::GetRepositoriesResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep__GetRepositoriesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep__GetRepositoriesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep__GetRepositoriesResponse * SOAP_FMAC4 soap_in__mtrep__GetRepositoriesResponse(struct soap *soap, const char *tag, _mtrep__GetRepositoriesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep__GetRepositoriesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep__GetRepositoriesResponse, sizeof(_mtrep__GetRepositoriesResponse), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetRepositoriesResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetRepositoriesResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep__ArrayOfRepositoryInfo(soap, "mtrep:GetRepositoriesResult", &a->_mtrep__GetRepositoriesResponse::GetRepositoriesResult, "mtrep:ArrayOfRepositoryInfo"))
				{	soap_flag_GetRepositoriesResult1--;
					continue;
				}
			soap_check_result(soap, "mtrep:GetRepositoriesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep__GetRepositoriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep__GetRepositoriesResponse, SOAP_TYPE__mtrep__GetRepositoriesResponse, sizeof(_mtrep__GetRepositoriesResponse), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep__GetRepositoriesResponse * SOAP_FMAC2 repository_instantiate__mtrep__GetRepositoriesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep__GetRepositoriesResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep__GetRepositoriesResponse *p;
	size_t k = sizeof(_mtrep__GetRepositoriesResponse);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep__GetRepositoriesResponse);
		if (p)
			((_mtrep__GetRepositoriesResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep__GetRepositoriesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep__GetRepositoriesResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep__GetRepositoriesResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep__GetRepositoriesResponse, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep__GetRepositoriesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep:GetRepositoriesResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep__GetRepositoriesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep__GetRepositoriesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep__GetRepositoriesResponse * SOAP_FMAC4 soap_get__mtrep__GetRepositoriesResponse(struct soap *soap, _mtrep__GetRepositoriesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep__GetRepositoriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep__GetRepositories::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_mtrep__GetRepositories::onlyOnline);
	soap_default_bool(soap, &this->_mtrep__GetRepositories::noCorrupted);
	soap_default_int(soap, &this->_mtrep__GetRepositories::maxDelay);
	/* transient soap skipped */
}

void _mtrep__GetRepositories::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _mtrep__GetRepositories::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep__GetRepositories(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep__GetRepositories(struct soap *soap, const char *tag, int id, const _mtrep__GetRepositories *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep__GetRepositories), type))
		return soap->error;
	if (soap_out_bool(soap, "mtrep:onlyOnline", -1, &a->_mtrep__GetRepositories::onlyOnline, ""))
		return soap->error;
	if (soap_out_bool(soap, "mtrep:noCorrupted", -1, &a->_mtrep__GetRepositories::noCorrupted, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep:maxDelay", -1, &a->_mtrep__GetRepositories::maxDelay, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep__GetRepositories::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep__GetRepositories(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep__GetRepositories * SOAP_FMAC4 soap_in__mtrep__GetRepositories(struct soap *soap, const char *tag, _mtrep__GetRepositories *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep__GetRepositories *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep__GetRepositories, sizeof(_mtrep__GetRepositories), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_onlyOnline1 = 1;
	size_t soap_flag_noCorrupted1 = 1;
	size_t soap_flag_maxDelay1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_onlyOnline1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep:onlyOnline", &a->_mtrep__GetRepositories::onlyOnline, "xsd:boolean"))
				{	soap_flag_onlyOnline1--;
					continue;
				}
			if (soap_flag_noCorrupted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep:noCorrupted", &a->_mtrep__GetRepositories::noCorrupted, "xsd:boolean"))
				{	soap_flag_noCorrupted1--;
					continue;
				}
			if (soap_flag_maxDelay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep:maxDelay", &a->_mtrep__GetRepositories::maxDelay, "xsd:int"))
				{	soap_flag_maxDelay1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_onlyOnline1 > 0 || soap_flag_noCorrupted1 > 0 || soap_flag_maxDelay1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_mtrep__GetRepositories *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep__GetRepositories, SOAP_TYPE__mtrep__GetRepositories, sizeof(_mtrep__GetRepositories), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep__GetRepositories * SOAP_FMAC2 repository_instantiate__mtrep__GetRepositories(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep__GetRepositories(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep__GetRepositories *p;
	size_t k = sizeof(_mtrep__GetRepositories);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep__GetRepositories);
		if (p)
			((_mtrep__GetRepositories*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep__GetRepositories, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep__GetRepositories*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep__GetRepositories location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep__GetRepositories, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep__GetRepositories::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep:GetRepositories", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep__GetRepositories::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep__GetRepositories(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep__GetRepositories * SOAP_FMAC4 soap_get__mtrep__GetRepositories(struct soap *soap, _mtrep__GetRepositories *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep__GetRepositories(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep__GetAllRepositoriesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep__GetAllRepositoriesResponse::GetAllRepositoriesResult = NULL;
	/* transient soap skipped */
}

void _mtrep__GetAllRepositoriesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep__ArrayOfRepositoryInfo(soap, &this->_mtrep__GetAllRepositoriesResponse::GetAllRepositoriesResult);
#endif
}

int _mtrep__GetAllRepositoriesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep__GetAllRepositoriesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep__GetAllRepositoriesResponse(struct soap *soap, const char *tag, int id, const _mtrep__GetAllRepositoriesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep__GetAllRepositoriesResponse), type))
		return soap->error;
	if (a->GetAllRepositoriesResult)
		soap_element_result(soap, "mtrep:GetAllRepositoriesResult");
	if (soap_out_PointerTomtrep__ArrayOfRepositoryInfo(soap, "mtrep:GetAllRepositoriesResult", -1, &a->_mtrep__GetAllRepositoriesResponse::GetAllRepositoriesResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep__GetAllRepositoriesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep__GetAllRepositoriesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep__GetAllRepositoriesResponse * SOAP_FMAC4 soap_in__mtrep__GetAllRepositoriesResponse(struct soap *soap, const char *tag, _mtrep__GetAllRepositoriesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep__GetAllRepositoriesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep__GetAllRepositoriesResponse, sizeof(_mtrep__GetAllRepositoriesResponse), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetAllRepositoriesResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAllRepositoriesResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep__ArrayOfRepositoryInfo(soap, "mtrep:GetAllRepositoriesResult", &a->_mtrep__GetAllRepositoriesResponse::GetAllRepositoriesResult, "mtrep:ArrayOfRepositoryInfo"))
				{	soap_flag_GetAllRepositoriesResult1--;
					continue;
				}
			soap_check_result(soap, "mtrep:GetAllRepositoriesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep__GetAllRepositoriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep__GetAllRepositoriesResponse, SOAP_TYPE__mtrep__GetAllRepositoriesResponse, sizeof(_mtrep__GetAllRepositoriesResponse), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep__GetAllRepositoriesResponse * SOAP_FMAC2 repository_instantiate__mtrep__GetAllRepositoriesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep__GetAllRepositoriesResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep__GetAllRepositoriesResponse *p;
	size_t k = sizeof(_mtrep__GetAllRepositoriesResponse);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep__GetAllRepositoriesResponse);
		if (p)
			((_mtrep__GetAllRepositoriesResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep__GetAllRepositoriesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep__GetAllRepositoriesResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep__GetAllRepositoriesResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep__GetAllRepositoriesResponse, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep__GetAllRepositoriesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep:GetAllRepositoriesResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep__GetAllRepositoriesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep__GetAllRepositoriesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep__GetAllRepositoriesResponse * SOAP_FMAC4 soap_get__mtrep__GetAllRepositoriesResponse(struct soap *soap, _mtrep__GetAllRepositoriesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep__GetAllRepositoriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep__GetAllRepositories::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _mtrep__GetAllRepositories::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _mtrep__GetAllRepositories::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep__GetAllRepositories(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep__GetAllRepositories(struct soap *soap, const char *tag, int id, const _mtrep__GetAllRepositories *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep__GetAllRepositories), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep__GetAllRepositories::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep__GetAllRepositories(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep__GetAllRepositories * SOAP_FMAC4 soap_in__mtrep__GetAllRepositories(struct soap *soap, const char *tag, _mtrep__GetAllRepositories *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep__GetAllRepositories *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep__GetAllRepositories, sizeof(_mtrep__GetAllRepositories), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep__GetAllRepositories *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep__GetAllRepositories, SOAP_TYPE__mtrep__GetAllRepositories, sizeof(_mtrep__GetAllRepositories), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep__GetAllRepositories * SOAP_FMAC2 repository_instantiate__mtrep__GetAllRepositories(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep__GetAllRepositories(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep__GetAllRepositories *p;
	size_t k = sizeof(_mtrep__GetAllRepositories);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep__GetAllRepositories);
		if (p)
			((_mtrep__GetAllRepositories*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep__GetAllRepositories, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep__GetAllRepositories*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep__GetAllRepositories location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep__GetAllRepositories, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep__GetAllRepositories::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep:GetAllRepositories", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep__GetAllRepositories::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep__GetAllRepositories(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep__GetAllRepositories * SOAP_FMAC4 soap_get__mtrep__GetAllRepositories(struct soap *soap, _mtrep__GetAllRepositories *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep__GetAllRepositories(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep__PickRepositoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep__PickRepositoryResponse::PickRepositoryResult = NULL;
	/* transient soap skipped */
}

void _mtrep__PickRepositoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep__RepositoryInfo(soap, &this->_mtrep__PickRepositoryResponse::PickRepositoryResult);
#endif
}

int _mtrep__PickRepositoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep__PickRepositoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep__PickRepositoryResponse(struct soap *soap, const char *tag, int id, const _mtrep__PickRepositoryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep__PickRepositoryResponse), type))
		return soap->error;
	if (a->PickRepositoryResult)
		soap_element_result(soap, "mtrep:PickRepositoryResult");
	if (soap_out_PointerTomtrep__RepositoryInfo(soap, "mtrep:PickRepositoryResult", -1, &a->_mtrep__PickRepositoryResponse::PickRepositoryResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep__PickRepositoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep__PickRepositoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep__PickRepositoryResponse * SOAP_FMAC4 soap_in__mtrep__PickRepositoryResponse(struct soap *soap, const char *tag, _mtrep__PickRepositoryResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep__PickRepositoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep__PickRepositoryResponse, sizeof(_mtrep__PickRepositoryResponse), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PickRepositoryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PickRepositoryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep__RepositoryInfo(soap, "mtrep:PickRepositoryResult", &a->_mtrep__PickRepositoryResponse::PickRepositoryResult, "mtrep:RepositoryInfo"))
				{	soap_flag_PickRepositoryResult1--;
					continue;
				}
			soap_check_result(soap, "mtrep:PickRepositoryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep__PickRepositoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep__PickRepositoryResponse, SOAP_TYPE__mtrep__PickRepositoryResponse, sizeof(_mtrep__PickRepositoryResponse), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep__PickRepositoryResponse * SOAP_FMAC2 repository_instantiate__mtrep__PickRepositoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep__PickRepositoryResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep__PickRepositoryResponse *p;
	size_t k = sizeof(_mtrep__PickRepositoryResponse);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep__PickRepositoryResponse);
		if (p)
			((_mtrep__PickRepositoryResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep__PickRepositoryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep__PickRepositoryResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep__PickRepositoryResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep__PickRepositoryResponse, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep__PickRepositoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep:PickRepositoryResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep__PickRepositoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep__PickRepositoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep__PickRepositoryResponse * SOAP_FMAC4 soap_get__mtrep__PickRepositoryResponse(struct soap *soap, _mtrep__PickRepositoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep__PickRepositoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep__PickRepository::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _mtrep__PickRepository::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _mtrep__PickRepository::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep__PickRepository(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep__PickRepository(struct soap *soap, const char *tag, int id, const _mtrep__PickRepository *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep__PickRepository), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep__PickRepository::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep__PickRepository(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep__PickRepository * SOAP_FMAC4 soap_in__mtrep__PickRepository(struct soap *soap, const char *tag, _mtrep__PickRepository *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep__PickRepository *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep__PickRepository, sizeof(_mtrep__PickRepository), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep__PickRepository *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep__PickRepository, SOAP_TYPE__mtrep__PickRepository, sizeof(_mtrep__PickRepository), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep__PickRepository * SOAP_FMAC2 repository_instantiate__mtrep__PickRepository(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep__PickRepository(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep__PickRepository *p;
	size_t k = sizeof(_mtrep__PickRepository);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep__PickRepository);
		if (p)
			((_mtrep__PickRepository*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep__PickRepository, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep__PickRepository*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep__PickRepository location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep__PickRepository, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep__PickRepository::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep:PickRepository", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep__PickRepository::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep__PickRepository(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep__PickRepository * SOAP_FMAC4 soap_get__mtrep__PickRepository(struct soap *soap, _mtrep__PickRepository *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep__PickRepository(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep__TryGetRepositoryInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_mtrep__TryGetRepositoryInfoResponse::TryGetRepositoryInfoResult);
	this->_mtrep__TryGetRepositoryInfoResponse::repositoryInfo = NULL;
	/* transient soap skipped */
}

void _mtrep__TryGetRepositoryInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomtrep__RepositoryInfo(soap, &this->_mtrep__TryGetRepositoryInfoResponse::repositoryInfo);
#endif
}

int _mtrep__TryGetRepositoryInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep__TryGetRepositoryInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep__TryGetRepositoryInfoResponse(struct soap *soap, const char *tag, int id, const _mtrep__TryGetRepositoryInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse), type))
		return soap->error;
	soap_element_result(soap, "mtrep:TryGetRepositoryInfoResult");
	if (soap_out_bool(soap, "mtrep:TryGetRepositoryInfoResult", -1, &a->_mtrep__TryGetRepositoryInfoResponse::TryGetRepositoryInfoResult, ""))
		return soap->error;
	if (soap_out_PointerTomtrep__RepositoryInfo(soap, "mtrep:repositoryInfo", -1, &a->_mtrep__TryGetRepositoryInfoResponse::repositoryInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep__TryGetRepositoryInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep__TryGetRepositoryInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep__TryGetRepositoryInfoResponse * SOAP_FMAC4 soap_in__mtrep__TryGetRepositoryInfoResponse(struct soap *soap, const char *tag, _mtrep__TryGetRepositoryInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep__TryGetRepositoryInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse, sizeof(_mtrep__TryGetRepositoryInfoResponse), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TryGetRepositoryInfoResult1 = 1;
	size_t soap_flag_repositoryInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TryGetRepositoryInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mtrep:TryGetRepositoryInfoResult", &a->_mtrep__TryGetRepositoryInfoResponse::TryGetRepositoryInfoResult, "xsd:boolean"))
				{	soap_flag_TryGetRepositoryInfoResult1--;
					continue;
				}
			if (soap_flag_repositoryInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomtrep__RepositoryInfo(soap, "mtrep:repositoryInfo", &a->_mtrep__TryGetRepositoryInfoResponse::repositoryInfo, "mtrep:RepositoryInfo"))
				{	soap_flag_repositoryInfo1--;
					continue;
				}
			soap_check_result(soap, "mtrep:TryGetRepositoryInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TryGetRepositoryInfoResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_mtrep__TryGetRepositoryInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse, SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse, sizeof(_mtrep__TryGetRepositoryInfoResponse), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep__TryGetRepositoryInfoResponse * SOAP_FMAC2 repository_instantiate__mtrep__TryGetRepositoryInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep__TryGetRepositoryInfoResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep__TryGetRepositoryInfoResponse *p;
	size_t k = sizeof(_mtrep__TryGetRepositoryInfoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep__TryGetRepositoryInfoResponse);
		if (p)
			((_mtrep__TryGetRepositoryInfoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep__TryGetRepositoryInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep__TryGetRepositoryInfoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep__TryGetRepositoryInfoResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep__TryGetRepositoryInfoResponse, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep__TryGetRepositoryInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep:TryGetRepositoryInfoResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep__TryGetRepositoryInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep__TryGetRepositoryInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep__TryGetRepositoryInfoResponse * SOAP_FMAC4 soap_get__mtrep__TryGetRepositoryInfoResponse(struct soap *soap, _mtrep__TryGetRepositoryInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep__TryGetRepositoryInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _mtrep__TryGetRepositoryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_mtrep__TryGetRepositoryInfo::url = NULL;
	/* transient soap skipped */
}

void _mtrep__TryGetRepositoryInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_mtrep__TryGetRepositoryInfo::url);
#endif
}

int _mtrep__TryGetRepositoryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__mtrep__TryGetRepositoryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__mtrep__TryGetRepositoryInfo(struct soap *soap, const char *tag, int id, const _mtrep__TryGetRepositoryInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__mtrep__TryGetRepositoryInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep:url", -1, &a->_mtrep__TryGetRepositoryInfo::url, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_mtrep__TryGetRepositoryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__mtrep__TryGetRepositoryInfo(soap, tag, this, type);
}

SOAP_FMAC3 _mtrep__TryGetRepositoryInfo * SOAP_FMAC4 soap_in__mtrep__TryGetRepositoryInfo(struct soap *soap, const char *tag, _mtrep__TryGetRepositoryInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_mtrep__TryGetRepositoryInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__mtrep__TryGetRepositoryInfo, sizeof(_mtrep__TryGetRepositoryInfo), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_url1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep:url", &a->_mtrep__TryGetRepositoryInfo::url, "xsd:string"))
				{	soap_flag_url1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_mtrep__TryGetRepositoryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__mtrep__TryGetRepositoryInfo, SOAP_TYPE__mtrep__TryGetRepositoryInfo, sizeof(_mtrep__TryGetRepositoryInfo), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _mtrep__TryGetRepositoryInfo * SOAP_FMAC2 repository_instantiate__mtrep__TryGetRepositoryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate__mtrep__TryGetRepositoryInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_mtrep__TryGetRepositoryInfo *p;
	size_t k = sizeof(_mtrep__TryGetRepositoryInfo);
	if (n < 0)
	{	p = SOAP_NEW(_mtrep__TryGetRepositoryInfo);
		if (p)
			((_mtrep__TryGetRepositoryInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_mtrep__TryGetRepositoryInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_mtrep__TryGetRepositoryInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _mtrep__TryGetRepositoryInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__mtrep__TryGetRepositoryInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int _mtrep__TryGetRepositoryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep:TryGetRepositoryInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_mtrep__TryGetRepositoryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__mtrep__TryGetRepositoryInfo(soap, this, tag, type);
}

SOAP_FMAC3 _mtrep__TryGetRepositoryInfo * SOAP_FMAC4 soap_get__mtrep__TryGetRepositoryInfo(struct soap *soap, _mtrep__TryGetRepositoryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__mtrep__TryGetRepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep__ArrayOfRepositoryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTomtrep__RepositoryInfo(soap, &this->mtrep__ArrayOfRepositoryInfo::RepositoryInfo);
	/* transient soap skipped */
}

void mtrep__ArrayOfRepositoryInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTomtrep__RepositoryInfo(soap, &this->mtrep__ArrayOfRepositoryInfo::RepositoryInfo);
#endif
}

int mtrep__ArrayOfRepositoryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep__ArrayOfRepositoryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep__ArrayOfRepositoryInfo(struct soap *soap, const char *tag, int id, const mtrep__ArrayOfRepositoryInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep__ArrayOfRepositoryInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTomtrep__RepositoryInfo(soap, "mtrep:RepositoryInfo", -1, &a->mtrep__ArrayOfRepositoryInfo::RepositoryInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep__ArrayOfRepositoryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep__ArrayOfRepositoryInfo(soap, tag, this, type);
}

SOAP_FMAC3 mtrep__ArrayOfRepositoryInfo * SOAP_FMAC4 soap_in_mtrep__ArrayOfRepositoryInfo(struct soap *soap, const char *tag, mtrep__ArrayOfRepositoryInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep__ArrayOfRepositoryInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep__ArrayOfRepositoryInfo, sizeof(mtrep__ArrayOfRepositoryInfo), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTomtrep__RepositoryInfo(soap, "mtrep:RepositoryInfo", &a->mtrep__ArrayOfRepositoryInfo::RepositoryInfo, "mtrep:RepositoryInfo"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mtrep__ArrayOfRepositoryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep__ArrayOfRepositoryInfo, SOAP_TYPE_mtrep__ArrayOfRepositoryInfo, sizeof(mtrep__ArrayOfRepositoryInfo), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep__ArrayOfRepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep__ArrayOfRepositoryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep__ArrayOfRepositoryInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep__ArrayOfRepositoryInfo *p;
	size_t k = sizeof(mtrep__ArrayOfRepositoryInfo);
	if (n < 0)
	{	p = SOAP_NEW(mtrep__ArrayOfRepositoryInfo);
		if (p)
			((mtrep__ArrayOfRepositoryInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep__ArrayOfRepositoryInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep__ArrayOfRepositoryInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep__ArrayOfRepositoryInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep__ArrayOfRepositoryInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep__ArrayOfRepositoryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep:ArrayOfRepositoryInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep__ArrayOfRepositoryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep__ArrayOfRepositoryInfo(soap, this, tag, type);
}

SOAP_FMAC3 mtrep__ArrayOfRepositoryInfo * SOAP_FMAC4 soap_get_mtrep__ArrayOfRepositoryInfo(struct soap *soap, mtrep__ArrayOfRepositoryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep__ArrayOfRepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mtrep__RepositoryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->mtrep__RepositoryInfo::Country = NULL;
	soap_default_int(soap, &this->mtrep__RepositoryInfo::Date);
	soap_default_int(soap, &this->mtrep__RepositoryInfo::Delay);
	this->mtrep__RepositoryInfo::Description = NULL;
	soap_default_mtrep__RepositoryIntegrity(soap, &this->mtrep__RepositoryInfo::Integrity);
	soap_default_mtrep__PackageLevel(soap, &this->mtrep__RepositoryInfo::Level);
	soap_default_mtrep__RepositoryStatus(soap, &this->mtrep__RepositoryInfo::Status);
	this->mtrep__RepositoryInfo::Url = NULL;
	soap_default_int(soap, &this->mtrep__RepositoryInfo::Version);
	/* transient soap skipped */
}

void mtrep__RepositoryInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->mtrep__RepositoryInfo::Country);
	soap_serialize_PointerTostd__string(soap, &this->mtrep__RepositoryInfo::Description);
	soap_serialize_PointerTostd__string(soap, &this->mtrep__RepositoryInfo::Url);
#endif
}

int mtrep__RepositoryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mtrep__RepositoryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mtrep__RepositoryInfo(struct soap *soap, const char *tag, int id, const mtrep__RepositoryInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mtrep__RepositoryInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep:Country", -1, &a->mtrep__RepositoryInfo::Country, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep:Date", -1, &a->mtrep__RepositoryInfo::Date, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep:Delay", -1, &a->mtrep__RepositoryInfo::Delay, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep:Description", -1, &a->mtrep__RepositoryInfo::Description, ""))
		return soap->error;
	if (soap_out_mtrep__RepositoryIntegrity(soap, "mtrep:Integrity", -1, &a->mtrep__RepositoryInfo::Integrity, ""))
		return soap->error;
	if (soap_out_mtrep__PackageLevel(soap, "mtrep:Level", -1, &a->mtrep__RepositoryInfo::Level, ""))
		return soap->error;
	if (soap_out_mtrep__RepositoryStatus(soap, "mtrep:Status", -1, &a->mtrep__RepositoryInfo::Status, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "mtrep:Url", -1, &a->mtrep__RepositoryInfo::Url, ""))
		return soap->error;
	if (soap_out_int(soap, "mtrep:Version", -1, &a->mtrep__RepositoryInfo::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mtrep__RepositoryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mtrep__RepositoryInfo(soap, tag, this, type);
}

SOAP_FMAC3 mtrep__RepositoryInfo * SOAP_FMAC4 soap_in_mtrep__RepositoryInfo(struct soap *soap, const char *tag, mtrep__RepositoryInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mtrep__RepositoryInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mtrep__RepositoryInfo, sizeof(mtrep__RepositoryInfo), soap->type, soap->arrayType, repository_instantiate, repository_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Country1 = 1;
	size_t soap_flag_Date1 = 1;
	size_t soap_flag_Delay1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_Integrity1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_Url1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep:Country", &a->mtrep__RepositoryInfo::Country, "xsd:string"))
				{	soap_flag_Country1--;
					continue;
				}
			if (soap_flag_Date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep:Date", &a->mtrep__RepositoryInfo::Date, "xsd:int"))
				{	soap_flag_Date1--;
					continue;
				}
			if (soap_flag_Delay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep:Delay", &a->mtrep__RepositoryInfo::Delay, "xsd:int"))
				{	soap_flag_Delay1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep:Description", &a->mtrep__RepositoryInfo::Description, "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_Integrity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep__RepositoryIntegrity(soap, "mtrep:Integrity", &a->mtrep__RepositoryInfo::Integrity, "mtrep:RepositoryIntegrity"))
				{	soap_flag_Integrity1--;
					continue;
				}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep__PackageLevel(soap, "mtrep:Level", &a->mtrep__RepositoryInfo::Level, "mtrep:PackageLevel"))
				{	soap_flag_Level1--;
					continue;
				}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_mtrep__RepositoryStatus(soap, "mtrep:Status", &a->mtrep__RepositoryInfo::Status, "mtrep:RepositoryStatus"))
				{	soap_flag_Status1--;
					continue;
				}
			if (soap_flag_Url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "mtrep:Url", &a->mtrep__RepositoryInfo::Url, "xsd:string"))
				{	soap_flag_Url1--;
					continue;
				}
			if (soap_flag_Version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mtrep:Version", &a->mtrep__RepositoryInfo::Version, "xsd:int"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Date1 > 0 || soap_flag_Delay1 > 0 || soap_flag_Integrity1 > 0 || soap_flag_Level1 > 0 || soap_flag_Status1 > 0 || soap_flag_Version1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (mtrep__RepositoryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mtrep__RepositoryInfo, SOAP_TYPE_mtrep__RepositoryInfo, sizeof(mtrep__RepositoryInfo), 0, repository_finsert, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mtrep__RepositoryInfo * SOAP_FMAC2 repository_instantiate_mtrep__RepositoryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_mtrep__RepositoryInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mtrep__RepositoryInfo *p;
	size_t k = sizeof(mtrep__RepositoryInfo);
	if (n < 0)
	{	p = SOAP_NEW(mtrep__RepositoryInfo);
		if (p)
			((mtrep__RepositoryInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(mtrep__RepositoryInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((mtrep__RepositoryInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mtrep__RepositoryInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_mtrep__RepositoryInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

int mtrep__RepositoryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"mtrep:RepositoryInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mtrep__RepositoryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mtrep__RepositoryInfo(soap, this, tag, type);
}

SOAP_FMAC3 mtrep__RepositoryInfo * SOAP_FMAC4 soap_get_mtrep__RepositoryInfo(struct soap *soap, mtrep__RepositoryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_mtrep__RepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, repository_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 repository_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, repository_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 repository_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, repository_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 repository_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, repository_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 repository_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, repository_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 repository_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__TryGetRepositoryInfo3_(struct soap *soap, struct __mtrep7__TryGetRepositoryInfo3_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep7__TryGetRepositoryInfo3 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__TryGetRepositoryInfo3_(struct soap *soap, const struct __mtrep7__TryGetRepositoryInfo3_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep7__TryGetRepositoryInfo3(soap, &a->mtrep7__TryGetRepositoryInfo3);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__TryGetRepositoryInfo3_(struct soap *soap, const char *tag, int id, const struct __mtrep7__TryGetRepositoryInfo3_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep7__TryGetRepositoryInfo3(soap, "mtrep7:TryGetRepositoryInfo3", -1, &a->mtrep7__TryGetRepositoryInfo3, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__TryGetRepositoryInfo3_ * SOAP_FMAC4 soap_in___mtrep7__TryGetRepositoryInfo3_(struct soap *soap, const char *tag, struct __mtrep7__TryGetRepositoryInfo3_ *a, const char *type)
{
	size_t soap_flag_mtrep7__TryGetRepositoryInfo3 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__TryGetRepositoryInfo3_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__TryGetRepositoryInfo3_, sizeof(struct __mtrep7__TryGetRepositoryInfo3_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__TryGetRepositoryInfo3_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep7__TryGetRepositoryInfo3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep7__TryGetRepositoryInfo3(soap, "mtrep7:TryGetRepositoryInfo3", &a->mtrep7__TryGetRepositoryInfo3, ""))
				{	soap_flag_mtrep7__TryGetRepositoryInfo3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__TryGetRepositoryInfo3_ * SOAP_FMAC2 repository_instantiate___mtrep7__TryGetRepositoryInfo3_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__TryGetRepositoryInfo3_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__TryGetRepositoryInfo3_ *p;
	size_t k = sizeof(struct __mtrep7__TryGetRepositoryInfo3_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__TryGetRepositoryInfo3_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__TryGetRepositoryInfo3_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__TryGetRepositoryInfo3_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__TryGetRepositoryInfo3_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__TryGetRepositoryInfo3_(struct soap *soap, const struct __mtrep7__TryGetRepositoryInfo3_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__TryGetRepositoryInfo3_(soap, tag?tag:"-mtrep7:TryGetRepositoryInfo3", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__TryGetRepositoryInfo3_ * SOAP_FMAC4 soap_get___mtrep7__TryGetRepositoryInfo3_(struct soap *soap, struct __mtrep7__TryGetRepositoryInfo3_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__TryGetRepositoryInfo3_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__VerifyRepository2_(struct soap *soap, struct __mtrep7__VerifyRepository2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep7__VerifyRepository2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__VerifyRepository2_(struct soap *soap, const struct __mtrep7__VerifyRepository2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep7__VerifyRepository2(soap, &a->mtrep7__VerifyRepository2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__VerifyRepository2_(struct soap *soap, const char *tag, int id, const struct __mtrep7__VerifyRepository2_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep7__VerifyRepository2(soap, "mtrep7:VerifyRepository2", -1, &a->mtrep7__VerifyRepository2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__VerifyRepository2_ * SOAP_FMAC4 soap_in___mtrep7__VerifyRepository2_(struct soap *soap, const char *tag, struct __mtrep7__VerifyRepository2_ *a, const char *type)
{
	size_t soap_flag_mtrep7__VerifyRepository2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__VerifyRepository2_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__VerifyRepository2_, sizeof(struct __mtrep7__VerifyRepository2_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__VerifyRepository2_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep7__VerifyRepository2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep7__VerifyRepository2(soap, "mtrep7:VerifyRepository2", &a->mtrep7__VerifyRepository2, ""))
				{	soap_flag_mtrep7__VerifyRepository2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__VerifyRepository2_ * SOAP_FMAC2 repository_instantiate___mtrep7__VerifyRepository2_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__VerifyRepository2_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__VerifyRepository2_ *p;
	size_t k = sizeof(struct __mtrep7__VerifyRepository2_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__VerifyRepository2_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__VerifyRepository2_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__VerifyRepository2_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__VerifyRepository2_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__VerifyRepository2_(struct soap *soap, const struct __mtrep7__VerifyRepository2_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__VerifyRepository2_(soap, tag?tag:"-mtrep7:VerifyRepository2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__VerifyRepository2_ * SOAP_FMAC4 soap_get___mtrep7__VerifyRepository2_(struct soap *soap, struct __mtrep7__VerifyRepository2_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__VerifyRepository2_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__PickRepository4_(struct soap *soap, struct __mtrep7__PickRepository4_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep6__PickRepository4 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__PickRepository4_(struct soap *soap, const struct __mtrep7__PickRepository4_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep6__PickRepository4(soap, &a->mtrep6__PickRepository4);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__PickRepository4_(struct soap *soap, const char *tag, int id, const struct __mtrep7__PickRepository4_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep6__PickRepository4(soap, "mtrep6:PickRepository4", -1, &a->mtrep6__PickRepository4, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository4_ * SOAP_FMAC4 soap_in___mtrep7__PickRepository4_(struct soap *soap, const char *tag, struct __mtrep7__PickRepository4_ *a, const char *type)
{
	size_t soap_flag_mtrep6__PickRepository4 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__PickRepository4_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__PickRepository4_, sizeof(struct __mtrep7__PickRepository4_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__PickRepository4_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep6__PickRepository4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep6__PickRepository4(soap, "mtrep6:PickRepository4", &a->mtrep6__PickRepository4, ""))
				{	soap_flag_mtrep6__PickRepository4--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__PickRepository4_ * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository4_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__PickRepository4_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__PickRepository4_ *p;
	size_t k = sizeof(struct __mtrep7__PickRepository4_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__PickRepository4_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__PickRepository4_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__PickRepository4_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__PickRepository4_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__PickRepository4_(struct soap *soap, const struct __mtrep7__PickRepository4_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__PickRepository4_(soap, tag?tag:"-mtrep7:PickRepository4", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository4_ * SOAP_FMAC4 soap_get___mtrep7__PickRepository4_(struct soap *soap, struct __mtrep7__PickRepository4_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__PickRepository4_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__GetRepositories4_(struct soap *soap, struct __mtrep7__GetRepositories4_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep6__GetRepositories4 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__GetRepositories4_(struct soap *soap, const struct __mtrep7__GetRepositories4_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep6__GetRepositories4(soap, &a->mtrep6__GetRepositories4);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__GetRepositories4_(struct soap *soap, const char *tag, int id, const struct __mtrep7__GetRepositories4_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep6__GetRepositories4(soap, "mtrep6:GetRepositories4", -1, &a->mtrep6__GetRepositories4, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories4_ * SOAP_FMAC4 soap_in___mtrep7__GetRepositories4_(struct soap *soap, const char *tag, struct __mtrep7__GetRepositories4_ *a, const char *type)
{
	size_t soap_flag_mtrep6__GetRepositories4 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__GetRepositories4_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__GetRepositories4_, sizeof(struct __mtrep7__GetRepositories4_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__GetRepositories4_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep6__GetRepositories4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep6__GetRepositories4(soap, "mtrep6:GetRepositories4", &a->mtrep6__GetRepositories4, ""))
				{	soap_flag_mtrep6__GetRepositories4--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__GetRepositories4_ * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories4_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__GetRepositories4_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__GetRepositories4_ *p;
	size_t k = sizeof(struct __mtrep7__GetRepositories4_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__GetRepositories4_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__GetRepositories4_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__GetRepositories4_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__GetRepositories4_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__GetRepositories4_(struct soap *soap, const struct __mtrep7__GetRepositories4_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__GetRepositories4_(soap, tag?tag:"-mtrep7:GetRepositories4", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories4_ * SOAP_FMAC4 soap_get___mtrep7__GetRepositories4_(struct soap *soap, struct __mtrep7__GetRepositories4_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__GetRepositories4_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__PickRepository3_(struct soap *soap, struct __mtrep7__PickRepository3_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep5__PickRepository3 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__PickRepository3_(struct soap *soap, const struct __mtrep7__PickRepository3_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep5__PickRepository3(soap, &a->mtrep5__PickRepository3);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__PickRepository3_(struct soap *soap, const char *tag, int id, const struct __mtrep7__PickRepository3_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep5__PickRepository3(soap, "mtrep5:PickRepository3", -1, &a->mtrep5__PickRepository3, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository3_ * SOAP_FMAC4 soap_in___mtrep7__PickRepository3_(struct soap *soap, const char *tag, struct __mtrep7__PickRepository3_ *a, const char *type)
{
	size_t soap_flag_mtrep5__PickRepository3 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__PickRepository3_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__PickRepository3_, sizeof(struct __mtrep7__PickRepository3_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__PickRepository3_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep5__PickRepository3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep5__PickRepository3(soap, "mtrep5:PickRepository3", &a->mtrep5__PickRepository3, ""))
				{	soap_flag_mtrep5__PickRepository3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__PickRepository3_ * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository3_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__PickRepository3_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__PickRepository3_ *p;
	size_t k = sizeof(struct __mtrep7__PickRepository3_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__PickRepository3_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__PickRepository3_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__PickRepository3_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__PickRepository3_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__PickRepository3_(struct soap *soap, const struct __mtrep7__PickRepository3_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__PickRepository3_(soap, tag?tag:"-mtrep7:PickRepository3", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository3_ * SOAP_FMAC4 soap_get___mtrep7__PickRepository3_(struct soap *soap, struct __mtrep7__PickRepository3_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__PickRepository3_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__GetRepositories3_(struct soap *soap, struct __mtrep7__GetRepositories3_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep5__GetRepositories3 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__GetRepositories3_(struct soap *soap, const struct __mtrep7__GetRepositories3_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep5__GetRepositories3(soap, &a->mtrep5__GetRepositories3);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__GetRepositories3_(struct soap *soap, const char *tag, int id, const struct __mtrep7__GetRepositories3_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep5__GetRepositories3(soap, "mtrep5:GetRepositories3", -1, &a->mtrep5__GetRepositories3, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories3_ * SOAP_FMAC4 soap_in___mtrep7__GetRepositories3_(struct soap *soap, const char *tag, struct __mtrep7__GetRepositories3_ *a, const char *type)
{
	size_t soap_flag_mtrep5__GetRepositories3 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__GetRepositories3_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__GetRepositories3_, sizeof(struct __mtrep7__GetRepositories3_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__GetRepositories3_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep5__GetRepositories3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep5__GetRepositories3(soap, "mtrep5:GetRepositories3", &a->mtrep5__GetRepositories3, ""))
				{	soap_flag_mtrep5__GetRepositories3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__GetRepositories3_ * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories3_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__GetRepositories3_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__GetRepositories3_ *p;
	size_t k = sizeof(struct __mtrep7__GetRepositories3_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__GetRepositories3_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__GetRepositories3_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__GetRepositories3_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__GetRepositories3_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__GetRepositories3_(struct soap *soap, const struct __mtrep7__GetRepositories3_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__GetRepositories3_(soap, tag?tag:"-mtrep7:GetRepositories3", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories3_ * SOAP_FMAC4 soap_get___mtrep7__GetRepositories3_(struct soap *soap, struct __mtrep7__GetRepositories3_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__GetRepositories3_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__VerifyRepository_(struct soap *soap, struct __mtrep7__VerifyRepository_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep4__VerifyRepository = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__VerifyRepository_(struct soap *soap, const struct __mtrep7__VerifyRepository_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep4__VerifyRepository(soap, &a->mtrep4__VerifyRepository);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__VerifyRepository_(struct soap *soap, const char *tag, int id, const struct __mtrep7__VerifyRepository_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep4__VerifyRepository(soap, "mtrep4:VerifyRepository", -1, &a->mtrep4__VerifyRepository, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__VerifyRepository_ * SOAP_FMAC4 soap_in___mtrep7__VerifyRepository_(struct soap *soap, const char *tag, struct __mtrep7__VerifyRepository_ *a, const char *type)
{
	size_t soap_flag_mtrep4__VerifyRepository = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__VerifyRepository_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__VerifyRepository_, sizeof(struct __mtrep7__VerifyRepository_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__VerifyRepository_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep4__VerifyRepository && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep4__VerifyRepository(soap, "mtrep4:VerifyRepository", &a->mtrep4__VerifyRepository, ""))
				{	soap_flag_mtrep4__VerifyRepository--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__VerifyRepository_ * SOAP_FMAC2 repository_instantiate___mtrep7__VerifyRepository_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__VerifyRepository_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__VerifyRepository_ *p;
	size_t k = sizeof(struct __mtrep7__VerifyRepository_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__VerifyRepository_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__VerifyRepository_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__VerifyRepository_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__VerifyRepository_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__VerifyRepository_(struct soap *soap, const struct __mtrep7__VerifyRepository_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__VerifyRepository_(soap, tag?tag:"-mtrep7:VerifyRepository", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__VerifyRepository_ * SOAP_FMAC4 soap_get___mtrep7__VerifyRepository_(struct soap *soap, struct __mtrep7__VerifyRepository_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__VerifyRepository_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__TryGetRepositoryInfo2_(struct soap *soap, struct __mtrep7__TryGetRepositoryInfo2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep3__TryGetRepositoryInfo2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__TryGetRepositoryInfo2_(struct soap *soap, const struct __mtrep7__TryGetRepositoryInfo2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep3__TryGetRepositoryInfo2(soap, &a->mtrep3__TryGetRepositoryInfo2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__TryGetRepositoryInfo2_(struct soap *soap, const char *tag, int id, const struct __mtrep7__TryGetRepositoryInfo2_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep3__TryGetRepositoryInfo2(soap, "mtrep3:TryGetRepositoryInfo2", -1, &a->mtrep3__TryGetRepositoryInfo2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__TryGetRepositoryInfo2_ * SOAP_FMAC4 soap_in___mtrep7__TryGetRepositoryInfo2_(struct soap *soap, const char *tag, struct __mtrep7__TryGetRepositoryInfo2_ *a, const char *type)
{
	size_t soap_flag_mtrep3__TryGetRepositoryInfo2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__TryGetRepositoryInfo2_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__TryGetRepositoryInfo2_, sizeof(struct __mtrep7__TryGetRepositoryInfo2_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__TryGetRepositoryInfo2_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep3__TryGetRepositoryInfo2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep3__TryGetRepositoryInfo2(soap, "mtrep3:TryGetRepositoryInfo2", &a->mtrep3__TryGetRepositoryInfo2, ""))
				{	soap_flag_mtrep3__TryGetRepositoryInfo2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__TryGetRepositoryInfo2_ * SOAP_FMAC2 repository_instantiate___mtrep7__TryGetRepositoryInfo2_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__TryGetRepositoryInfo2_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__TryGetRepositoryInfo2_ *p;
	size_t k = sizeof(struct __mtrep7__TryGetRepositoryInfo2_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__TryGetRepositoryInfo2_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__TryGetRepositoryInfo2_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__TryGetRepositoryInfo2_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__TryGetRepositoryInfo2_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__TryGetRepositoryInfo2_(struct soap *soap, const struct __mtrep7__TryGetRepositoryInfo2_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__TryGetRepositoryInfo2_(soap, tag?tag:"-mtrep7:TryGetRepositoryInfo2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__TryGetRepositoryInfo2_ * SOAP_FMAC4 soap_get___mtrep7__TryGetRepositoryInfo2_(struct soap *soap, struct __mtrep7__TryGetRepositoryInfo2_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__TryGetRepositoryInfo2_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__PickRepository2_(struct soap *soap, struct __mtrep7__PickRepository2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep3__PickRepository2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__PickRepository2_(struct soap *soap, const struct __mtrep7__PickRepository2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep3__PickRepository2(soap, &a->mtrep3__PickRepository2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__PickRepository2_(struct soap *soap, const char *tag, int id, const struct __mtrep7__PickRepository2_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep3__PickRepository2(soap, "mtrep3:PickRepository2", -1, &a->mtrep3__PickRepository2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository2_ * SOAP_FMAC4 soap_in___mtrep7__PickRepository2_(struct soap *soap, const char *tag, struct __mtrep7__PickRepository2_ *a, const char *type)
{
	size_t soap_flag_mtrep3__PickRepository2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__PickRepository2_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__PickRepository2_, sizeof(struct __mtrep7__PickRepository2_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__PickRepository2_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep3__PickRepository2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep3__PickRepository2(soap, "mtrep3:PickRepository2", &a->mtrep3__PickRepository2, ""))
				{	soap_flag_mtrep3__PickRepository2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__PickRepository2_ * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository2_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__PickRepository2_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__PickRepository2_ *p;
	size_t k = sizeof(struct __mtrep7__PickRepository2_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__PickRepository2_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__PickRepository2_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__PickRepository2_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__PickRepository2_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__PickRepository2_(struct soap *soap, const struct __mtrep7__PickRepository2_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__PickRepository2_(soap, tag?tag:"-mtrep7:PickRepository2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository2_ * SOAP_FMAC4 soap_get___mtrep7__PickRepository2_(struct soap *soap, struct __mtrep7__PickRepository2_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__PickRepository2_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__GetRepositories2_(struct soap *soap, struct __mtrep7__GetRepositories2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep3__GetRepositories2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__GetRepositories2_(struct soap *soap, const struct __mtrep7__GetRepositories2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep3__GetRepositories2(soap, &a->mtrep3__GetRepositories2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__GetRepositories2_(struct soap *soap, const char *tag, int id, const struct __mtrep7__GetRepositories2_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep3__GetRepositories2(soap, "mtrep3:GetRepositories2", -1, &a->mtrep3__GetRepositories2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories2_ * SOAP_FMAC4 soap_in___mtrep7__GetRepositories2_(struct soap *soap, const char *tag, struct __mtrep7__GetRepositories2_ *a, const char *type)
{
	size_t soap_flag_mtrep3__GetRepositories2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__GetRepositories2_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__GetRepositories2_, sizeof(struct __mtrep7__GetRepositories2_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__GetRepositories2_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep3__GetRepositories2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep3__GetRepositories2(soap, "mtrep3:GetRepositories2", &a->mtrep3__GetRepositories2, ""))
				{	soap_flag_mtrep3__GetRepositories2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__GetRepositories2_ * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories2_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__GetRepositories2_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__GetRepositories2_ *p;
	size_t k = sizeof(struct __mtrep7__GetRepositories2_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__GetRepositories2_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__GetRepositories2_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__GetRepositories2_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__GetRepositories2_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__GetRepositories2_(struct soap *soap, const struct __mtrep7__GetRepositories2_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__GetRepositories2_(soap, tag?tag:"-mtrep7:GetRepositories2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories2_ * SOAP_FMAC4 soap_get___mtrep7__GetRepositories2_(struct soap *soap, struct __mtrep7__GetRepositories2_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__GetRepositories2_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__GetListCreationTime_(struct soap *soap, struct __mtrep7__GetListCreationTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep2__GetListCreationTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__GetListCreationTime_(struct soap *soap, const struct __mtrep7__GetListCreationTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep2__GetListCreationTime(soap, &a->mtrep2__GetListCreationTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__GetListCreationTime_(struct soap *soap, const char *tag, int id, const struct __mtrep7__GetListCreationTime_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep2__GetListCreationTime(soap, "mtrep2:GetListCreationTime", -1, &a->mtrep2__GetListCreationTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetListCreationTime_ * SOAP_FMAC4 soap_in___mtrep7__GetListCreationTime_(struct soap *soap, const char *tag, struct __mtrep7__GetListCreationTime_ *a, const char *type)
{
	size_t soap_flag_mtrep2__GetListCreationTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__GetListCreationTime_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__GetListCreationTime_, sizeof(struct __mtrep7__GetListCreationTime_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__GetListCreationTime_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep2__GetListCreationTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep2__GetListCreationTime(soap, "mtrep2:GetListCreationTime", &a->mtrep2__GetListCreationTime, ""))
				{	soap_flag_mtrep2__GetListCreationTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__GetListCreationTime_ * SOAP_FMAC2 repository_instantiate___mtrep7__GetListCreationTime_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__GetListCreationTime_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__GetListCreationTime_ *p;
	size_t k = sizeof(struct __mtrep7__GetListCreationTime_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__GetListCreationTime_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__GetListCreationTime_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__GetListCreationTime_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__GetListCreationTime_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__GetListCreationTime_(struct soap *soap, const struct __mtrep7__GetListCreationTime_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__GetListCreationTime_(soap, tag?tag:"-mtrep7:GetListCreationTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetListCreationTime_ * SOAP_FMAC4 soap_get___mtrep7__GetListCreationTime_(struct soap *soap, struct __mtrep7__GetListCreationTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__GetListCreationTime_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__GetRepositories_(struct soap *soap, struct __mtrep7__GetRepositories_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep__GetRepositories = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__GetRepositories_(struct soap *soap, const struct __mtrep7__GetRepositories_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep__GetRepositories(soap, &a->mtrep__GetRepositories);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__GetRepositories_(struct soap *soap, const char *tag, int id, const struct __mtrep7__GetRepositories_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep__GetRepositories(soap, "mtrep:GetRepositories", -1, &a->mtrep__GetRepositories, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories_ * SOAP_FMAC4 soap_in___mtrep7__GetRepositories_(struct soap *soap, const char *tag, struct __mtrep7__GetRepositories_ *a, const char *type)
{
	size_t soap_flag_mtrep__GetRepositories = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__GetRepositories_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__GetRepositories_, sizeof(struct __mtrep7__GetRepositories_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__GetRepositories_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep__GetRepositories && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep__GetRepositories(soap, "mtrep:GetRepositories", &a->mtrep__GetRepositories, ""))
				{	soap_flag_mtrep__GetRepositories--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__GetRepositories_ * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__GetRepositories_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__GetRepositories_ *p;
	size_t k = sizeof(struct __mtrep7__GetRepositories_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__GetRepositories_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__GetRepositories_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__GetRepositories_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__GetRepositories_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__GetRepositories_(struct soap *soap, const struct __mtrep7__GetRepositories_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__GetRepositories_(soap, tag?tag:"-mtrep7:GetRepositories", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories_ * SOAP_FMAC4 soap_get___mtrep7__GetRepositories_(struct soap *soap, struct __mtrep7__GetRepositories_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__GetRepositories_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__GetAllRepositories_(struct soap *soap, struct __mtrep7__GetAllRepositories_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep__GetAllRepositories = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__GetAllRepositories_(struct soap *soap, const struct __mtrep7__GetAllRepositories_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep__GetAllRepositories(soap, &a->mtrep__GetAllRepositories);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__GetAllRepositories_(struct soap *soap, const char *tag, int id, const struct __mtrep7__GetAllRepositories_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep__GetAllRepositories(soap, "mtrep:GetAllRepositories", -1, &a->mtrep__GetAllRepositories, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetAllRepositories_ * SOAP_FMAC4 soap_in___mtrep7__GetAllRepositories_(struct soap *soap, const char *tag, struct __mtrep7__GetAllRepositories_ *a, const char *type)
{
	size_t soap_flag_mtrep__GetAllRepositories = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__GetAllRepositories_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__GetAllRepositories_, sizeof(struct __mtrep7__GetAllRepositories_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__GetAllRepositories_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep__GetAllRepositories && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep__GetAllRepositories(soap, "mtrep:GetAllRepositories", &a->mtrep__GetAllRepositories, ""))
				{	soap_flag_mtrep__GetAllRepositories--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__GetAllRepositories_ * SOAP_FMAC2 repository_instantiate___mtrep7__GetAllRepositories_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__GetAllRepositories_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__GetAllRepositories_ *p;
	size_t k = sizeof(struct __mtrep7__GetAllRepositories_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__GetAllRepositories_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__GetAllRepositories_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__GetAllRepositories_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__GetAllRepositories_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__GetAllRepositories_(struct soap *soap, const struct __mtrep7__GetAllRepositories_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__GetAllRepositories_(soap, tag?tag:"-mtrep7:GetAllRepositories", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetAllRepositories_ * SOAP_FMAC4 soap_get___mtrep7__GetAllRepositories_(struct soap *soap, struct __mtrep7__GetAllRepositories_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__GetAllRepositories_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__PickRepository_(struct soap *soap, struct __mtrep7__PickRepository_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep__PickRepository = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__PickRepository_(struct soap *soap, const struct __mtrep7__PickRepository_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep__PickRepository(soap, &a->mtrep__PickRepository);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__PickRepository_(struct soap *soap, const char *tag, int id, const struct __mtrep7__PickRepository_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep__PickRepository(soap, "mtrep:PickRepository", -1, &a->mtrep__PickRepository, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository_ * SOAP_FMAC4 soap_in___mtrep7__PickRepository_(struct soap *soap, const char *tag, struct __mtrep7__PickRepository_ *a, const char *type)
{
	size_t soap_flag_mtrep__PickRepository = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__PickRepository_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__PickRepository_, sizeof(struct __mtrep7__PickRepository_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__PickRepository_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep__PickRepository && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep__PickRepository(soap, "mtrep:PickRepository", &a->mtrep__PickRepository, ""))
				{	soap_flag_mtrep__PickRepository--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__PickRepository_ * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__PickRepository_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__PickRepository_ *p;
	size_t k = sizeof(struct __mtrep7__PickRepository_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__PickRepository_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__PickRepository_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__PickRepository_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__PickRepository_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__PickRepository_(struct soap *soap, const struct __mtrep7__PickRepository_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__PickRepository_(soap, tag?tag:"-mtrep7:PickRepository", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository_ * SOAP_FMAC4 soap_get___mtrep7__PickRepository_(struct soap *soap, struct __mtrep7__PickRepository_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__PickRepository_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__TryGetRepositoryInfo_(struct soap *soap, struct __mtrep7__TryGetRepositoryInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep__TryGetRepositoryInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__TryGetRepositoryInfo_(struct soap *soap, const struct __mtrep7__TryGetRepositoryInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep__TryGetRepositoryInfo(soap, &a->mtrep__TryGetRepositoryInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__TryGetRepositoryInfo_(struct soap *soap, const char *tag, int id, const struct __mtrep7__TryGetRepositoryInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep__TryGetRepositoryInfo(soap, "mtrep:TryGetRepositoryInfo", -1, &a->mtrep__TryGetRepositoryInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__TryGetRepositoryInfo_ * SOAP_FMAC4 soap_in___mtrep7__TryGetRepositoryInfo_(struct soap *soap, const char *tag, struct __mtrep7__TryGetRepositoryInfo_ *a, const char *type)
{
	size_t soap_flag_mtrep__TryGetRepositoryInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__TryGetRepositoryInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__TryGetRepositoryInfo_, sizeof(struct __mtrep7__TryGetRepositoryInfo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__TryGetRepositoryInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep__TryGetRepositoryInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep__TryGetRepositoryInfo(soap, "mtrep:TryGetRepositoryInfo", &a->mtrep__TryGetRepositoryInfo, ""))
				{	soap_flag_mtrep__TryGetRepositoryInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__TryGetRepositoryInfo_ * SOAP_FMAC2 repository_instantiate___mtrep7__TryGetRepositoryInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__TryGetRepositoryInfo_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__TryGetRepositoryInfo_ *p;
	size_t k = sizeof(struct __mtrep7__TryGetRepositoryInfo_);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__TryGetRepositoryInfo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__TryGetRepositoryInfo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__TryGetRepositoryInfo_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__TryGetRepositoryInfo_, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__TryGetRepositoryInfo_(struct soap *soap, const struct __mtrep7__TryGetRepositoryInfo_ *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__TryGetRepositoryInfo_(soap, tag?tag:"-mtrep7:TryGetRepositoryInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__TryGetRepositoryInfo_ * SOAP_FMAC4 soap_get___mtrep7__TryGetRepositoryInfo_(struct soap *soap, struct __mtrep7__TryGetRepositoryInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__TryGetRepositoryInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__TryGetRepositoryInfo3(struct soap *soap, struct __mtrep7__TryGetRepositoryInfo3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep7__TryGetRepositoryInfo3 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__TryGetRepositoryInfo3(struct soap *soap, const struct __mtrep7__TryGetRepositoryInfo3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep7__TryGetRepositoryInfo3(soap, &a->mtrep7__TryGetRepositoryInfo3);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__TryGetRepositoryInfo3(struct soap *soap, const char *tag, int id, const struct __mtrep7__TryGetRepositoryInfo3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep7__TryGetRepositoryInfo3(soap, "mtrep7:TryGetRepositoryInfo3", -1, &a->mtrep7__TryGetRepositoryInfo3, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__TryGetRepositoryInfo3 * SOAP_FMAC4 soap_in___mtrep7__TryGetRepositoryInfo3(struct soap *soap, const char *tag, struct __mtrep7__TryGetRepositoryInfo3 *a, const char *type)
{
	size_t soap_flag_mtrep7__TryGetRepositoryInfo3 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__TryGetRepositoryInfo3 *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__TryGetRepositoryInfo3, sizeof(struct __mtrep7__TryGetRepositoryInfo3), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__TryGetRepositoryInfo3(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep7__TryGetRepositoryInfo3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep7__TryGetRepositoryInfo3(soap, "mtrep7:TryGetRepositoryInfo3", &a->mtrep7__TryGetRepositoryInfo3, ""))
				{	soap_flag_mtrep7__TryGetRepositoryInfo3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__TryGetRepositoryInfo3 * SOAP_FMAC2 repository_instantiate___mtrep7__TryGetRepositoryInfo3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__TryGetRepositoryInfo3(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__TryGetRepositoryInfo3 *p;
	size_t k = sizeof(struct __mtrep7__TryGetRepositoryInfo3);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__TryGetRepositoryInfo3);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__TryGetRepositoryInfo3, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__TryGetRepositoryInfo3 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__TryGetRepositoryInfo3, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__TryGetRepositoryInfo3(struct soap *soap, const struct __mtrep7__TryGetRepositoryInfo3 *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__TryGetRepositoryInfo3(soap, tag?tag:"-mtrep7:TryGetRepositoryInfo3", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__TryGetRepositoryInfo3 * SOAP_FMAC4 soap_get___mtrep7__TryGetRepositoryInfo3(struct soap *soap, struct __mtrep7__TryGetRepositoryInfo3 *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__TryGetRepositoryInfo3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__VerifyRepository2(struct soap *soap, struct __mtrep7__VerifyRepository2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep7__VerifyRepository2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__VerifyRepository2(struct soap *soap, const struct __mtrep7__VerifyRepository2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep7__VerifyRepository2(soap, &a->mtrep7__VerifyRepository2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__VerifyRepository2(struct soap *soap, const char *tag, int id, const struct __mtrep7__VerifyRepository2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep7__VerifyRepository2(soap, "mtrep7:VerifyRepository2", -1, &a->mtrep7__VerifyRepository2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__VerifyRepository2 * SOAP_FMAC4 soap_in___mtrep7__VerifyRepository2(struct soap *soap, const char *tag, struct __mtrep7__VerifyRepository2 *a, const char *type)
{
	size_t soap_flag_mtrep7__VerifyRepository2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__VerifyRepository2 *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__VerifyRepository2, sizeof(struct __mtrep7__VerifyRepository2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__VerifyRepository2(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep7__VerifyRepository2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep7__VerifyRepository2(soap, "mtrep7:VerifyRepository2", &a->mtrep7__VerifyRepository2, ""))
				{	soap_flag_mtrep7__VerifyRepository2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__VerifyRepository2 * SOAP_FMAC2 repository_instantiate___mtrep7__VerifyRepository2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__VerifyRepository2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__VerifyRepository2 *p;
	size_t k = sizeof(struct __mtrep7__VerifyRepository2);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__VerifyRepository2);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__VerifyRepository2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__VerifyRepository2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__VerifyRepository2, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__VerifyRepository2(struct soap *soap, const struct __mtrep7__VerifyRepository2 *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__VerifyRepository2(soap, tag?tag:"-mtrep7:VerifyRepository2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__VerifyRepository2 * SOAP_FMAC4 soap_get___mtrep7__VerifyRepository2(struct soap *soap, struct __mtrep7__VerifyRepository2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__VerifyRepository2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__PickRepository4(struct soap *soap, struct __mtrep7__PickRepository4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep6__PickRepository4 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__PickRepository4(struct soap *soap, const struct __mtrep7__PickRepository4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep6__PickRepository4(soap, &a->mtrep6__PickRepository4);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__PickRepository4(struct soap *soap, const char *tag, int id, const struct __mtrep7__PickRepository4 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep6__PickRepository4(soap, "mtrep6:PickRepository4", -1, &a->mtrep6__PickRepository4, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository4 * SOAP_FMAC4 soap_in___mtrep7__PickRepository4(struct soap *soap, const char *tag, struct __mtrep7__PickRepository4 *a, const char *type)
{
	size_t soap_flag_mtrep6__PickRepository4 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__PickRepository4 *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__PickRepository4, sizeof(struct __mtrep7__PickRepository4), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__PickRepository4(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep6__PickRepository4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep6__PickRepository4(soap, "mtrep6:PickRepository4", &a->mtrep6__PickRepository4, ""))
				{	soap_flag_mtrep6__PickRepository4--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__PickRepository4 * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__PickRepository4(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__PickRepository4 *p;
	size_t k = sizeof(struct __mtrep7__PickRepository4);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__PickRepository4);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__PickRepository4, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__PickRepository4 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__PickRepository4, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__PickRepository4(struct soap *soap, const struct __mtrep7__PickRepository4 *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__PickRepository4(soap, tag?tag:"-mtrep7:PickRepository4", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository4 * SOAP_FMAC4 soap_get___mtrep7__PickRepository4(struct soap *soap, struct __mtrep7__PickRepository4 *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__PickRepository4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__GetRepositories4(struct soap *soap, struct __mtrep7__GetRepositories4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep6__GetRepositories4 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__GetRepositories4(struct soap *soap, const struct __mtrep7__GetRepositories4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep6__GetRepositories4(soap, &a->mtrep6__GetRepositories4);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__GetRepositories4(struct soap *soap, const char *tag, int id, const struct __mtrep7__GetRepositories4 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep6__GetRepositories4(soap, "mtrep6:GetRepositories4", -1, &a->mtrep6__GetRepositories4, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories4 * SOAP_FMAC4 soap_in___mtrep7__GetRepositories4(struct soap *soap, const char *tag, struct __mtrep7__GetRepositories4 *a, const char *type)
{
	size_t soap_flag_mtrep6__GetRepositories4 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__GetRepositories4 *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__GetRepositories4, sizeof(struct __mtrep7__GetRepositories4), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__GetRepositories4(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep6__GetRepositories4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep6__GetRepositories4(soap, "mtrep6:GetRepositories4", &a->mtrep6__GetRepositories4, ""))
				{	soap_flag_mtrep6__GetRepositories4--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__GetRepositories4 * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__GetRepositories4(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__GetRepositories4 *p;
	size_t k = sizeof(struct __mtrep7__GetRepositories4);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__GetRepositories4);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__GetRepositories4, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__GetRepositories4 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__GetRepositories4, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__GetRepositories4(struct soap *soap, const struct __mtrep7__GetRepositories4 *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__GetRepositories4(soap, tag?tag:"-mtrep7:GetRepositories4", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories4 * SOAP_FMAC4 soap_get___mtrep7__GetRepositories4(struct soap *soap, struct __mtrep7__GetRepositories4 *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__GetRepositories4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__PickRepository3(struct soap *soap, struct __mtrep7__PickRepository3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep5__PickRepository3 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__PickRepository3(struct soap *soap, const struct __mtrep7__PickRepository3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep5__PickRepository3(soap, &a->mtrep5__PickRepository3);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__PickRepository3(struct soap *soap, const char *tag, int id, const struct __mtrep7__PickRepository3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep5__PickRepository3(soap, "mtrep5:PickRepository3", -1, &a->mtrep5__PickRepository3, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository3 * SOAP_FMAC4 soap_in___mtrep7__PickRepository3(struct soap *soap, const char *tag, struct __mtrep7__PickRepository3 *a, const char *type)
{
	size_t soap_flag_mtrep5__PickRepository3 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__PickRepository3 *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__PickRepository3, sizeof(struct __mtrep7__PickRepository3), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__PickRepository3(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep5__PickRepository3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep5__PickRepository3(soap, "mtrep5:PickRepository3", &a->mtrep5__PickRepository3, ""))
				{	soap_flag_mtrep5__PickRepository3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__PickRepository3 * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__PickRepository3(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__PickRepository3 *p;
	size_t k = sizeof(struct __mtrep7__PickRepository3);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__PickRepository3);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__PickRepository3, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__PickRepository3 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__PickRepository3, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__PickRepository3(struct soap *soap, const struct __mtrep7__PickRepository3 *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__PickRepository3(soap, tag?tag:"-mtrep7:PickRepository3", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository3 * SOAP_FMAC4 soap_get___mtrep7__PickRepository3(struct soap *soap, struct __mtrep7__PickRepository3 *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__PickRepository3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__GetRepositories3(struct soap *soap, struct __mtrep7__GetRepositories3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep5__GetRepositories3 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__GetRepositories3(struct soap *soap, const struct __mtrep7__GetRepositories3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep5__GetRepositories3(soap, &a->mtrep5__GetRepositories3);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__GetRepositories3(struct soap *soap, const char *tag, int id, const struct __mtrep7__GetRepositories3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep5__GetRepositories3(soap, "mtrep5:GetRepositories3", -1, &a->mtrep5__GetRepositories3, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories3 * SOAP_FMAC4 soap_in___mtrep7__GetRepositories3(struct soap *soap, const char *tag, struct __mtrep7__GetRepositories3 *a, const char *type)
{
	size_t soap_flag_mtrep5__GetRepositories3 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__GetRepositories3 *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__GetRepositories3, sizeof(struct __mtrep7__GetRepositories3), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__GetRepositories3(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep5__GetRepositories3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep5__GetRepositories3(soap, "mtrep5:GetRepositories3", &a->mtrep5__GetRepositories3, ""))
				{	soap_flag_mtrep5__GetRepositories3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__GetRepositories3 * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__GetRepositories3(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__GetRepositories3 *p;
	size_t k = sizeof(struct __mtrep7__GetRepositories3);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__GetRepositories3);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__GetRepositories3, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__GetRepositories3 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__GetRepositories3, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__GetRepositories3(struct soap *soap, const struct __mtrep7__GetRepositories3 *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__GetRepositories3(soap, tag?tag:"-mtrep7:GetRepositories3", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories3 * SOAP_FMAC4 soap_get___mtrep7__GetRepositories3(struct soap *soap, struct __mtrep7__GetRepositories3 *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__GetRepositories3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__VerifyRepository(struct soap *soap, struct __mtrep7__VerifyRepository *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep4__VerifyRepository = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__VerifyRepository(struct soap *soap, const struct __mtrep7__VerifyRepository *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep4__VerifyRepository(soap, &a->mtrep4__VerifyRepository);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__VerifyRepository(struct soap *soap, const char *tag, int id, const struct __mtrep7__VerifyRepository *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep4__VerifyRepository(soap, "mtrep4:VerifyRepository", -1, &a->mtrep4__VerifyRepository, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__VerifyRepository * SOAP_FMAC4 soap_in___mtrep7__VerifyRepository(struct soap *soap, const char *tag, struct __mtrep7__VerifyRepository *a, const char *type)
{
	size_t soap_flag_mtrep4__VerifyRepository = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__VerifyRepository *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__VerifyRepository, sizeof(struct __mtrep7__VerifyRepository), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__VerifyRepository(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep4__VerifyRepository && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep4__VerifyRepository(soap, "mtrep4:VerifyRepository", &a->mtrep4__VerifyRepository, ""))
				{	soap_flag_mtrep4__VerifyRepository--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__VerifyRepository * SOAP_FMAC2 repository_instantiate___mtrep7__VerifyRepository(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__VerifyRepository(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__VerifyRepository *p;
	size_t k = sizeof(struct __mtrep7__VerifyRepository);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__VerifyRepository);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__VerifyRepository, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__VerifyRepository location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__VerifyRepository, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__VerifyRepository(struct soap *soap, const struct __mtrep7__VerifyRepository *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__VerifyRepository(soap, tag?tag:"-mtrep7:VerifyRepository", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__VerifyRepository * SOAP_FMAC4 soap_get___mtrep7__VerifyRepository(struct soap *soap, struct __mtrep7__VerifyRepository *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__VerifyRepository(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__TryGetRepositoryInfo2(struct soap *soap, struct __mtrep7__TryGetRepositoryInfo2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep3__TryGetRepositoryInfo2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__TryGetRepositoryInfo2(struct soap *soap, const struct __mtrep7__TryGetRepositoryInfo2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep3__TryGetRepositoryInfo2(soap, &a->mtrep3__TryGetRepositoryInfo2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__TryGetRepositoryInfo2(struct soap *soap, const char *tag, int id, const struct __mtrep7__TryGetRepositoryInfo2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep3__TryGetRepositoryInfo2(soap, "mtrep3:TryGetRepositoryInfo2", -1, &a->mtrep3__TryGetRepositoryInfo2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__TryGetRepositoryInfo2 * SOAP_FMAC4 soap_in___mtrep7__TryGetRepositoryInfo2(struct soap *soap, const char *tag, struct __mtrep7__TryGetRepositoryInfo2 *a, const char *type)
{
	size_t soap_flag_mtrep3__TryGetRepositoryInfo2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__TryGetRepositoryInfo2 *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__TryGetRepositoryInfo2, sizeof(struct __mtrep7__TryGetRepositoryInfo2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__TryGetRepositoryInfo2(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep3__TryGetRepositoryInfo2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep3__TryGetRepositoryInfo2(soap, "mtrep3:TryGetRepositoryInfo2", &a->mtrep3__TryGetRepositoryInfo2, ""))
				{	soap_flag_mtrep3__TryGetRepositoryInfo2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__TryGetRepositoryInfo2 * SOAP_FMAC2 repository_instantiate___mtrep7__TryGetRepositoryInfo2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__TryGetRepositoryInfo2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__TryGetRepositoryInfo2 *p;
	size_t k = sizeof(struct __mtrep7__TryGetRepositoryInfo2);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__TryGetRepositoryInfo2);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__TryGetRepositoryInfo2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__TryGetRepositoryInfo2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__TryGetRepositoryInfo2, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__TryGetRepositoryInfo2(struct soap *soap, const struct __mtrep7__TryGetRepositoryInfo2 *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__TryGetRepositoryInfo2(soap, tag?tag:"-mtrep7:TryGetRepositoryInfo2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__TryGetRepositoryInfo2 * SOAP_FMAC4 soap_get___mtrep7__TryGetRepositoryInfo2(struct soap *soap, struct __mtrep7__TryGetRepositoryInfo2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__TryGetRepositoryInfo2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__PickRepository2(struct soap *soap, struct __mtrep7__PickRepository2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep3__PickRepository2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__PickRepository2(struct soap *soap, const struct __mtrep7__PickRepository2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep3__PickRepository2(soap, &a->mtrep3__PickRepository2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__PickRepository2(struct soap *soap, const char *tag, int id, const struct __mtrep7__PickRepository2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep3__PickRepository2(soap, "mtrep3:PickRepository2", -1, &a->mtrep3__PickRepository2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository2 * SOAP_FMAC4 soap_in___mtrep7__PickRepository2(struct soap *soap, const char *tag, struct __mtrep7__PickRepository2 *a, const char *type)
{
	size_t soap_flag_mtrep3__PickRepository2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__PickRepository2 *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__PickRepository2, sizeof(struct __mtrep7__PickRepository2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__PickRepository2(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep3__PickRepository2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep3__PickRepository2(soap, "mtrep3:PickRepository2", &a->mtrep3__PickRepository2, ""))
				{	soap_flag_mtrep3__PickRepository2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__PickRepository2 * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__PickRepository2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__PickRepository2 *p;
	size_t k = sizeof(struct __mtrep7__PickRepository2);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__PickRepository2);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__PickRepository2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__PickRepository2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__PickRepository2, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__PickRepository2(struct soap *soap, const struct __mtrep7__PickRepository2 *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__PickRepository2(soap, tag?tag:"-mtrep7:PickRepository2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository2 * SOAP_FMAC4 soap_get___mtrep7__PickRepository2(struct soap *soap, struct __mtrep7__PickRepository2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__PickRepository2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__GetRepositories2(struct soap *soap, struct __mtrep7__GetRepositories2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep3__GetRepositories2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__GetRepositories2(struct soap *soap, const struct __mtrep7__GetRepositories2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep3__GetRepositories2(soap, &a->mtrep3__GetRepositories2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__GetRepositories2(struct soap *soap, const char *tag, int id, const struct __mtrep7__GetRepositories2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep3__GetRepositories2(soap, "mtrep3:GetRepositories2", -1, &a->mtrep3__GetRepositories2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories2 * SOAP_FMAC4 soap_in___mtrep7__GetRepositories2(struct soap *soap, const char *tag, struct __mtrep7__GetRepositories2 *a, const char *type)
{
	size_t soap_flag_mtrep3__GetRepositories2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__GetRepositories2 *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__GetRepositories2, sizeof(struct __mtrep7__GetRepositories2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__GetRepositories2(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep3__GetRepositories2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep3__GetRepositories2(soap, "mtrep3:GetRepositories2", &a->mtrep3__GetRepositories2, ""))
				{	soap_flag_mtrep3__GetRepositories2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__GetRepositories2 * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__GetRepositories2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__GetRepositories2 *p;
	size_t k = sizeof(struct __mtrep7__GetRepositories2);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__GetRepositories2);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__GetRepositories2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__GetRepositories2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__GetRepositories2, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__GetRepositories2(struct soap *soap, const struct __mtrep7__GetRepositories2 *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__GetRepositories2(soap, tag?tag:"-mtrep7:GetRepositories2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories2 * SOAP_FMAC4 soap_get___mtrep7__GetRepositories2(struct soap *soap, struct __mtrep7__GetRepositories2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__GetRepositories2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__GetListCreationTime(struct soap *soap, struct __mtrep7__GetListCreationTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep2__GetListCreationTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__GetListCreationTime(struct soap *soap, const struct __mtrep7__GetListCreationTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep2__GetListCreationTime(soap, &a->mtrep2__GetListCreationTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__GetListCreationTime(struct soap *soap, const char *tag, int id, const struct __mtrep7__GetListCreationTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep2__GetListCreationTime(soap, "mtrep2:GetListCreationTime", -1, &a->mtrep2__GetListCreationTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetListCreationTime * SOAP_FMAC4 soap_in___mtrep7__GetListCreationTime(struct soap *soap, const char *tag, struct __mtrep7__GetListCreationTime *a, const char *type)
{
	size_t soap_flag_mtrep2__GetListCreationTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__GetListCreationTime *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__GetListCreationTime, sizeof(struct __mtrep7__GetListCreationTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__GetListCreationTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep2__GetListCreationTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep2__GetListCreationTime(soap, "mtrep2:GetListCreationTime", &a->mtrep2__GetListCreationTime, ""))
				{	soap_flag_mtrep2__GetListCreationTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__GetListCreationTime * SOAP_FMAC2 repository_instantiate___mtrep7__GetListCreationTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__GetListCreationTime(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__GetListCreationTime *p;
	size_t k = sizeof(struct __mtrep7__GetListCreationTime);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__GetListCreationTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__GetListCreationTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__GetListCreationTime location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__GetListCreationTime, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__GetListCreationTime(struct soap *soap, const struct __mtrep7__GetListCreationTime *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__GetListCreationTime(soap, tag?tag:"-mtrep7:GetListCreationTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetListCreationTime * SOAP_FMAC4 soap_get___mtrep7__GetListCreationTime(struct soap *soap, struct __mtrep7__GetListCreationTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__GetListCreationTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__GetRepositories(struct soap *soap, struct __mtrep7__GetRepositories *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep__GetRepositories = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__GetRepositories(struct soap *soap, const struct __mtrep7__GetRepositories *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep__GetRepositories(soap, &a->mtrep__GetRepositories);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__GetRepositories(struct soap *soap, const char *tag, int id, const struct __mtrep7__GetRepositories *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep__GetRepositories(soap, "mtrep:GetRepositories", -1, &a->mtrep__GetRepositories, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories * SOAP_FMAC4 soap_in___mtrep7__GetRepositories(struct soap *soap, const char *tag, struct __mtrep7__GetRepositories *a, const char *type)
{
	size_t soap_flag_mtrep__GetRepositories = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__GetRepositories *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__GetRepositories, sizeof(struct __mtrep7__GetRepositories), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__GetRepositories(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep__GetRepositories && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep__GetRepositories(soap, "mtrep:GetRepositories", &a->mtrep__GetRepositories, ""))
				{	soap_flag_mtrep__GetRepositories--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__GetRepositories * SOAP_FMAC2 repository_instantiate___mtrep7__GetRepositories(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__GetRepositories(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__GetRepositories *p;
	size_t k = sizeof(struct __mtrep7__GetRepositories);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__GetRepositories);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__GetRepositories, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__GetRepositories location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__GetRepositories, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__GetRepositories(struct soap *soap, const struct __mtrep7__GetRepositories *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__GetRepositories(soap, tag?tag:"-mtrep7:GetRepositories", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetRepositories * SOAP_FMAC4 soap_get___mtrep7__GetRepositories(struct soap *soap, struct __mtrep7__GetRepositories *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__GetRepositories(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__GetAllRepositories(struct soap *soap, struct __mtrep7__GetAllRepositories *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep__GetAllRepositories = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__GetAllRepositories(struct soap *soap, const struct __mtrep7__GetAllRepositories *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep__GetAllRepositories(soap, &a->mtrep__GetAllRepositories);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__GetAllRepositories(struct soap *soap, const char *tag, int id, const struct __mtrep7__GetAllRepositories *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep__GetAllRepositories(soap, "mtrep:GetAllRepositories", -1, &a->mtrep__GetAllRepositories, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetAllRepositories * SOAP_FMAC4 soap_in___mtrep7__GetAllRepositories(struct soap *soap, const char *tag, struct __mtrep7__GetAllRepositories *a, const char *type)
{
	size_t soap_flag_mtrep__GetAllRepositories = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__GetAllRepositories *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__GetAllRepositories, sizeof(struct __mtrep7__GetAllRepositories), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__GetAllRepositories(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep__GetAllRepositories && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep__GetAllRepositories(soap, "mtrep:GetAllRepositories", &a->mtrep__GetAllRepositories, ""))
				{	soap_flag_mtrep__GetAllRepositories--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__GetAllRepositories * SOAP_FMAC2 repository_instantiate___mtrep7__GetAllRepositories(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__GetAllRepositories(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__GetAllRepositories *p;
	size_t k = sizeof(struct __mtrep7__GetAllRepositories);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__GetAllRepositories);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__GetAllRepositories, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__GetAllRepositories location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__GetAllRepositories, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__GetAllRepositories(struct soap *soap, const struct __mtrep7__GetAllRepositories *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__GetAllRepositories(soap, tag?tag:"-mtrep7:GetAllRepositories", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__GetAllRepositories * SOAP_FMAC4 soap_get___mtrep7__GetAllRepositories(struct soap *soap, struct __mtrep7__GetAllRepositories *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__GetAllRepositories(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__PickRepository(struct soap *soap, struct __mtrep7__PickRepository *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep__PickRepository = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__PickRepository(struct soap *soap, const struct __mtrep7__PickRepository *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep__PickRepository(soap, &a->mtrep__PickRepository);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__PickRepository(struct soap *soap, const char *tag, int id, const struct __mtrep7__PickRepository *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep__PickRepository(soap, "mtrep:PickRepository", -1, &a->mtrep__PickRepository, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository * SOAP_FMAC4 soap_in___mtrep7__PickRepository(struct soap *soap, const char *tag, struct __mtrep7__PickRepository *a, const char *type)
{
	size_t soap_flag_mtrep__PickRepository = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__PickRepository *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__PickRepository, sizeof(struct __mtrep7__PickRepository), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__PickRepository(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep__PickRepository && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep__PickRepository(soap, "mtrep:PickRepository", &a->mtrep__PickRepository, ""))
				{	soap_flag_mtrep__PickRepository--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__PickRepository * SOAP_FMAC2 repository_instantiate___mtrep7__PickRepository(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__PickRepository(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__PickRepository *p;
	size_t k = sizeof(struct __mtrep7__PickRepository);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__PickRepository);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__PickRepository, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__PickRepository location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__PickRepository, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__PickRepository(struct soap *soap, const struct __mtrep7__PickRepository *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__PickRepository(soap, tag?tag:"-mtrep7:PickRepository", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__PickRepository * SOAP_FMAC4 soap_get___mtrep7__PickRepository(struct soap *soap, struct __mtrep7__PickRepository *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__PickRepository(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___mtrep7__TryGetRepositoryInfo(struct soap *soap, struct __mtrep7__TryGetRepositoryInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtrep__TryGetRepositoryInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___mtrep7__TryGetRepositoryInfo(struct soap *soap, const struct __mtrep7__TryGetRepositoryInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_mtrep__TryGetRepositoryInfo(soap, &a->mtrep__TryGetRepositoryInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___mtrep7__TryGetRepositoryInfo(struct soap *soap, const char *tag, int id, const struct __mtrep7__TryGetRepositoryInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_mtrep__TryGetRepositoryInfo(soap, "mtrep:TryGetRepositoryInfo", -1, &a->mtrep__TryGetRepositoryInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__TryGetRepositoryInfo * SOAP_FMAC4 soap_in___mtrep7__TryGetRepositoryInfo(struct soap *soap, const char *tag, struct __mtrep7__TryGetRepositoryInfo *a, const char *type)
{
	size_t soap_flag_mtrep__TryGetRepositoryInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __mtrep7__TryGetRepositoryInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___mtrep7__TryGetRepositoryInfo, sizeof(struct __mtrep7__TryGetRepositoryInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___mtrep7__TryGetRepositoryInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtrep__TryGetRepositoryInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_mtrep__TryGetRepositoryInfo(soap, "mtrep:TryGetRepositoryInfo", &a->mtrep__TryGetRepositoryInfo, ""))
				{	soap_flag_mtrep__TryGetRepositoryInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __mtrep7__TryGetRepositoryInfo * SOAP_FMAC2 repository_instantiate___mtrep7__TryGetRepositoryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate___mtrep7__TryGetRepositoryInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __mtrep7__TryGetRepositoryInfo *p;
	size_t k = sizeof(struct __mtrep7__TryGetRepositoryInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __mtrep7__TryGetRepositoryInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __mtrep7__TryGetRepositoryInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __mtrep7__TryGetRepositoryInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___mtrep7__TryGetRepositoryInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___mtrep7__TryGetRepositoryInfo(struct soap *soap, const struct __mtrep7__TryGetRepositoryInfo *a, const char *tag, const char *type)
{
	if (soap_out___mtrep7__TryGetRepositoryInfo(soap, tag?tag:"-mtrep7:TryGetRepositoryInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __mtrep7__TryGetRepositoryInfo * SOAP_FMAC4 soap_get___mtrep7__TryGetRepositoryInfo(struct soap *soap, struct __mtrep7__TryGetRepositoryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___mtrep7__TryGetRepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep7__TryGetRepositoryInfo3(struct soap *soap, _mtrep7__TryGetRepositoryInfo3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep7__TryGetRepositoryInfo3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep7__TryGetRepositoryInfo3(struct soap *soap, const char *tag, int id, _mtrep7__TryGetRepositoryInfo3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep7__TryGetRepositoryInfo3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep7__TryGetRepositoryInfo3 ** SOAP_FMAC4 soap_in_PointerTo_mtrep7__TryGetRepositoryInfo3(struct soap *soap, const char *tag, _mtrep7__TryGetRepositoryInfo3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep7__TryGetRepositoryInfo3 **)soap_malloc(soap, sizeof(_mtrep7__TryGetRepositoryInfo3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep7__TryGetRepositoryInfo3 *)repository_instantiate__mtrep7__TryGetRepositoryInfo3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep7__TryGetRepositoryInfo3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep7__TryGetRepositoryInfo3, sizeof(_mtrep7__TryGetRepositoryInfo3), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep7__TryGetRepositoryInfo3(struct soap *soap, _mtrep7__TryGetRepositoryInfo3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep7__TryGetRepositoryInfo3(soap, tag?tag:"mtrep7:TryGetRepositoryInfo3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep7__TryGetRepositoryInfo3 ** SOAP_FMAC4 soap_get_PointerTo_mtrep7__TryGetRepositoryInfo3(struct soap *soap, _mtrep7__TryGetRepositoryInfo3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep7__TryGetRepositoryInfo3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep7__VerifyRepository2(struct soap *soap, _mtrep7__VerifyRepository2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep7__VerifyRepository2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep7__VerifyRepository2(struct soap *soap, const char *tag, int id, _mtrep7__VerifyRepository2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep7__VerifyRepository2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep7__VerifyRepository2 ** SOAP_FMAC4 soap_in_PointerTo_mtrep7__VerifyRepository2(struct soap *soap, const char *tag, _mtrep7__VerifyRepository2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep7__VerifyRepository2 **)soap_malloc(soap, sizeof(_mtrep7__VerifyRepository2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep7__VerifyRepository2 *)repository_instantiate__mtrep7__VerifyRepository2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep7__VerifyRepository2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep7__VerifyRepository2, sizeof(_mtrep7__VerifyRepository2), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep7__VerifyRepository2(struct soap *soap, _mtrep7__VerifyRepository2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep7__VerifyRepository2(soap, tag?tag:"mtrep7:VerifyRepository2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep7__VerifyRepository2 ** SOAP_FMAC4 soap_get_PointerTo_mtrep7__VerifyRepository2(struct soap *soap, _mtrep7__VerifyRepository2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep7__VerifyRepository2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep6__PickRepository4(struct soap *soap, _mtrep6__PickRepository4 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep6__PickRepository4))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep6__PickRepository4(struct soap *soap, const char *tag, int id, _mtrep6__PickRepository4 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep6__PickRepository4, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep6__PickRepository4 ** SOAP_FMAC4 soap_in_PointerTo_mtrep6__PickRepository4(struct soap *soap, const char *tag, _mtrep6__PickRepository4 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep6__PickRepository4 **)soap_malloc(soap, sizeof(_mtrep6__PickRepository4 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep6__PickRepository4 *)repository_instantiate__mtrep6__PickRepository4(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep6__PickRepository4 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep6__PickRepository4, sizeof(_mtrep6__PickRepository4), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep6__PickRepository4(struct soap *soap, _mtrep6__PickRepository4 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep6__PickRepository4(soap, tag?tag:"mtrep6:PickRepository4", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep6__PickRepository4 ** SOAP_FMAC4 soap_get_PointerTo_mtrep6__PickRepository4(struct soap *soap, _mtrep6__PickRepository4 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep6__PickRepository4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep6__GetRepositories4(struct soap *soap, _mtrep6__GetRepositories4 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep6__GetRepositories4))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep6__GetRepositories4(struct soap *soap, const char *tag, int id, _mtrep6__GetRepositories4 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep6__GetRepositories4, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep6__GetRepositories4 ** SOAP_FMAC4 soap_in_PointerTo_mtrep6__GetRepositories4(struct soap *soap, const char *tag, _mtrep6__GetRepositories4 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep6__GetRepositories4 **)soap_malloc(soap, sizeof(_mtrep6__GetRepositories4 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep6__GetRepositories4 *)repository_instantiate__mtrep6__GetRepositories4(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep6__GetRepositories4 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep6__GetRepositories4, sizeof(_mtrep6__GetRepositories4), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep6__GetRepositories4(struct soap *soap, _mtrep6__GetRepositories4 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep6__GetRepositories4(soap, tag?tag:"mtrep6:GetRepositories4", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep6__GetRepositories4 ** SOAP_FMAC4 soap_get_PointerTo_mtrep6__GetRepositories4(struct soap *soap, _mtrep6__GetRepositories4 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep6__GetRepositories4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep5__PickRepository3(struct soap *soap, _mtrep5__PickRepository3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep5__PickRepository3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep5__PickRepository3(struct soap *soap, const char *tag, int id, _mtrep5__PickRepository3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep5__PickRepository3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep5__PickRepository3 ** SOAP_FMAC4 soap_in_PointerTo_mtrep5__PickRepository3(struct soap *soap, const char *tag, _mtrep5__PickRepository3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep5__PickRepository3 **)soap_malloc(soap, sizeof(_mtrep5__PickRepository3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep5__PickRepository3 *)repository_instantiate__mtrep5__PickRepository3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep5__PickRepository3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep5__PickRepository3, sizeof(_mtrep5__PickRepository3), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep5__PickRepository3(struct soap *soap, _mtrep5__PickRepository3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep5__PickRepository3(soap, tag?tag:"mtrep5:PickRepository3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep5__PickRepository3 ** SOAP_FMAC4 soap_get_PointerTo_mtrep5__PickRepository3(struct soap *soap, _mtrep5__PickRepository3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep5__PickRepository3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep5__GetRepositories3(struct soap *soap, _mtrep5__GetRepositories3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep5__GetRepositories3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep5__GetRepositories3(struct soap *soap, const char *tag, int id, _mtrep5__GetRepositories3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep5__GetRepositories3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep5__GetRepositories3 ** SOAP_FMAC4 soap_in_PointerTo_mtrep5__GetRepositories3(struct soap *soap, const char *tag, _mtrep5__GetRepositories3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep5__GetRepositories3 **)soap_malloc(soap, sizeof(_mtrep5__GetRepositories3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep5__GetRepositories3 *)repository_instantiate__mtrep5__GetRepositories3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep5__GetRepositories3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep5__GetRepositories3, sizeof(_mtrep5__GetRepositories3), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep5__GetRepositories3(struct soap *soap, _mtrep5__GetRepositories3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep5__GetRepositories3(soap, tag?tag:"mtrep5:GetRepositories3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep5__GetRepositories3 ** SOAP_FMAC4 soap_get_PointerTo_mtrep5__GetRepositories3(struct soap *soap, _mtrep5__GetRepositories3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep5__GetRepositories3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep4__VerifyRepository(struct soap *soap, _mtrep4__VerifyRepository *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep4__VerifyRepository))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep4__VerifyRepository(struct soap *soap, const char *tag, int id, _mtrep4__VerifyRepository *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep4__VerifyRepository, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep4__VerifyRepository ** SOAP_FMAC4 soap_in_PointerTo_mtrep4__VerifyRepository(struct soap *soap, const char *tag, _mtrep4__VerifyRepository **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep4__VerifyRepository **)soap_malloc(soap, sizeof(_mtrep4__VerifyRepository *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep4__VerifyRepository *)repository_instantiate__mtrep4__VerifyRepository(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep4__VerifyRepository **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep4__VerifyRepository, sizeof(_mtrep4__VerifyRepository), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep4__VerifyRepository(struct soap *soap, _mtrep4__VerifyRepository *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep4__VerifyRepository(soap, tag?tag:"mtrep4:VerifyRepository", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep4__VerifyRepository ** SOAP_FMAC4 soap_get_PointerTo_mtrep4__VerifyRepository(struct soap *soap, _mtrep4__VerifyRepository **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep4__VerifyRepository(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep3__TryGetRepositoryInfo2(struct soap *soap, _mtrep3__TryGetRepositoryInfo2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep3__TryGetRepositoryInfo2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep3__TryGetRepositoryInfo2(struct soap *soap, const char *tag, int id, _mtrep3__TryGetRepositoryInfo2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep3__TryGetRepositoryInfo2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep3__TryGetRepositoryInfo2 ** SOAP_FMAC4 soap_in_PointerTo_mtrep3__TryGetRepositoryInfo2(struct soap *soap, const char *tag, _mtrep3__TryGetRepositoryInfo2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep3__TryGetRepositoryInfo2 **)soap_malloc(soap, sizeof(_mtrep3__TryGetRepositoryInfo2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep3__TryGetRepositoryInfo2 *)repository_instantiate__mtrep3__TryGetRepositoryInfo2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep3__TryGetRepositoryInfo2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep3__TryGetRepositoryInfo2, sizeof(_mtrep3__TryGetRepositoryInfo2), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep3__TryGetRepositoryInfo2(struct soap *soap, _mtrep3__TryGetRepositoryInfo2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep3__TryGetRepositoryInfo2(soap, tag?tag:"mtrep3:TryGetRepositoryInfo2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep3__TryGetRepositoryInfo2 ** SOAP_FMAC4 soap_get_PointerTo_mtrep3__TryGetRepositoryInfo2(struct soap *soap, _mtrep3__TryGetRepositoryInfo2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep3__TryGetRepositoryInfo2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep3__PickRepository2(struct soap *soap, _mtrep3__PickRepository2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep3__PickRepository2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep3__PickRepository2(struct soap *soap, const char *tag, int id, _mtrep3__PickRepository2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep3__PickRepository2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep3__PickRepository2 ** SOAP_FMAC4 soap_in_PointerTo_mtrep3__PickRepository2(struct soap *soap, const char *tag, _mtrep3__PickRepository2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep3__PickRepository2 **)soap_malloc(soap, sizeof(_mtrep3__PickRepository2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep3__PickRepository2 *)repository_instantiate__mtrep3__PickRepository2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep3__PickRepository2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep3__PickRepository2, sizeof(_mtrep3__PickRepository2), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep3__PickRepository2(struct soap *soap, _mtrep3__PickRepository2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep3__PickRepository2(soap, tag?tag:"mtrep3:PickRepository2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep3__PickRepository2 ** SOAP_FMAC4 soap_get_PointerTo_mtrep3__PickRepository2(struct soap *soap, _mtrep3__PickRepository2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep3__PickRepository2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep3__GetRepositories2(struct soap *soap, _mtrep3__GetRepositories2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep3__GetRepositories2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep3__GetRepositories2(struct soap *soap, const char *tag, int id, _mtrep3__GetRepositories2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep3__GetRepositories2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep3__GetRepositories2 ** SOAP_FMAC4 soap_in_PointerTo_mtrep3__GetRepositories2(struct soap *soap, const char *tag, _mtrep3__GetRepositories2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep3__GetRepositories2 **)soap_malloc(soap, sizeof(_mtrep3__GetRepositories2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep3__GetRepositories2 *)repository_instantiate__mtrep3__GetRepositories2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep3__GetRepositories2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep3__GetRepositories2, sizeof(_mtrep3__GetRepositories2), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep3__GetRepositories2(struct soap *soap, _mtrep3__GetRepositories2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep3__GetRepositories2(soap, tag?tag:"mtrep3:GetRepositories2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep3__GetRepositories2 ** SOAP_FMAC4 soap_get_PointerTo_mtrep3__GetRepositories2(struct soap *soap, _mtrep3__GetRepositories2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep3__GetRepositories2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep2__GetListCreationTime(struct soap *soap, _mtrep2__GetListCreationTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep2__GetListCreationTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep2__GetListCreationTime(struct soap *soap, const char *tag, int id, _mtrep2__GetListCreationTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep2__GetListCreationTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep2__GetListCreationTime ** SOAP_FMAC4 soap_in_PointerTo_mtrep2__GetListCreationTime(struct soap *soap, const char *tag, _mtrep2__GetListCreationTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep2__GetListCreationTime **)soap_malloc(soap, sizeof(_mtrep2__GetListCreationTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep2__GetListCreationTime *)repository_instantiate__mtrep2__GetListCreationTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep2__GetListCreationTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep2__GetListCreationTime, sizeof(_mtrep2__GetListCreationTime), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep2__GetListCreationTime(struct soap *soap, _mtrep2__GetListCreationTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep2__GetListCreationTime(soap, tag?tag:"mtrep2:GetListCreationTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep2__GetListCreationTime ** SOAP_FMAC4 soap_get_PointerTo_mtrep2__GetListCreationTime(struct soap *soap, _mtrep2__GetListCreationTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep2__GetListCreationTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep__GetRepositories(struct soap *soap, _mtrep__GetRepositories *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep__GetRepositories))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep__GetRepositories(struct soap *soap, const char *tag, int id, _mtrep__GetRepositories *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep__GetRepositories, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep__GetRepositories ** SOAP_FMAC4 soap_in_PointerTo_mtrep__GetRepositories(struct soap *soap, const char *tag, _mtrep__GetRepositories **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep__GetRepositories **)soap_malloc(soap, sizeof(_mtrep__GetRepositories *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep__GetRepositories *)repository_instantiate__mtrep__GetRepositories(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep__GetRepositories **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep__GetRepositories, sizeof(_mtrep__GetRepositories), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep__GetRepositories(struct soap *soap, _mtrep__GetRepositories *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep__GetRepositories(soap, tag?tag:"mtrep:GetRepositories", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep__GetRepositories ** SOAP_FMAC4 soap_get_PointerTo_mtrep__GetRepositories(struct soap *soap, _mtrep__GetRepositories **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep__GetRepositories(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep__GetAllRepositories(struct soap *soap, _mtrep__GetAllRepositories *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep__GetAllRepositories))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep__GetAllRepositories(struct soap *soap, const char *tag, int id, _mtrep__GetAllRepositories *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep__GetAllRepositories, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep__GetAllRepositories ** SOAP_FMAC4 soap_in_PointerTo_mtrep__GetAllRepositories(struct soap *soap, const char *tag, _mtrep__GetAllRepositories **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep__GetAllRepositories **)soap_malloc(soap, sizeof(_mtrep__GetAllRepositories *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep__GetAllRepositories *)repository_instantiate__mtrep__GetAllRepositories(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep__GetAllRepositories **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep__GetAllRepositories, sizeof(_mtrep__GetAllRepositories), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep__GetAllRepositories(struct soap *soap, _mtrep__GetAllRepositories *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep__GetAllRepositories(soap, tag?tag:"mtrep:GetAllRepositories", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep__GetAllRepositories ** SOAP_FMAC4 soap_get_PointerTo_mtrep__GetAllRepositories(struct soap *soap, _mtrep__GetAllRepositories **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep__GetAllRepositories(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep__PickRepository(struct soap *soap, _mtrep__PickRepository *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep__PickRepository))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep__PickRepository(struct soap *soap, const char *tag, int id, _mtrep__PickRepository *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep__PickRepository, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep__PickRepository ** SOAP_FMAC4 soap_in_PointerTo_mtrep__PickRepository(struct soap *soap, const char *tag, _mtrep__PickRepository **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep__PickRepository **)soap_malloc(soap, sizeof(_mtrep__PickRepository *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep__PickRepository *)repository_instantiate__mtrep__PickRepository(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep__PickRepository **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep__PickRepository, sizeof(_mtrep__PickRepository), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep__PickRepository(struct soap *soap, _mtrep__PickRepository *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep__PickRepository(soap, tag?tag:"mtrep:PickRepository", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep__PickRepository ** SOAP_FMAC4 soap_get_PointerTo_mtrep__PickRepository(struct soap *soap, _mtrep__PickRepository **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep__PickRepository(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_mtrep__TryGetRepositoryInfo(struct soap *soap, _mtrep__TryGetRepositoryInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__mtrep__TryGetRepositoryInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_mtrep__TryGetRepositoryInfo(struct soap *soap, const char *tag, int id, _mtrep__TryGetRepositoryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__mtrep__TryGetRepositoryInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _mtrep__TryGetRepositoryInfo ** SOAP_FMAC4 soap_in_PointerTo_mtrep__TryGetRepositoryInfo(struct soap *soap, const char *tag, _mtrep__TryGetRepositoryInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_mtrep__TryGetRepositoryInfo **)soap_malloc(soap, sizeof(_mtrep__TryGetRepositoryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_mtrep__TryGetRepositoryInfo *)repository_instantiate__mtrep__TryGetRepositoryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_mtrep__TryGetRepositoryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__mtrep__TryGetRepositoryInfo, sizeof(_mtrep__TryGetRepositoryInfo), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_mtrep__TryGetRepositoryInfo(struct soap *soap, _mtrep__TryGetRepositoryInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_mtrep__TryGetRepositoryInfo(soap, tag?tag:"mtrep:TryGetRepositoryInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _mtrep__TryGetRepositoryInfo ** SOAP_FMAC4 soap_get_PointerTo_mtrep__TryGetRepositoryInfo(struct soap *soap, _mtrep__TryGetRepositoryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_mtrep__TryGetRepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep7__RepositoryInfo3(struct soap *soap, mtrep7__RepositoryInfo3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep7__RepositoryInfo3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep7__RepositoryInfo3(struct soap *soap, const char *tag, int id, mtrep7__RepositoryInfo3 *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep7__RepositoryInfo3, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 mtrep7__RepositoryInfo3 ** SOAP_FMAC4 soap_in_PointerTomtrep7__RepositoryInfo3(struct soap *soap, const char *tag, mtrep7__RepositoryInfo3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep7__RepositoryInfo3 **)soap_malloc(soap, sizeof(mtrep7__RepositoryInfo3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep7__RepositoryInfo3 *)repository_instantiate_mtrep7__RepositoryInfo3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep7__RepositoryInfo3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep7__RepositoryInfo3, sizeof(mtrep7__RepositoryInfo3), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep7__RepositoryInfo3(struct soap *soap, mtrep7__RepositoryInfo3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep7__RepositoryInfo3(soap, tag?tag:"mtrep7:RepositoryInfo3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep7__RepositoryInfo3 ** SOAP_FMAC4 soap_get_PointerTomtrep7__RepositoryInfo3(struct soap *soap, mtrep7__RepositoryInfo3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep7__RepositoryInfo3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep7__ClientInfo(struct soap *soap, mtrep7__ClientInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep7__ClientInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep7__ClientInfo(struct soap *soap, const char *tag, int id, mtrep7__ClientInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep7__ClientInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 mtrep7__ClientInfo ** SOAP_FMAC4 soap_in_PointerTomtrep7__ClientInfo(struct soap *soap, const char *tag, mtrep7__ClientInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep7__ClientInfo **)soap_malloc(soap, sizeof(mtrep7__ClientInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep7__ClientInfo *)repository_instantiate_mtrep7__ClientInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep7__ClientInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep7__ClientInfo, sizeof(mtrep7__ClientInfo), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep7__ClientInfo(struct soap *soap, mtrep7__ClientInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep7__ClientInfo(soap, tag?tag:"mtrep7:ClientInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep7__ClientInfo ** SOAP_FMAC4 soap_get_PointerTomtrep7__ClientInfo(struct soap *soap, mtrep7__ClientInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep7__ClientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep6__ArrayOfRepositoryInfo3(struct soap *soap, mtrep6__ArrayOfRepositoryInfo3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep6__ArrayOfRepositoryInfo3(struct soap *soap, const char *tag, int id, mtrep6__ArrayOfRepositoryInfo3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 mtrep6__ArrayOfRepositoryInfo3 ** SOAP_FMAC4 soap_in_PointerTomtrep6__ArrayOfRepositoryInfo3(struct soap *soap, const char *tag, mtrep6__ArrayOfRepositoryInfo3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep6__ArrayOfRepositoryInfo3 **)soap_malloc(soap, sizeof(mtrep6__ArrayOfRepositoryInfo3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep6__ArrayOfRepositoryInfo3 *)repository_instantiate_mtrep6__ArrayOfRepositoryInfo3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep6__ArrayOfRepositoryInfo3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep6__ArrayOfRepositoryInfo3, sizeof(mtrep6__ArrayOfRepositoryInfo3), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep6__ArrayOfRepositoryInfo3(struct soap *soap, mtrep6__ArrayOfRepositoryInfo3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep6__ArrayOfRepositoryInfo3(soap, tag?tag:"mtrep6:ArrayOfRepositoryInfo3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep6__ArrayOfRepositoryInfo3 ** SOAP_FMAC4 soap_get_PointerTomtrep6__ArrayOfRepositoryInfo3(struct soap *soap, mtrep6__ArrayOfRepositoryInfo3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep6__ArrayOfRepositoryInfo3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep6__ClientInfo(struct soap *soap, mtrep6__ClientInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep6__ClientInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep6__ClientInfo(struct soap *soap, const char *tag, int id, mtrep6__ClientInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep6__ClientInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 mtrep6__ClientInfo ** SOAP_FMAC4 soap_in_PointerTomtrep6__ClientInfo(struct soap *soap, const char *tag, mtrep6__ClientInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep6__ClientInfo **)soap_malloc(soap, sizeof(mtrep6__ClientInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep6__ClientInfo *)repository_instantiate_mtrep6__ClientInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep6__ClientInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep6__ClientInfo, sizeof(mtrep6__ClientInfo), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep6__ClientInfo(struct soap *soap, mtrep6__ClientInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep6__ClientInfo(soap, tag?tag:"mtrep6:ClientInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep6__ClientInfo ** SOAP_FMAC4 soap_get_PointerTomtrep6__ClientInfo(struct soap *soap, mtrep6__ClientInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep6__ClientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep6__RepositoryInfo3(struct soap *soap, mtrep6__RepositoryInfo3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep6__RepositoryInfo3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep6__RepositoryInfo3(struct soap *soap, const char *tag, int id, mtrep6__RepositoryInfo3 *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep6__RepositoryInfo3, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 mtrep6__RepositoryInfo3 ** SOAP_FMAC4 soap_in_PointerTomtrep6__RepositoryInfo3(struct soap *soap, const char *tag, mtrep6__RepositoryInfo3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep6__RepositoryInfo3 **)soap_malloc(soap, sizeof(mtrep6__RepositoryInfo3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep6__RepositoryInfo3 *)repository_instantiate_mtrep6__RepositoryInfo3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep6__RepositoryInfo3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep6__RepositoryInfo3, sizeof(mtrep6__RepositoryInfo3), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep6__RepositoryInfo3(struct soap *soap, mtrep6__RepositoryInfo3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep6__RepositoryInfo3(soap, tag?tag:"mtrep6:RepositoryInfo3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep6__RepositoryInfo3 ** SOAP_FMAC4 soap_get_PointerTomtrep6__RepositoryInfo3(struct soap *soap, mtrep6__RepositoryInfo3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep6__RepositoryInfo3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep5__ArrayOfRepositoryInfo2(struct soap *soap, mtrep5__ArrayOfRepositoryInfo2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep5__ArrayOfRepositoryInfo2(struct soap *soap, const char *tag, int id, mtrep5__ArrayOfRepositoryInfo2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 mtrep5__ArrayOfRepositoryInfo2 ** SOAP_FMAC4 soap_in_PointerTomtrep5__ArrayOfRepositoryInfo2(struct soap *soap, const char *tag, mtrep5__ArrayOfRepositoryInfo2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep5__ArrayOfRepositoryInfo2 **)soap_malloc(soap, sizeof(mtrep5__ArrayOfRepositoryInfo2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep5__ArrayOfRepositoryInfo2 *)repository_instantiate_mtrep5__ArrayOfRepositoryInfo2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep5__ArrayOfRepositoryInfo2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep5__ArrayOfRepositoryInfo2, sizeof(mtrep5__ArrayOfRepositoryInfo2), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep5__ArrayOfRepositoryInfo2(struct soap *soap, mtrep5__ArrayOfRepositoryInfo2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep5__ArrayOfRepositoryInfo2(soap, tag?tag:"mtrep5:ArrayOfRepositoryInfo2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep5__ArrayOfRepositoryInfo2 ** SOAP_FMAC4 soap_get_PointerTomtrep5__ArrayOfRepositoryInfo2(struct soap *soap, mtrep5__ArrayOfRepositoryInfo2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep5__ArrayOfRepositoryInfo2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep5__ClientInfo(struct soap *soap, mtrep5__ClientInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep5__ClientInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep5__ClientInfo(struct soap *soap, const char *tag, int id, mtrep5__ClientInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep5__ClientInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 mtrep5__ClientInfo ** SOAP_FMAC4 soap_in_PointerTomtrep5__ClientInfo(struct soap *soap, const char *tag, mtrep5__ClientInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep5__ClientInfo **)soap_malloc(soap, sizeof(mtrep5__ClientInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep5__ClientInfo *)repository_instantiate_mtrep5__ClientInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep5__ClientInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep5__ClientInfo, sizeof(mtrep5__ClientInfo), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep5__ClientInfo(struct soap *soap, mtrep5__ClientInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep5__ClientInfo(soap, tag?tag:"mtrep5:ClientInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep5__ClientInfo ** SOAP_FMAC4 soap_get_PointerTomtrep5__ClientInfo(struct soap *soap, mtrep5__ClientInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep5__ClientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep5__RepositoryInfo2(struct soap *soap, mtrep5__RepositoryInfo2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep5__RepositoryInfo2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep5__RepositoryInfo2(struct soap *soap, const char *tag, int id, mtrep5__RepositoryInfo2 *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep5__RepositoryInfo2, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 mtrep5__RepositoryInfo2 ** SOAP_FMAC4 soap_in_PointerTomtrep5__RepositoryInfo2(struct soap *soap, const char *tag, mtrep5__RepositoryInfo2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep5__RepositoryInfo2 **)soap_malloc(soap, sizeof(mtrep5__RepositoryInfo2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep5__RepositoryInfo2 *)repository_instantiate_mtrep5__RepositoryInfo2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep5__RepositoryInfo2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep5__RepositoryInfo2, sizeof(mtrep5__RepositoryInfo2), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep5__RepositoryInfo2(struct soap *soap, mtrep5__RepositoryInfo2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep5__RepositoryInfo2(soap, tag?tag:"mtrep5:RepositoryInfo2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep5__RepositoryInfo2 ** SOAP_FMAC4 soap_get_PointerTomtrep5__RepositoryInfo2(struct soap *soap, mtrep5__RepositoryInfo2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep5__RepositoryInfo2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep4__RepositoryInfo(struct soap *soap, mtrep4__RepositoryInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep4__RepositoryInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep4__RepositoryInfo(struct soap *soap, const char *tag, int id, mtrep4__RepositoryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep4__RepositoryInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 mtrep4__RepositoryInfo ** SOAP_FMAC4 soap_in_PointerTomtrep4__RepositoryInfo(struct soap *soap, const char *tag, mtrep4__RepositoryInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep4__RepositoryInfo **)soap_malloc(soap, sizeof(mtrep4__RepositoryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep4__RepositoryInfo *)repository_instantiate_mtrep4__RepositoryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep4__RepositoryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep4__RepositoryInfo, sizeof(mtrep4__RepositoryInfo), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep4__RepositoryInfo(struct soap *soap, mtrep4__RepositoryInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep4__RepositoryInfo(soap, tag?tag:"mtrep4:RepositoryInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep4__RepositoryInfo ** SOAP_FMAC4 soap_get_PointerTomtrep4__RepositoryInfo(struct soap *soap, mtrep4__RepositoryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep4__RepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep4__ClientInfo(struct soap *soap, mtrep4__ClientInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep4__ClientInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep4__ClientInfo(struct soap *soap, const char *tag, int id, mtrep4__ClientInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep4__ClientInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 mtrep4__ClientInfo ** SOAP_FMAC4 soap_in_PointerTomtrep4__ClientInfo(struct soap *soap, const char *tag, mtrep4__ClientInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep4__ClientInfo **)soap_malloc(soap, sizeof(mtrep4__ClientInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep4__ClientInfo *)repository_instantiate_mtrep4__ClientInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep4__ClientInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep4__ClientInfo, sizeof(mtrep4__ClientInfo), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep4__ClientInfo(struct soap *soap, mtrep4__ClientInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep4__ClientInfo(soap, tag?tag:"mtrep4:ClientInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep4__ClientInfo ** SOAP_FMAC4 soap_get_PointerTomtrep4__ClientInfo(struct soap *soap, mtrep4__ClientInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep4__ClientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep3__ArrayOfRepositoryInfo(struct soap *soap, mtrep3__ArrayOfRepositoryInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep3__ArrayOfRepositoryInfo(struct soap *soap, const char *tag, int id, mtrep3__ArrayOfRepositoryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 mtrep3__ArrayOfRepositoryInfo ** SOAP_FMAC4 soap_in_PointerTomtrep3__ArrayOfRepositoryInfo(struct soap *soap, const char *tag, mtrep3__ArrayOfRepositoryInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep3__ArrayOfRepositoryInfo **)soap_malloc(soap, sizeof(mtrep3__ArrayOfRepositoryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep3__ArrayOfRepositoryInfo *)repository_instantiate_mtrep3__ArrayOfRepositoryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep3__ArrayOfRepositoryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep3__ArrayOfRepositoryInfo, sizeof(mtrep3__ArrayOfRepositoryInfo), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep3__ArrayOfRepositoryInfo(struct soap *soap, mtrep3__ArrayOfRepositoryInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep3__ArrayOfRepositoryInfo(soap, tag?tag:"mtrep3:ArrayOfRepositoryInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep3__ArrayOfRepositoryInfo ** SOAP_FMAC4 soap_get_PointerTomtrep3__ArrayOfRepositoryInfo(struct soap *soap, mtrep3__ArrayOfRepositoryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep3__ArrayOfRepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep3__ClientInfo(struct soap *soap, mtrep3__ClientInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep3__ClientInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep3__ClientInfo(struct soap *soap, const char *tag, int id, mtrep3__ClientInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep3__ClientInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 mtrep3__ClientInfo ** SOAP_FMAC4 soap_in_PointerTomtrep3__ClientInfo(struct soap *soap, const char *tag, mtrep3__ClientInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep3__ClientInfo **)soap_malloc(soap, sizeof(mtrep3__ClientInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep3__ClientInfo *)repository_instantiate_mtrep3__ClientInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep3__ClientInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep3__ClientInfo, sizeof(mtrep3__ClientInfo), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep3__ClientInfo(struct soap *soap, mtrep3__ClientInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep3__ClientInfo(soap, tag?tag:"mtrep3:ClientInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep3__ClientInfo ** SOAP_FMAC4 soap_get_PointerTomtrep3__ClientInfo(struct soap *soap, mtrep3__ClientInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep3__ClientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep3__RepositoryInfo(struct soap *soap, mtrep3__RepositoryInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep3__RepositoryInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep3__RepositoryInfo(struct soap *soap, const char *tag, int id, mtrep3__RepositoryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep3__RepositoryInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 mtrep3__RepositoryInfo ** SOAP_FMAC4 soap_in_PointerTomtrep3__RepositoryInfo(struct soap *soap, const char *tag, mtrep3__RepositoryInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep3__RepositoryInfo **)soap_malloc(soap, sizeof(mtrep3__RepositoryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep3__RepositoryInfo *)repository_instantiate_mtrep3__RepositoryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep3__RepositoryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep3__RepositoryInfo, sizeof(mtrep3__RepositoryInfo), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep3__RepositoryInfo(struct soap *soap, mtrep3__RepositoryInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep3__RepositoryInfo(soap, tag?tag:"mtrep3:RepositoryInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep3__RepositoryInfo ** SOAP_FMAC4 soap_get_PointerTomtrep3__RepositoryInfo(struct soap *soap, mtrep3__RepositoryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep3__RepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep__ArrayOfRepositoryInfo(struct soap *soap, mtrep__ArrayOfRepositoryInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep__ArrayOfRepositoryInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep__ArrayOfRepositoryInfo(struct soap *soap, const char *tag, int id, mtrep__ArrayOfRepositoryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep__ArrayOfRepositoryInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 mtrep__ArrayOfRepositoryInfo ** SOAP_FMAC4 soap_in_PointerTomtrep__ArrayOfRepositoryInfo(struct soap *soap, const char *tag, mtrep__ArrayOfRepositoryInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep__ArrayOfRepositoryInfo **)soap_malloc(soap, sizeof(mtrep__ArrayOfRepositoryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep__ArrayOfRepositoryInfo *)repository_instantiate_mtrep__ArrayOfRepositoryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep__ArrayOfRepositoryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep__ArrayOfRepositoryInfo, sizeof(mtrep__ArrayOfRepositoryInfo), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep__ArrayOfRepositoryInfo(struct soap *soap, mtrep__ArrayOfRepositoryInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep__ArrayOfRepositoryInfo(soap, tag?tag:"mtrep:ArrayOfRepositoryInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep__ArrayOfRepositoryInfo ** SOAP_FMAC4 soap_get_PointerTomtrep__ArrayOfRepositoryInfo(struct soap *soap, mtrep__ArrayOfRepositoryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep__ArrayOfRepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomtrep__RepositoryInfo(struct soap *soap, mtrep__RepositoryInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mtrep__RepositoryInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomtrep__RepositoryInfo(struct soap *soap, const char *tag, int id, mtrep__RepositoryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mtrep__RepositoryInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 mtrep__RepositoryInfo ** SOAP_FMAC4 soap_in_PointerTomtrep__RepositoryInfo(struct soap *soap, const char *tag, mtrep__RepositoryInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mtrep__RepositoryInfo **)soap_malloc(soap, sizeof(mtrep__RepositoryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mtrep__RepositoryInfo *)repository_instantiate_mtrep__RepositoryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mtrep__RepositoryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mtrep__RepositoryInfo, sizeof(mtrep__RepositoryInfo), 0, repository_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomtrep__RepositoryInfo(struct soap *soap, mtrep__RepositoryInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomtrep__RepositoryInfo(soap, tag?tag:"mtrep:RepositoryInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mtrep__RepositoryInfo ** SOAP_FMAC4 soap_get_PointerTomtrep__RepositoryInfo(struct soap *soap, mtrep__RepositoryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomtrep__RepositoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag?tag:"QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3(struct soap *soap, std::vector<mtrep6__RepositoryInfo3 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3(struct soap *soap, const std::vector<mtrep6__RepositoryInfo3 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<mtrep6__RepositoryInfo3 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTomtrep6__RepositoryInfo3(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3(struct soap *soap, const char *tag, int id, const std::vector<mtrep6__RepositoryInfo3 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<mtrep6__RepositoryInfo3 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTomtrep6__RepositoryInfo3(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<mtrep6__RepositoryInfo3 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3(struct soap *soap, const char *tag, std::vector<mtrep6__RepositoryInfo3 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3(soap)))
			return NULL;
		mtrep6__RepositoryInfo3 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_mtrep6__RepositoryInfo3, SOAP_TYPE_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3, sizeof(mtrep6__RepositoryInfo3), 1, repository_finsert, repository_fbase))
				break;
			if (!soap_in_PointerTomtrep6__RepositoryInfo3(soap, tag, NULL, "mtrep6:RepositoryInfo3"))
				break;
		}
		else
		{	if (!soap_in_PointerTomtrep6__RepositoryInfo3(soap, tag, &n, "mtrep6:RepositoryInfo3"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<mtrep6__RepositoryInfo3 *>  * SOAP_FMAC2 repository_instantiate_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<mtrep6__RepositoryInfo3 *> *p;
	size_t k = sizeof(std::vector<mtrep6__RepositoryInfo3 *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<mtrep6__RepositoryInfo3 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<mtrep6__RepositoryInfo3 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<mtrep6__RepositoryInfo3 *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTomtrep6__RepositoryInfo3, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2(struct soap *soap, std::vector<mtrep5__RepositoryInfo2 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2(struct soap *soap, const std::vector<mtrep5__RepositoryInfo2 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<mtrep5__RepositoryInfo2 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTomtrep5__RepositoryInfo2(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2(struct soap *soap, const char *tag, int id, const std::vector<mtrep5__RepositoryInfo2 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<mtrep5__RepositoryInfo2 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTomtrep5__RepositoryInfo2(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<mtrep5__RepositoryInfo2 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2(struct soap *soap, const char *tag, std::vector<mtrep5__RepositoryInfo2 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2(soap)))
			return NULL;
		mtrep5__RepositoryInfo2 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_mtrep5__RepositoryInfo2, SOAP_TYPE_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2, sizeof(mtrep5__RepositoryInfo2), 1, repository_finsert, repository_fbase))
				break;
			if (!soap_in_PointerTomtrep5__RepositoryInfo2(soap, tag, NULL, "mtrep5:RepositoryInfo2"))
				break;
		}
		else
		{	if (!soap_in_PointerTomtrep5__RepositoryInfo2(soap, tag, &n, "mtrep5:RepositoryInfo2"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<mtrep5__RepositoryInfo2 *>  * SOAP_FMAC2 repository_instantiate_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<mtrep5__RepositoryInfo2 *> *p;
	size_t k = sizeof(std::vector<mtrep5__RepositoryInfo2 *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<mtrep5__RepositoryInfo2 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<mtrep5__RepositoryInfo2 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<mtrep5__RepositoryInfo2 *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTomtrep5__RepositoryInfo2, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo(struct soap *soap, std::vector<mtrep3__RepositoryInfo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo(struct soap *soap, const std::vector<mtrep3__RepositoryInfo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<mtrep3__RepositoryInfo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTomtrep3__RepositoryInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo(struct soap *soap, const char *tag, int id, const std::vector<mtrep3__RepositoryInfo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<mtrep3__RepositoryInfo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTomtrep3__RepositoryInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<mtrep3__RepositoryInfo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo(struct soap *soap, const char *tag, std::vector<mtrep3__RepositoryInfo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo(soap)))
			return NULL;
		mtrep3__RepositoryInfo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_mtrep3__RepositoryInfo, SOAP_TYPE_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo, sizeof(mtrep3__RepositoryInfo), 1, repository_finsert, repository_fbase))
				break;
			if (!soap_in_PointerTomtrep3__RepositoryInfo(soap, tag, NULL, "mtrep3:RepositoryInfo"))
				break;
		}
		else
		{	if (!soap_in_PointerTomtrep3__RepositoryInfo(soap, tag, &n, "mtrep3:RepositoryInfo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<mtrep3__RepositoryInfo *>  * SOAP_FMAC2 repository_instantiate_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<mtrep3__RepositoryInfo *> *p;
	size_t k = sizeof(std::vector<mtrep3__RepositoryInfo *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<mtrep3__RepositoryInfo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<mtrep3__RepositoryInfo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<mtrep3__RepositoryInfo *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTomtrep3__RepositoryInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTomtrep__RepositoryInfo(struct soap *soap, std::vector<mtrep__RepositoryInfo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTomtrep__RepositoryInfo(struct soap *soap, const std::vector<mtrep__RepositoryInfo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<mtrep__RepositoryInfo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTomtrep__RepositoryInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTomtrep__RepositoryInfo(struct soap *soap, const char *tag, int id, const std::vector<mtrep__RepositoryInfo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<mtrep__RepositoryInfo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTomtrep__RepositoryInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<mtrep__RepositoryInfo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTomtrep__RepositoryInfo(struct soap *soap, const char *tag, std::vector<mtrep__RepositoryInfo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTomtrep__RepositoryInfo(soap)))
			return NULL;
		mtrep__RepositoryInfo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_mtrep__RepositoryInfo, SOAP_TYPE_std__vectorTemplateOfPointerTomtrep__RepositoryInfo, sizeof(mtrep__RepositoryInfo), 1, repository_finsert, repository_fbase))
				break;
			if (!soap_in_PointerTomtrep__RepositoryInfo(soap, tag, NULL, "mtrep:RepositoryInfo"))
				break;
		}
		else
		{	if (!soap_in_PointerTomtrep__RepositoryInfo(soap, tag, &n, "mtrep:RepositoryInfo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<mtrep__RepositoryInfo *>  * SOAP_FMAC2 repository_instantiate_std__vectorTemplateOfPointerTomtrep__RepositoryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "repository_instantiate_std__vectorTemplateOfPointerTomtrep__RepositoryInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<mtrep__RepositoryInfo *> *p;
	size_t k = sizeof(std::vector<mtrep__RepositoryInfo *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<mtrep__RepositoryInfo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<mtrep__RepositoryInfo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<mtrep__RepositoryInfo *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTomtrep__RepositoryInfo, n, repository_fdelete);
	if (size)
		*size = k;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of repositoryC.cpp */
